
/home/pchizek/dev/press-reg/bin/targets/blinky/app/apps/blinky/blinky.elf:     file format elf32-littlearm
/home/pchizek/dev/press-reg/bin/targets/blinky/app/apps/blinky/blinky.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000c0d9

Program Header:
0x70000001 off    0x00010a20 vaddr 0x00010a20 paddr 0x00010a20 align 2**2
         filesz 0x00000018 memsz 0x00000018 flags r--
    LOAD off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**16
         filesz 0x00010a38 memsz 0x00010a38 flags rwx
    LOAD off    0x000200b4 vaddr 0x200000b4 paddr 0x00010a38 align 2**16
         filesz 0x00000074 memsz 0x00002478 flags rw-
    LOAD off    0x0002252c vaddr 0x2000252c paddr 0x00010aac align 2**16
         filesz 0x00000000 memsz 0x00000200 flags rw-
    LOAD off    0x00030000 vaddr 0x20000000 paddr 0x20000000 align 2**16
         filesz 0x00000000 memsz 0x000000b4 flags rw-
private flags = 5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn  Flags
  0 .imghdr       00000020  0000c000  0000c000  0000c000  2**0  ALLOC
  1 .text         00004a00  0000c020  0000c020  0000c020  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .ARM.exidx    00000018  00010a20  00010a20  00010a20  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .vector_relocation 000000b4  20000000  20000000  00030000  2**0  ALLOC
  4 .relocate     00000074  200000b4  00010a38  000200b4  2**2  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00002404  20000128  00010aac  00020128  2**3  ALLOC
  6 .heap         00000200  2000252c  00010aac  0002252c  2**0  ALLOC
  7 .stack_dummy  00000400  2000272c  2000272c  00020128  2**0  CONTENTS
  8 .debug_info   0003ccbe  00000000  00000000  00020528  2**0  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000098a7  00000000  00000000  0005d1e6  2**0  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000ea38  00000000  00000000  00066a8d  2**0  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00001338  00000000  00000000  000754c8  2**3  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00001940  00000000  00000000  00076800  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001028b  00000000  00000000  00078140  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c079  00000000  00000000  000883cb  2**0  CONTENTS, READONLY, DEBUGGING
 15 .comment      00000021  00000000  00000000  00094444  2**0  CONTENTS, READONLY
 16 .ARM.attributes 0000002f  00000000  00000000  00094465  2**0  CONTENTS, READONLY
 17 .svc_table    00000004  00000000  00000000  00094494  2**0  CONTENTS, READONLY
 18 .debug_frame  00002b54  00000000  00000000  00094498  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
0000c000 l    d  .imghdr	00000000 .imghdr
0000c020 l    d  .text	00000000 .text
00010a20 l    d  .ARM.exidx	00000000 .ARM.exidx
20000000 l    d  .vector_relocation	00000000 .vector_relocation
200000b4 l    d  .relocate	00000000 .relocate
20000128 l    d  .bss	00000000 .bss
2000252c l    d  .heap	00000000 .heap
2000272c l    d  .stack_dummy	00000000 .stack_dummy
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .svc_table	00000000 .svc_table
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 startup_samd21.c
00000000 l    df *ABS*	00000000 system_samd21.c
00000000 l    df *ABS*	00000000 gclk.c
0000c1a0 l     F .text	0000000c system_gclk_is_syncing
00000000 l    df *ABS*	00000000 system.c
00000000 l    df *ABS*	00000000 interrupt_sam_nvic.c
20000128 l     O .bss	00000004 cpu_irq_critical_section_counter
2000012c l     O .bss	00000001 cpu_irq_prev_interrupt_state
00000000 l    df *ABS*	00000000 clock.c
0000c460 l     F .text	00000010 _system_dfll_wait_for_sync
20000130 l     O .bss	00000018 _system_clock_inst
00000000 l    df *ABS*	00000000 start.c
00000000 l    df *ABS*	00000000 main.c
20000148 l     O .bss	00000004 g_task1_loops
00000000 l    df *ABS*	00000000 cmsis_nvic.c
00000000 l    df *ABS*	00000000 hal_gpio.c
000107dc l     O .text	00000008 valid_pins
00000000 l    df *ABS*	00000000 extint.c
0000c7f0 l     F .text	0000000c extint_is_syncing
0000c7fc l     F .text	0000001c _extint_enable
00000000 l    df *ABS*	00000000 port.c
00000000 l    df *ABS*	00000000 pinmux.c
0000c88c l     F .text	00000084 _system_pinmux_config
00000000 l    df *ABS*	00000000 os_fault.c
00000000 l    df *ABS*	00000000 os.c
0000ca70 l     F .text	00000016 os_main
2000014c l     O .bss	00001000 os_main_stack
2000114c l     O .bss	00000050 os_main_task
00000000 l    df *ABS*	00000000 os_callout.c
00000000 l    df *ABS*	00000000 os_dev.c
0000cc58 l     F .text	00000020 os_dev_initialize
2000119c l     O .bss	00000008 g_os_dev_list
00000000 l    df *ABS*	00000000 os_eventq.c
200011a4 l     O .bss	00000010 os_eventq_main
00000000 l    df *ABS*	00000000 os_msys_init.c
200011b4 l     O .bss	00000db0 os_msys_init_1_data
20001f64 l     O .bss	0000000c os_msys_init_1_mbuf_pool
20001f70 l     O .bss	00000020 os_msys_init_1_mempool
00000000 l    df *ABS*	00000000 os_sanity.c
0000ce8c l     F .text	00000020 os_sanity_check_list_lock
0000ceac l     F .text	0000001c os_sanity_check_list_unlock
00000000 l    df *ABS*	00000000 os_sched.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
0000d270 l     F .text	00000058 os_deltatime
20001f98 l     O .bss	00000030 basetod
00000000 l    df *ABS*	00000000 os_arch_arm.c
00000000 l    df *ABS*	00000000 os_mbuf.c
00000000 l    df *ABS*	00000000 os_mempool.c
00000000 l    df *ABS*	00000000 os_mutex.c
00000000 l    df *ABS*	00000000 HAL_CM0.S
0000d7f2 l       .text	00000000 SVC_User
0000d810 l       .text	00000000 SVC_Done
0000d820 l       .text	00000000 context_switch
00010907 l       .text	00000000 file_name
0000d872 l       .text	00000000 using_msp_as_sp
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 console.c
0000d8d6 l     F .text	00000016 cursor_save
0000d8ec l     F .text	00000016 cursor_restore
0000d904 l     F .text	00000040 console_append_char
0000d944 l     F .text	00000040 del_char
0000d984 l     F .text	00000060 insert_char
0000d9e4 l     F .text	00000140 handle_ansi
20001fcc l     O .bss	00000004 ansi_val
20001fd0 l     O .bss	00000004 ansi_val_2
20001fd4 l     O .bss	00000004 avail_queue
20001fd8 l     O .bss	00000004 completion
20001fdc l     O .bss	00000004 console_compat_rx_cb
20001fe0 l     O .bss	00000001 cur
20001fe1 l     O .bss	00000001 end
20001fe4 l     O .bss	00000004 esc_state
20001fe8 l     O .bss	00000004 ev.11235
20001fec l     O .bss	00000004 input.11236
20001ff0 l     O .bss	00000004 lines_queue
20001ff4 l     O .bss	00000004 nlip_state
20001ff8 l     O .bss	00000001 prev_endl.11237
200000d8 l     O .relocate	00000004 echo
00000000 l    df *ABS*	00000000 console_fmt.c
00000000 l    df *ABS*	00000000 ticks.c
200000dc l     O .relocate	00000001 do_ticks
00000000 l    df *ABS*	00000000 uart_console.c
0000de30 l     F .text	00000008 uart_blocking_tx
0000de38 l     F .text	0000000a console_rx_char
0000de44 l     F .text	00000024 console_tx_char
0000de68 l     F .text	00000058 console_queue_char
20001ffc l     O .bss	00000008 cr_tx
20002004 l     O .bss	00000020 cr_tx_buf
20002024 l     O .bss	00000004 uart_dev
20002028 l     O .bss	00000004 write_char_cb
00000000 l    df *ABS*	00000000 sysinit.c
0000dfe8 l     F .text	00000006 sysinit_dflt_panic_cb
00000000 l    df *ABS*	00000000 mem.c
00000000 l    df *ABS*	00000000 blinky-sysinit-app.c
00000000 l    df *ABS*	00000000 hal_bsp.c
2000202c l     O .bss	00000034 hal_uart0
00010964 l     O .text	00000020 uart_cfgs
00000000 l    df *ABS*	00000000 uart_hal.c
0000e0d8 l     F .text	0000000c uart_hal_blocking_tx
0000e0e4 l     F .text	0000000c uart_hal_start_rx
0000e0f0 l     F .text	00000012 uart_hal_close
0000e102 l     F .text	00000040 uart_hal_open
0000e142 l     F .text	0000001a uart_hal_start_tx
00000000 l    df *ABS*	00000000 hal_flash.c
0000e1cc l     F .text	0000005c samd21_flash_init
0000e228 l     F .text	00000030 samd21_flash_sector_info
0000e258 l     F .text	0000002c samd21_flash_erase_sector
0000e284 l     F .text	0000008e samd21_flash_write
0000e312 l     F .text	00000072 samd21_flash_read
00010984 l     O .text	00000014 samd21_flash_funcs
00000000 l    df *ABS*	00000000 hal_os_tick.c
00000000 l    df *ABS*	00000000 hal_system.c
00000000 l    df *ABS*	00000000 hal_timer.c
0000e410 l     F .text	00000050 samd21_timer_set_ocmp
0000e460 l     F .text	00000054 hal_timer_read_bsptimer
00010998 l     O .text	00000018 CSWTCH.32
000109b0 l     O .text	0000000c samd21_hal_timers
00000000 l    df *ABS*	00000000 hal_uart.c
0000e738 l     F .text	00000020 fill_tx_buf
0000e758 l     F .text	00000028 usart_callback_rx
0000e780 l     F .text	0000003c usart_callback_txdone
20002060 l     O .bss	000001f8 uarts
00000000 l    df *ABS*	00000000 hal_watchdog.c
00000000 l    df *ABS*	00000000 nvm.c
0000eb2c l     F .text	00000010 nvm_is_ready
20002258 l     O .bss	00000006 _nvm_dev
00000000 l    df *ABS*	00000000 sercom_interrupt.c
0000ee10 l     F .text	00000002 _sercom_default_handler
2000225e l     O .bss	00000001 _handler_table_initialized
20002260 l     O .bss	00000018 _sercom_interrupt_handlers
00000000 l    df *ABS*	00000000 usart.c
0000ef18 l     F .text	0000000a _usart_wait_for_sync
00000000 l    df *ABS*	00000000 usart_interrupt.c
00000000 l    df *ABS*	00000000 tc.c
00000000 l    df *ABS*	00000000 wdt.c
00000000 l    df *ABS*	00000000 sercom.c
20002278 l     O .bss	00000002 _sercom_config
00000000 l    df *ABS*	00000000 os_cputime.c
00000000 l    df *ABS*	00000000 os_heap.c
0000fac8 l     F .text	0000000e os_malloc_lock.part.0
0000fac8 l     F .text	0000000e os_malloc_unlock.part.1
0000fad8 l     F .text	00000028 os_malloc_lock
0000fb00 l     F .text	00000024 os_malloc_unlock
2000227c l     O .bss	0000000c os_malloc_mutex
00000000 l    df *ABS*	00000000 malloc.c
0000fb50 l     F .text	00000004 malloc_lock_nop
0000fb54 l     F .text	00000002 malloc_unlock_nop
0000fb58 l     F .text	00000060 __free_block
200000f8 l     O .relocate	00000018 __malloc_head
20000110 l     O .relocate	00000004 malloc_lock
20000114 l     O .relocate	00000004 malloc_unlock
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 tinyprintf.c
0000fcd8 l     F .text	000000b4 ui2a
0000fd8c l     F .text	00000020 putf
0000fdac l     F .text	0000010c putchw
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 mynewt.c
00010114 l     F .text	00000004 stdin_read
00010118 l     F .text	00000010 stdout_write
20000118 l     O .relocate	00000004 _stdin
2000011c l     O .relocate	00000008 _stdin_methods
00000000 l    df *ABS*	00000000 flash_map.c
20002288 l     O .bss	00000078 mfg_areas.11176
00000000 l    df *ABS*	00000000 mfg.c
00000000 l    df *ABS*	00000000 sbrk.c
20000124 l     O .relocate	00000004 _brk
00000000 l    df *ABS*	00000000 hal_flash.c
000103b4 l     F .text	00000016 hal_flash_check_addr
00000000 l    df *ABS*	00000000 _thumb1_case_uqi.o
00000000 l    df *ABS*	00000000 _udivsi3.o
00010444 l       .text	00000000 .udivsi3_skip_div0_test
00000000 l    df *ABS*	00000000 _ashldi3.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _clzdi2.o
00000000 l    df *ABS*	00000000 _clzsi2.o
00000000 l    df *ABS*	00000000 blinky-sysflash.c
00000000 l    df *ABS*	00000000 SVC_Table.S
00000000 l       .svc_table	00000000 SVC_End
0000df70 g     F .text	00000078 uart_console_init
0000d4ac g     F .text	00000038 os_arch_start
2000252c g       .bss	00000000 __HeapBase
200024bc g     O .bss	00000008 g_os_task_list
0000c9f0 g     F .text	00000080 os_idle_task
00010558 g     F .text	00000018 .hidden __ashldi3
0000ec60 g     F .text	00000098 nvm_write_buffer
00000000 g       .svc_table	00000000 SVC_Count
200000d0 g     O .relocate	00000008 g_os_mempool_list
0000c430 g     F .text	00000030 cpu_irq_leave_critical
0000fbb8 g     F .text	00000050 add_malloc_block
0000cdb0 g     F .text	00000052 os_eventq_put
0000f25a g     F .text	00000018 usart_register_callback
00000400 g       *ABS*	00000000 STACK_SIZE
0000c6b0 g     F .text	00000014 NVIC_SetVector
0000c0d4  w    F .text	00000002 DMAC_Handler
000100e0 g     F .text	00000020 printf
000109d4 g     O .text	00000004 stdout
0000c734 g     F .text	00000044 hal_gpio_write
0000d3e8 g     F .text	000000c0 os_arch_os_init
0000c0d4  w    F .text	00000002 HardFault_Handler
0000e534 g     F .text	000000ec hal_timer_init
0000d4e4 g     F .text	00000054 os_arch_os_start
0000f7b4 g     F .text	00000140 _sercom_get_async_baud_val
00000200 g       *ABS*	00000000 _Min_Stack_Size
0000c0d4  w    F .text	00000002 AC_Handler
0000d850 g     F .text	00000008 SysTick_Handler
20002518 g     O .bss	00000004 flash_map
0000df14 g     F .text	00000020 uart_console_non_blocking_mode
0000d812 g     F .text	0000003e PendSV_Handler
0000c0d4  w    F .text	00000002 NMI_Handler
0000c020 g       .text	00000000 __isr_vector_start
0000c3f0 g     F .text	0000000c system_init
0000d37c g     F .text	00000014 os_arch_ctx_sw
0000e15c g     F .text	00000070 uart_hal_init
0000e3d8 g     F .text	00000028 hal_system_reset
0000c020 g       .text	00000000 _sfixed
0000ca94 g     F .text	0000005c os_init_idle_task
200000d8 g       .relocate	00000000 __aeabi_unwind_cpp_pr0
0000cfe4 g     F .text	0000000c os_sched_set_current_task
0000c3a0 g     F .text	00000028 system_gclk_chan_lock
0000ee24 g     F .text	00000010 SERCOM1_Handler
0000d610 g     F .text	000000bc os_mutex_release
0000c0d4  w    F .text	00000002 ADC_Handler
0000ced8 g     F .text	00000020 os_sanity_check_register
0000d34c g     F .text	00000024 os_time_delay
00010a38 g       .vector_relocation	00000000 _etext
20000128 g       .bss	00000000 _sbss
000102c0 g     F .text	00000044 mfg_read_tlv_flash_area
0000de24 g     F .text	0000000c console_get_ticks
0000d3a4 g     F .text	0000000a os_arch_in_critical
20000128 g       .bss	00000000 _szero
0000c0d4  w    F .text	00000002 TCC1_Handler
0000d370 g     F .text	0000000a timer_handler
0000cd20 g     F .text	00000024 os_dev_lookup
0000d014 g     F .text	00000078 os_sched_sleep
200000b4 g       .relocate	00000000 _srelocate
0000eaa0 g     F .text	00000070 hal_watchdog_init
0000fabc g     F .text	0000000c os_cputime_init
0000f6ac g     F .text	000000cc wdt_set_config
00010570 g     F .text	0000003e .hidden __aeabi_uldivmod
0000ee74 g     F .text	00000020 _sercom_get_interrupt_vector
0000ee34 g     F .text	00000010 SERCOM2_Handler
00000020 g       *ABS*	00000000 _imghdr_size
0000cfac g     F .text	0000002c os_sched_ctx_sw_hook
200024cc g     O .bss	00000004 console_is_midline
00010a20 g       .text	00000000 __fini_array_end
20002300 g     O .bss	00000004 SystemCoreClock
0000c0d4  w    F .text	00000002 TCC0_Handler
0000c388 g     F .text	00000018 system_gclk_chan_set_config
0000d3ae g     F .text	00000032 os_arch_task_stack_init
0000fc08 g     F .text	00000098 malloc
0001016a g     F .text	00000020 flash_area_read
00010444 g     F .text	0000010a .hidden __udivsi3
0000c938 g     F .text	00000034 __assert_func
0000d130 g     F .text	0000003c os_sched_wakeup_ticks
0000ddac g     F .text	00000038 console_pkg_init
0000c0d4  w    F .text	00000002 RTC_Handler
20007c00 g       *ABS*	00000000 _user_heap_end
0000c0d4  w    F .text	00000002 Unhandled_Handler
200024a0 g     O .bss	00000008 g_callout_list
0000fb24 g     F .text	00000018 os_malloc
0000feb8 g     F .text	0000021e tfp_format
20007c00 g       *ABS*	00000000 __HeapLimit
20000128 g       .bss	00000000 __bss_start__
0000e400 g     F .text	00000010 hal_debugger_connected
0000c3fc g     F .text	00000034 cpu_irq_enter_critical
0000ed60 g     F .text	00000054 nvm_erase_row
00010604 g     F .text	00000182 .hidden __udivmoddi4
0000c2a0 g     F .text	00000070 system_gclk_gen_get_hz
200024b4 g     O .bss	00000004 g_current_task
0000cef8 g     F .text	00000058 os_sanity_run
00010430 g     F .text	00000012 .hidden __gnu_thumb1_case_uqi
0000d390 g     F .text	0000000c os_arch_save_sr
0000ea40 g     F .text	00000044 hal_uart_close
0000d594 g     F .text	00000068 os_mempool_init
20002304 g     O .bss	00000004 g_led_pin
200024c4 g     O .bss	00000001 g_task_id
200000b4 g     O .relocate	00000001 g_interrupt_enabled
0000f1da g     F .text	00000038 _usart_write_buffer
0000c0d4  w    F .text	00000002 WDT_Handler
0000e860 g     F .text	00000034 hal_uart_blocking_tx
200000c8 g     O .relocate	00000008 g_msys_pool_list
0000c1cc g     F .text	0000009c system_gclk_gen_set_config
0000cf50 g     F .text	00000010 os_sanity_init
0000d7ac g     F .text	00000014 os_set_env
000105b0 g     F .text	00000054 .hidden __aeabi_lmul
0000e048 g     F .text	00000010 hal_bsp_flash_dev
0000c648 g     F .text	00000002 __libc_init_array
200024a8 g     O .bss	0000000c g_os_sanity_check_mu
0000fb3c g     F .text	00000014 os_free
0001038c g     F .text	00000028 _sbrk
0000f212 g     F .text	00000048 _usart_read_buffer
0000e384 g     F .text	0000001c os_tick_idle
0000dde4 g     F .text	00000040 console_printf
0000f78c g     F .text	00000028 _sercom_get_sync_baud_val
0000db40 g     F .text	00000008 console_blocking_mode
0000c0d4  w    F .text	00000002 TC4_Handler
0000c4f4 g     F .text	0000003c system_clock_source_osc8m_set_config
0000e3a0 g     F .text	00000038 os_tick_init
0000f404 g     F .text	00000030 _tc_get_inst_index
2000252c g       .bss	00000000 _ebss
0000caf0 g     F .text	00000094 os_init
0000c0d8 g     F .text	000000a4 Reset_Handler
0000c0d4  w    F .text	00000002 USB_Handler
200024d0 g     O .bss	00000001 sysinit_active
0000ecf8 g     F .text	00000068 nvm_read_buffer
0000d588 g     F .text	0000000c os_mbuf_pool_init
0000c0d4  w    F .text	00000002 TC3_Handler
0000c7d4 g     F .text	0000001a hal_gpio_toggle
0000d862 g     F .text	00000032 os_default_irq_asm
0000d16c g     F .text	0000000c os_sched_next_task
0000c0d4 g     F .text	00000002 Dummy_Handler
0000cf60 g     F .text	0000004c os_sched_insert
00010304 g     F .text	00000088 mfg_init
0000cd88 g     F .text	00000010 os_dev_reset
0000d5fc g     F .text	00000014 os_mutex_init
0000ce02 g     F .text	0000001c os_eventq_get_no_wait
20002500 g     O .bss	00000018 _sercom_instances
0001018c g     F .text	000000ac flash_map_init
00010100 g     F .text	00000014 vprintf
0000ca88 g     F .text	0000000c os_started
20000000 g       .heap	00000000 _ram_start
0000d0f4 g     F .text	0000003c os_sched_os_timer_exp
20000000 g       .vector_relocation	00000000 __vector_tbl_reloc__
0000ee94 g     F .text	00000084 _sercom_set_handler
000102a4 g     F .text	0000001c mfg_next_tlv_with_type
200000e4 g     O .relocate	00000014 samd21_flash_dev
0000c818 g     F .text	00000058 _system_extint_init
000107a0 g     F .text	0000003c .hidden __clzsi2
200024c8 g     O .bss	00000004 g_os_time
0000e7bc g     F .text	00000030 hal_uart_init_cbs
0000eb24 g     F .text	00000008 hal_watchdog_tickle
2000252c g       .bss	00000000 __bss_end__
00000200 g       *ABS*	00000000 _Min_Heap_Size
0000d578 g     F .text	00000010 os_msys_reset
0000c634 g     F .text	00000014 _start
20002308 g     O .bss	00000040 _extint_dev
0000f1b0 g     F .text	0000002a usart_write_wait
0000c0d4  w    F .text	00000002 PM_Handler
0000ee64 g     F .text	00000010 SERCOM5_Handler
0000d7c0 g     F .text	00000012 os_arch_init_task_stack
0000edb4 g     F .text	0000005c nvm_get_parameters
0000c3c8 g     F .text	00000028 system_gclk_chan_get_hz
20002348 g     O .bss	00000050 g_idle_task
0000c778 g     F .text	0000005c hal_gpio_init_out
0000c6c4 g     F .text	00000070 hal_gpio_read
200000e0 g     O .relocate	00000004 sysinit_panic_cb
20001f90 g     O .bss	00000004 g_os_sanity_check_list
0000e814 g     F .text	0000004c hal_uart_start_tx
0000d08c g     F .text	00000068 os_sched_wakeup
0000e008 g     F .text	0000002c mem_init_mbuf_pool
0000c96c g     F .text	00000084 os_default_irq
200024b8 g     O .bss	00000004 g_os_last_ctx_sw_time
0000d3e0 g     F .text	00000008 os_arch_init
0000c268 g     F .text	00000038 system_gclk_gen_enable
0000d858 g       .text	00000000 __aeabi_ldiv0
0000dff0 g     F .text	0000000c sysinit_start
0000e620 g     F .text	00000118 hal_timer_config
0000cd44 g     F .text	00000044 os_dev_open
0000eb10 g     F .text	00000014 hal_watchdog_enable
00010a20 g       .text	00000000 __fini_array_start
0000d53c g     F .text	0000003c os_msys_register
20002398 g     O .bss	00000004 g_os_idle_ctr
00010128 g     F .text	00000040 flash_area_open
0000ef24 g     F .text	0000028c usart_init
0000d8b0 g     F .text	00000010 memset
0000c020 g     O .text	000000b4 __isr_vector
0000c64c g     F .text	0000003c main
00010444 g     F .text	00000000 .hidden __aeabi_uidiv
0000dffc g     F .text	0000000c sysinit_end
0000d7d2 g     F .text	00000040 SVC_Handler
0000c0d4  w    F .text	00000002 TCC2_Handler
0000c0d4  w    F .text	00000002 EVSYS_Handler
00010a20 g       .text	00000000 __init_array_end
000103f4 g     F .text	0000003c hal_flash_read
2000252c g       .bss	00000000 _ezero
0000ce20 g     F .text	00000008 os_eventq_dflt_get
0000ee44 g     F .text	00000010 SERCOM3_Handler
00010168 g     F .text	00000002 flash_area_close
0000ee54 g     F .text	00000010 SERCOM4_Handler
0000cc24 g     F .text	00000034 os_callout_wakeup_ticks
0000c0d4  w    F .text	00000002 I2S_Handler
2000251c g     O .bss	00000004 flash_map_entries
0000f8f4 g     F .text	0000003c sercom_set_gclk_generator
0000d8c0 g     F .text	00000016 strcmp
0000dec0 g     F .text	00000054 uart_console_blocking_mode
0000cfd8 g     F .text	0000000c os_sched_get_current_task
0000c310 g     F .text	00000028 system_gclk_chan_enable
0000db24 g     F .text	0000001c console_write
0000c0d4  w    F .text	00000002 NVMCTRL_Handler
0000c17c g     F .text	00000024 SystemInit
00010a20 g       .text	00000000 _efixed
0000c870 g     F .text	0000001c port_pin_set_config
0000f298 g     F .text	0000016c _usart_interrupt_handler
0000ebbc g     F .text	000000a4 nvm_execute_command
0000cff0 g     F .text	00000024 os_sched
0000e7ec g     F .text	00000028 hal_uart_start_rx
0000d6cc g     F .text	000000e0 os_mutex_pend
00000000 g       .svc_table	00000000 SVC_Table
0000ee14 g     F .text	00000010 SERCOM0_Handler
20008000 g       .heap	00000000 __StackTop
0000c5bc g     F .text	00000078 system_clock_init
20002520 g     O .bss	0000000c mfg_state
00010a20 g       .text	00000000 __preinit_array_end
0000eb3c g     F .text	00000080 nvm_set_config
0000c530 g     F .text	0000008c system_clock_source_enable
0000cbcc g     F .text	00000058 os_callout_tick
000109d8 g     O .text	00000048 sysflash_map_dflt
0000c0d4 g       .text	00000000 __isr_vector_end
0000cb84 g     F .text	0000001c os_start
200024d4 g     O .bss	00000024 samd21_hal_timer0
0000c0d4  w    F .text	00000002 DAC_Handler
0000e894 g     F .text	000001ac hal_uart_config
00010558 g     F .text	00000018 .hidden __aeabi_llsl
0000c470 g     F .text	00000084 system_clock_source_get_hz
0000e4b4 g     F .text	00000080 samd21_timer0_irq_handler
0000db48 g     F .text	00000264 console_handle_char
00010550 g     F .text	00000008 .hidden __aeabi_uidivmod
20000128 g       .relocate	00000000 _erelocate
200000b8 g     O .relocate	00000008 g_os_run_list
2000239c g     O .bss	00000100 g_idle_task_stack
0000f662 g     F .text	0000004a tc_set_compare_value
0000c688 g     F .text	00000028 NVIC_Relocate
0000e034 g     F .text	00000014 sysinit_app
0000c338 g     F .text	00000050 system_gclk_chan_disable
20001fc8 g     O .bss	00000004 os_flags
0000d39c g     F .text	00000008 os_arch_restore_sr
20007c00 g       *ABS*	00000000 __StackLimit
0000c0d4  w    F .text	00000002 PTC_Handler
2000249c g     O .bss	00000004 g_os_started
0000ce28 g     F .text	00000064 os_msys_init
0000d2c8 g     F .text	0000000c os_time_get
0000f638 g     F .text	0000002a tc_get_count_value
2000252c g       .heap	00000000 _user_heap_start
00010a20 g       .text	00000000 __init_array_start
0000d858 g     F .text	0000000a __aeabi_idiv0
0000fa8c g     F .text	00000030 _sercom_get_sercom_inst_index
200024f8 g     O .bss	00000006 g_wdt_config
0000f27c g     F .text	0000001a usart_write_buffer_job
0000c910 g     F .text	00000028 system_pinmux_pin_set_config
0000d1a0 g     F .text	000000d0 os_task_init
000105b0 g     F .text	00000054 .hidden __muldi3
0000fcc8 g     F .text	00000010 strlen
0000cc78 g     F .text	0000007c os_dev_create
0000cd98 g     F .text	00000018 os_eventq_init
0000c1ac g     F .text	00000020 system_gclk_init
0000d2d4 g     F .text	00000078 os_time_advance
0000d178 g     F .text	00000028 os_sched_resort
000103ca g     F .text	0000002a hal_flash_init
0000f930 g     F .text	0000015c _sercom_get_default_pad
0000ccf4 g     F .text	0000002c os_dev_initialize_all
00010788 g     F .text	00000016 .hidden __clzdi2
0000f272 g     F .text	0000000a usart_read_job
00010a20 g       .text	00000000 __preinit_array_start
0000c0d4  w    F .text	00000002 TC5_Handler
0000f778 g     F .text	00000014 wdt_reset_count
200000c0 g     O .relocate	00000008 g_os_sleep_list
0000e058 g     F .text	00000080 hal_bsp_init
0000cba0 g     F .text	0000002c os_pkg_init
00010238 g     F .text	0000006c mfg_next_tlv
0000cec8 g     F .text	0000000e os_sanity_check_init
0000ea84 g     F .text	0000001c hal_uart_init
000100d6 g     F .text	00000008 vfprintf
0000f434 g     F .text	00000204 tc_init
0000fca0 g     F .text	00000028 free
0000c0d4  w    F .text	00000002 SYSCTRL_Handler
0000df34 g     F .text	0000003c console_out



Disassembly of section .text:

0000c020 <__isr_vector>:
    c020:	00 80 00 20 d9 c0 00 00 d5 c0 00 00 d5 c0 00 00     ... ............
    c030:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c040:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d3 d7 00 00     ................
    c050:	d5 c0 00 00 d5 c0 00 00 13 d8 00 00 51 d8 00 00     ............Q...
    c060:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c070:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c080:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c090:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c0a0:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c0b0:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c0c0:	d5 c0 00 00 d5 c0 00 00 d5 c0 00 00 d5 c0 00 00     ................
    c0d0:	00 00 00 00                                         ....

0000c0d4 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    c0d4:	e7fe      	b.n	c0d4 <Dummy_Handler>
	...

0000c0d8 <Reset_Handler>:
        if (pSrc != pDest) {
    c0d8:	481f      	ldr	r0, [pc, #124]	; (c158 <Reset_Handler+0x80>)
    c0da:	4920      	ldr	r1, [pc, #128]	; (c15c <Reset_Handler+0x84>)
{
    c0dc:	b570      	push	{r4, r5, r6, lr}
    c0de:	2300      	movs	r3, #0
        if (pSrc != pDest) {
    c0e0:	4288      	cmp	r0, r1
    c0e2:	d132      	bne.n	c14a <Reset_Handler+0x72>
                *pDest++ = 0;
    c0e4:	2100      	movs	r1, #0
    c0e6:	4b1e      	ldr	r3, [pc, #120]	; (c160 <Reset_Handler+0x88>)
        for (pDest = &_szero; pDest < &_ezero;) {
    c0e8:	4a1e      	ldr	r2, [pc, #120]	; (c164 <Reset_Handler+0x8c>)
    c0ea:	4293      	cmp	r3, r2
    c0ec:	d332      	bcc.n	c154 <Reset_Handler+0x7c>
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    c0ee:	2202      	movs	r2, #2
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    c0f0:	2103      	movs	r1, #3
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    c0f2:	250c      	movs	r5, #12
    c0f4:	2408      	movs	r4, #8
        DMAC->QOSCTRL.bit.DQOS = 2;
    c0f6:	2630      	movs	r6, #48	; 0x30
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    c0f8:	4b1b      	ldr	r3, [pc, #108]	; (c168 <Reset_Handler+0x90>)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    c0fa:	481c      	ldr	r0, [pc, #112]	; (c16c <Reset_Handler+0x94>)
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
    c0fc:	625a      	str	r2, [r3, #36]	; 0x24
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
    c0fe:	78c3      	ldrb	r3, [r0, #3]
    c100:	438b      	bics	r3, r1
    c102:	4313      	orrs	r3, r2
    c104:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
    c106:	78c3      	ldrb	r3, [r0, #3]
    c108:	43ab      	bics	r3, r5
    c10a:	4323      	orrs	r3, r4
    c10c:	70c3      	strb	r3, [r0, #3]
        DMAC->QOSCTRL.bit.DQOS = 2;
    c10e:	4b18      	ldr	r3, [pc, #96]	; (c170 <Reset_Handler+0x98>)
    c110:	7b98      	ldrb	r0, [r3, #14]
    c112:	43b0      	bics	r0, r6
    c114:	0006      	movs	r6, r0
    c116:	2020      	movs	r0, #32
    c118:	4330      	orrs	r0, r6
    c11a:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
    c11c:	7b98      	ldrb	r0, [r3, #14]
    c11e:	43a8      	bics	r0, r5
    c120:	4304      	orrs	r4, r0
    c122:	739c      	strb	r4, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
    c124:	7b98      	ldrb	r0, [r3, #14]
    c126:	4388      	bics	r0, r1
    c128:	4302      	orrs	r2, r0
    c12a:	739a      	strb	r2, [r3, #14]
        NVMCTRL->CTRLB.bit.MANW = 1;
    c12c:	2380      	movs	r3, #128	; 0x80
    c12e:	4a11      	ldr	r2, [pc, #68]	; (c174 <Reset_Handler+0x9c>)
    c130:	6851      	ldr	r1, [r2, #4]
    c132:	430b      	orrs	r3, r1
    c134:	6053      	str	r3, [r2, #4]
        __libc_init_array();
    c136:	f000 fa87 	bl	c648 <__libc_init_array>
        SystemInit();
    c13a:	f000 f81f 	bl	c17c <SystemInit>
        _start();
    c13e:	f000 fa79 	bl	c634 <_start>
    c142:	e7fe      	b.n	c142 <Reset_Handler+0x6a>
                        *pDest++ = *pSrc++;
    c144:	58c4      	ldr	r4, [r0, r3]
    c146:	3304      	adds	r3, #4
    c148:	6014      	str	r4, [r2, #0]
                for (; pDest < &_erelocate;) {
    c14a:	4c0b      	ldr	r4, [pc, #44]	; (c178 <Reset_Handler+0xa0>)
    c14c:	18ca      	adds	r2, r1, r3
    c14e:	42a2      	cmp	r2, r4
    c150:	d3f8      	bcc.n	c144 <Reset_Handler+0x6c>
    c152:	e7c7      	b.n	c0e4 <Reset_Handler+0xc>
                *pDest++ = 0;
    c154:	c302      	stmia	r3!, {r1}
    c156:	e7c8      	b.n	c0ea <Reset_Handler+0x12>
    c158:	00010a38 	.word	0x00010a38
    c15c:	200000b4 	.word	0x200000b4
    c160:	20000128 	.word	0x20000128
    c164:	2000252c 	.word	0x2000252c
    c168:	410070fc 	.word	0x410070fc
    c16c:	41005000 	.word	0x41005000
    c170:	41004800 	.word	0x41004800
    c174:	41004000 	.word	0x41004000
    c178:	20000128 	.word	0x20000128

0000c17c <SystemInit>:
 *
 * @brief  Setup the microcontroller system.
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
    c17c:	b510      	push	{r4, lr}
    // Keep the default device state after reset
    system_init();
    c17e:	f000 f937 	bl	c3f0 <system_init>
 *
 * \return Current CPU frequency in Hz.
 */
static inline uint32_t system_cpu_clock_get_hz(void)
{
	return (system_gclk_gen_get_hz(GCLK_GENERATOR_0) >> PM->CPUSEL.reg);
    c182:	2000      	movs	r0, #0
    c184:	f000 f88c 	bl	c2a0 <system_gclk_gen_get_hz>
    c188:	4b03      	ldr	r3, [pc, #12]	; (c198 <SystemInit+0x1c>)
    c18a:	7a1b      	ldrb	r3, [r3, #8]
    c18c:	40d8      	lsrs	r0, r3
    SystemCoreClock = system_cpu_clock_get_hz();    
    c18e:	4b03      	ldr	r3, [pc, #12]	; (c19c <SystemInit+0x20>)
    c190:	6018      	str	r0, [r3, #0]
     * functions are pre-installed in the vector table at startup.  When
     * we relocate the vector table, we overwrite all of their initializations
     * and you need to manually set the vectors for the drivers you are 
     * using. See  sam0/drivers/sercom/sercom_interrupt.c at the end
     * for a simple example of how to do this */
    NVIC_Relocate();    
    c192:	f000 fa79 	bl	c688 <NVIC_Relocate>
    return;
}
    c196:	bd10      	pop	{r4, pc}
    c198:	40000400 	.word	0x40000400
    c19c:	20002300 	.word	0x20002300

0000c1a0 <system_gclk_is_syncing>:
 * \retval false if the module has completed synchronization
 * \retval true if the module synchronization is ongoing
 */
static inline bool system_gclk_is_syncing(void)
{
	if (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY){
    c1a0:	4b01      	ldr	r3, [pc, #4]	; (c1a8 <system_gclk_is_syncing+0x8>)
    c1a2:	7858      	ldrb	r0, [r3, #1]
    c1a4:	09c0      	lsrs	r0, r0, #7
		return true;
	}

	return false;
}
    c1a6:	4770      	bx	lr
    c1a8:	40000c00 	.word	0x40000c00

0000c1ac <system_gclk_init>:
		const enum system_clock_apb_bus bus,
		const uint32_t mask)
{
	switch (bus) {
		case SYSTEM_CLOCK_APB_APBA:
			PM->APBAMASK.reg |= mask;
    c1ac:	2308      	movs	r3, #8
    c1ae:	4a05      	ldr	r2, [pc, #20]	; (c1c4 <system_gclk_init+0x18>)
    c1b0:	6991      	ldr	r1, [r2, #24]
    c1b2:	430b      	orrs	r3, r1
    c1b4:	6193      	str	r3, [r2, #24]
{
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_GCLK);

	/* Software reset the module to ensure it is re-initialized correctly */
	GCLK->CTRL.reg = GCLK_CTRL_SWRST;
    c1b6:	2301      	movs	r3, #1
    c1b8:	4a03      	ldr	r2, [pc, #12]	; (c1c8 <system_gclk_init+0x1c>)
    c1ba:	7013      	strb	r3, [r2, #0]
	while (GCLK->CTRL.reg & GCLK_CTRL_SWRST) {
    c1bc:	7811      	ldrb	r1, [r2, #0]
    c1be:	4219      	tst	r1, r3
    c1c0:	d1fc      	bne.n	c1bc <system_gclk_init+0x10>
		/* Wait for reset to complete */
	}
}
    c1c2:	4770      	bx	lr
    c1c4:	40000400 	.word	0x40000400
    c1c8:	40000c00 	.word	0x40000c00

0000c1cc <system_gclk_gen_set_config>:
 * \param[in] config     Configuration settings for the generator
 */
void system_gclk_gen_set_config(
		const uint8_t generator,
		struct system_gclk_gen_config *const config)
{
    c1cc:	b570      	push	{r4, r5, r6, lr}
	/* Cache new register configurations to minimize sync requirements. */
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
	uint32_t new_gendiv_config  = (generator << GCLK_GENDIV_ID_Pos);

	/* Select the requested source clock for the generator */
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    c1ce:	780c      	ldrb	r4, [r1, #0]

	/* Configure the clock to be either high or low when disabled */
	if (config->high_when_disabled) {
    c1d0:	784b      	ldrb	r3, [r1, #1]
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    c1d2:	0224      	lsls	r4, r4, #8
{
    c1d4:	0006      	movs	r6, r0
	uint32_t new_genctrl_config = (generator << GCLK_GENCTRL_ID_Pos);
    c1d6:	0005      	movs	r5, r0
	new_genctrl_config |= config->source_clock << GCLK_GENCTRL_SRC_Pos;
    c1d8:	4304      	orrs	r4, r0
	if (config->high_when_disabled) {
    c1da:	2b00      	cmp	r3, #0
    c1dc:	d002      	beq.n	c1e4 <system_gclk_gen_set_config+0x18>
		new_genctrl_config |= GCLK_GENCTRL_OOV;
    c1de:	2380      	movs	r3, #128	; 0x80
    c1e0:	02db      	lsls	r3, r3, #11
    c1e2:	431c      	orrs	r4, r3
	}

	/* Configure if the clock output to I/O pin should be enabled. */
	if (config->output_enable) {
    c1e4:	7a4b      	ldrb	r3, [r1, #9]
    c1e6:	2b00      	cmp	r3, #0
    c1e8:	d002      	beq.n	c1f0 <system_gclk_gen_set_config+0x24>
		new_genctrl_config |= GCLK_GENCTRL_OE;
    c1ea:	2380      	movs	r3, #128	; 0x80
    c1ec:	031b      	lsls	r3, r3, #12
    c1ee:	431c      	orrs	r4, r3
	}

	/* Set division factor */
	if (config->division_factor > 1) {
    c1f0:	684b      	ldr	r3, [r1, #4]
    c1f2:	2b01      	cmp	r3, #1
    c1f4:	d910      	bls.n	c218 <system_gclk_gen_set_config+0x4c>
		/* Check if division is a power of two */
		if (((config->division_factor & (config->division_factor - 1)) == 0)) {
    c1f6:	1e5d      	subs	r5, r3, #1
    c1f8:	401d      	ands	r5, r3
    c1fa:	d02f      	beq.n	c25c <system_gclk_gen_set_config+0x90>
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
		} else {
			/* Set integer division factor */

			new_gendiv_config  |=
					(config->division_factor) << GCLK_GENDIV_DIV_Pos;
    c1fc:	021d      	lsls	r5, r3, #8

			/* Enable non-binary division with increased duty cycle accuracy */
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    c1fe:	2380      	movs	r3, #128	; 0x80
			new_gendiv_config  |=
    c200:	4335      	orrs	r5, r6
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    c202:	029b      	lsls	r3, r3, #10
    c204:	e007      	b.n	c216 <system_gclk_gen_set_config+0x4a>
				div2_count++;
    c206:	3501      	adds	r5, #1
						mask <<= 1) {
    c208:	0052      	lsls	r2, r2, #1
			for (mask = (1UL << 1); mask < config->division_factor;
    c20a:	4293      	cmp	r3, r2
    c20c:	d8fb      	bhi.n	c206 <system_gclk_gen_set_config+0x3a>
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    c20e:	2380      	movs	r3, #128	; 0x80
			new_gendiv_config  |= div2_count << GCLK_GENDIV_DIV_Pos;
    c210:	022d      	lsls	r5, r5, #8
    c212:	4335      	orrs	r5, r6
			new_genctrl_config |= GCLK_GENCTRL_DIVSEL;
    c214:	035b      	lsls	r3, r3, #13
			new_genctrl_config |= GCLK_GENCTRL_IDC;
    c216:	431c      	orrs	r4, r3
		}

	}

	/* Enable or disable the clock in standby mode */
	if (config->run_in_standby) {
    c218:	7a0b      	ldrb	r3, [r1, #8]
    c21a:	2b00      	cmp	r3, #0
    c21c:	d002      	beq.n	c224 <system_gclk_gen_set_config+0x58>
		new_genctrl_config |= GCLK_GENCTRL_RUNSTDBY;
    c21e:	2380      	movs	r3, #128	; 0x80
    c220:	039b      	lsls	r3, r3, #14
    c222:	431c      	orrs	r4, r3
	}

	while (system_gclk_is_syncing()) {
    c224:	f7ff ffbc 	bl	c1a0 <system_gclk_is_syncing>
    c228:	2800      	cmp	r0, #0
    c22a:	d1fb      	bne.n	c224 <system_gclk_gen_set_config+0x58>
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_enter_critical_section(void)
{
	cpu_irq_enter_critical();
    c22c:	f000 f8e6 	bl	c3fc <cpu_irq_enter_critical>
	};

	system_interrupt_enter_critical_section();

	/* Select the correct generator */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    c230:	4b0b      	ldr	r3, [pc, #44]	; (c260 <system_gclk_gen_set_config+0x94>)
    c232:	701e      	strb	r6, [r3, #0]

	/* Write the new generator configuration */
	while (system_gclk_is_syncing()) {
    c234:	f7ff ffb4 	bl	c1a0 <system_gclk_is_syncing>
    c238:	2800      	cmp	r0, #0
    c23a:	d1fb      	bne.n	c234 <system_gclk_gen_set_config+0x68>
		/* Wait for synchronization */
	};
	GCLK->GENDIV.reg  = new_gendiv_config;
    c23c:	4b09      	ldr	r3, [pc, #36]	; (c264 <system_gclk_gen_set_config+0x98>)
    c23e:	609d      	str	r5, [r3, #8]
    c240:	001d      	movs	r5, r3

	while (system_gclk_is_syncing()) {
    c242:	f7ff ffad 	bl	c1a0 <system_gclk_is_syncing>
    c246:	2800      	cmp	r0, #0
    c248:	d1fb      	bne.n	c242 <system_gclk_gen_set_config+0x76>
		/* Wait for synchronization */
	};
	GCLK->GENCTRL.reg = new_genctrl_config | (GCLK->GENCTRL.reg & GCLK_GENCTRL_GENEN);
    c24a:	2280      	movs	r2, #128	; 0x80
    c24c:	686b      	ldr	r3, [r5, #4]
    c24e:	0252      	lsls	r2, r2, #9
    c250:	4013      	ands	r3, r2
    c252:	431c      	orrs	r4, r3
    c254:	606c      	str	r4, [r5, #4]
 * are only re-enabled upon leaving the outermost nested critical section.
 *
 */
static inline void system_interrupt_leave_critical_section(void)
{
	cpu_irq_leave_critical();
    c256:	f000 f8eb 	bl	c430 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();
}
    c25a:	bd70      	pop	{r4, r5, r6, pc}
			for (mask = (1UL << 1); mask < config->division_factor;
    c25c:	2202      	movs	r2, #2
    c25e:	e7d4      	b.n	c20a <system_gclk_gen_set_config+0x3e>
    c260:	40000c08 	.word	0x40000c08
    c264:	40000c00 	.word	0x40000c00

0000c268 <system_gclk_gen_enable>:
 *
 * \param[in] generator  Generic Clock Generator index to enable
 */
void system_gclk_gen_enable(
		const uint8_t generator)
{
    c268:	b510      	push	{r4, lr}
    c26a:	0004      	movs	r4, r0
	while (system_gclk_is_syncing()) {
    c26c:	f7ff ff98 	bl	c1a0 <system_gclk_is_syncing>
    c270:	2800      	cmp	r0, #0
    c272:	d1fb      	bne.n	c26c <system_gclk_gen_enable+0x4>
	cpu_irq_enter_critical();
    c274:	f000 f8c2 	bl	c3fc <cpu_irq_enter_critical>
	};

	system_interrupt_enter_critical_section();

	/* Select the requested generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    c278:	4b07      	ldr	r3, [pc, #28]	; (c298 <system_gclk_gen_enable+0x30>)
    c27a:	701c      	strb	r4, [r3, #0]
	while (system_gclk_is_syncing()) {
    c27c:	f7ff ff90 	bl	c1a0 <system_gclk_is_syncing>
    c280:	2800      	cmp	r0, #0
    c282:	d1fb      	bne.n	c27c <system_gclk_gen_enable+0x14>
		/* Wait for synchronization */
	};

	/* Enable generator */
	GCLK->GENCTRL.reg |= GCLK_GENCTRL_GENEN;
    c284:	2380      	movs	r3, #128	; 0x80
    c286:	4a05      	ldr	r2, [pc, #20]	; (c29c <system_gclk_gen_enable+0x34>)
    c288:	025b      	lsls	r3, r3, #9
    c28a:	6851      	ldr	r1, [r2, #4]
    c28c:	430b      	orrs	r3, r1
    c28e:	6053      	str	r3, [r2, #4]
	cpu_irq_leave_critical();
    c290:	f000 f8ce 	bl	c430 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();
}
    c294:	bd10      	pop	{r4, pc}
    c296:	46c0      	nop			; (mov r8, r8)
    c298:	40000c04 	.word	0x40000c04
    c29c:	40000c00 	.word	0x40000c00

0000c2a0 <system_gclk_gen_get_hz>:
 *
 * \return The frequency of the generic clock generator, in Hz.
 */
uint32_t system_gclk_gen_get_hz(
		const uint8_t generator)
{
    c2a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c2a2:	0007      	movs	r7, r0
	while (system_gclk_is_syncing()) {
    c2a4:	f7ff ff7c 	bl	c1a0 <system_gclk_is_syncing>
    c2a8:	2800      	cmp	r0, #0
    c2aa:	d1fb      	bne.n	c2a4 <system_gclk_gen_get_hz+0x4>
	};

	system_interrupt_enter_critical_section();

	/* Select the appropriate generator */
	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    c2ac:	4e15      	ldr	r6, [pc, #84]	; (c304 <system_gclk_gen_get_hz+0x64>)
	cpu_irq_enter_critical();
    c2ae:	f000 f8a5 	bl	c3fc <cpu_irq_enter_critical>
    c2b2:	7037      	strb	r7, [r6, #0]
	while (system_gclk_is_syncing()) {
    c2b4:	f7ff ff74 	bl	c1a0 <system_gclk_is_syncing>
    c2b8:	2800      	cmp	r0, #0
    c2ba:	d1fb      	bne.n	c2b4 <system_gclk_gen_get_hz+0x14>
		/* Wait for synchronization */
	};

	/* Get the frequency of the source connected to the GCLK generator */
	uint32_t gen_input_hz = system_clock_source_get_hz(
			(enum system_clock_source)GCLK->GENCTRL.bit.SRC);
    c2bc:	4c12      	ldr	r4, [pc, #72]	; (c308 <system_gclk_gen_get_hz+0x68>)
    c2be:	6860      	ldr	r0, [r4, #4]
    c2c0:	04c0      	lsls	r0, r0, #19
    c2c2:	0ec0      	lsrs	r0, r0, #27
	uint32_t gen_input_hz = system_clock_source_get_hz(
    c2c4:	f000 f8d4 	bl	c470 <system_clock_source_get_hz>
    c2c8:	0005      	movs	r5, r0

	*((uint8_t*)&GCLK->GENCTRL.reg) = generator;
    c2ca:	7037      	strb	r7, [r6, #0]

	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    c2cc:	6866      	ldr	r6, [r4, #4]

	/* Select the appropriate generator division register */
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    c2ce:	4b0f      	ldr	r3, [pc, #60]	; (c30c <system_gclk_gen_get_hz+0x6c>)
	uint8_t divsel = GCLK->GENCTRL.bit.DIVSEL;
    c2d0:	02f6      	lsls	r6, r6, #11
    c2d2:	0ff6      	lsrs	r6, r6, #31
	*((uint8_t*)&GCLK->GENDIV.reg) = generator;
    c2d4:	701f      	strb	r7, [r3, #0]
	while (system_gclk_is_syncing()) {
    c2d6:	f7ff ff63 	bl	c1a0 <system_gclk_is_syncing>
    c2da:	2800      	cmp	r0, #0
    c2dc:	d1fb      	bne.n	c2d6 <system_gclk_gen_get_hz+0x36>
		/* Wait for synchronization */
	};

	uint32_t divider = GCLK->GENDIV.bit.DIV;
    c2de:	68a4      	ldr	r4, [r4, #8]
    c2e0:	0224      	lsls	r4, r4, #8
    c2e2:	0c24      	lsrs	r4, r4, #16
	cpu_irq_leave_critical();
    c2e4:	f000 f8a4 	bl	c430 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();

	/* Check if the generator is using fractional or binary division */
	if (!divsel && divider > 1) {
    c2e8:	2e00      	cmp	r6, #0
    c2ea:	d108      	bne.n	c2fe <system_gclk_gen_get_hz+0x5e>
    c2ec:	2c01      	cmp	r4, #1
    c2ee:	d904      	bls.n	c2fa <system_gclk_gen_get_hz+0x5a>
		gen_input_hz /= divider;
    c2f0:	0028      	movs	r0, r5
    c2f2:	0021      	movs	r1, r4
    c2f4:	f004 f8a6 	bl	10444 <__udivsi3>
    c2f8:	0005      	movs	r5, r0
	} else if (divsel) {
		gen_input_hz >>= (divider+1);
	}

	return gen_input_hz;
}
    c2fa:	0028      	movs	r0, r5
    c2fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		gen_input_hz >>= (divider+1);
    c2fe:	3401      	adds	r4, #1
    c300:	40e5      	lsrs	r5, r4
	return gen_input_hz;
    c302:	e7fa      	b.n	c2fa <system_gclk_gen_get_hz+0x5a>
    c304:	40000c04 	.word	0x40000c04
    c308:	40000c00 	.word	0x40000c00
    c30c:	40000c08 	.word	0x40000c08

0000c310 <system_gclk_chan_enable>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_enable(
		const uint8_t channel)
{
    c310:	b510      	push	{r4, lr}
    c312:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    c314:	f000 f872 	bl	c3fc <cpu_irq_enter_critical>
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c318:	4b05      	ldr	r3, [pc, #20]	; (c330 <system_gclk_chan_enable+0x20>)

	/* Enable the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    c31a:	4a06      	ldr	r2, [pc, #24]	; (c334 <system_gclk_chan_enable+0x24>)
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c31c:	701c      	strb	r4, [r3, #0]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_CLKEN;
    c31e:	2380      	movs	r3, #128	; 0x80
    c320:	8851      	ldrh	r1, [r2, #2]
    c322:	01db      	lsls	r3, r3, #7
    c324:	430b      	orrs	r3, r1
    c326:	8053      	strh	r3, [r2, #2]
	cpu_irq_leave_critical();
    c328:	f000 f882 	bl	c430 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();
}
    c32c:	bd10      	pop	{r4, pc}
    c32e:	46c0      	nop			; (mov r8, r8)
    c330:	40000c02 	.word	0x40000c02
    c334:	40000c00 	.word	0x40000c00

0000c338 <system_gclk_chan_disable>:
 *
 * \param[in] channel  Generic Clock channel to disable
 */
void system_gclk_chan_disable(
		const uint8_t channel)
{
    c338:	b510      	push	{r4, lr}
    c33a:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    c33c:	f000 f85e 	bl	c3fc <cpu_irq_enter_critical>
	system_interrupt_enter_critical_section();

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c340:	4b0d      	ldr	r3, [pc, #52]	; (c378 <system_gclk_chan_disable+0x40>)
	/* Sanity check WRTLOCK */
	Assert(!GCLK->CLKCTRL.bit.WRTLOCK);

	/* Switch to known-working source so that the channel can be disabled */
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
	GCLK->CLKCTRL.bit.GEN = 0;
    c342:	4a0e      	ldr	r2, [pc, #56]	; (c37c <system_gclk_chan_disable+0x44>)
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c344:	701c      	strb	r4, [r3, #0]
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    c346:	4b0e      	ldr	r3, [pc, #56]	; (c380 <system_gclk_chan_disable+0x48>)

	/* Disable the generic clock */
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    c348:	4c0e      	ldr	r4, [pc, #56]	; (c384 <system_gclk_chan_disable+0x4c>)
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    c34a:	8858      	ldrh	r0, [r3, #2]
	GCLK->CLKCTRL.bit.GEN = 0;
    c34c:	8859      	ldrh	r1, [r3, #2]
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    c34e:	0500      	lsls	r0, r0, #20
	GCLK->CLKCTRL.bit.GEN = 0;
    c350:	4011      	ands	r1, r2
    c352:	8059      	strh	r1, [r3, #2]
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    c354:	8859      	ldrh	r1, [r3, #2]
	uint32_t prev_gen_id = GCLK->CLKCTRL.bit.GEN;
    c356:	0f00      	lsrs	r0, r0, #28
	GCLK->CLKCTRL.reg &= ~GCLK_CLKCTRL_CLKEN;
    c358:	4021      	ands	r1, r4
    c35a:	8059      	strh	r1, [r3, #2]
    c35c:	0011      	movs	r1, r2
	while (GCLK->CLKCTRL.reg & GCLK_CLKCTRL_CLKEN) {
    c35e:	2280      	movs	r2, #128	; 0x80
    c360:	01d2      	lsls	r2, r2, #7
    c362:	885c      	ldrh	r4, [r3, #2]
    c364:	4214      	tst	r4, r2
    c366:	d1fc      	bne.n	c362 <system_gclk_chan_disable+0x2a>
		/* Wait for clock to become disabled */
	}

	/* Restore previous configured clock generator */
	GCLK->CLKCTRL.bit.GEN = prev_gen_id;
    c368:	885a      	ldrh	r2, [r3, #2]
    c36a:	0200      	lsls	r0, r0, #8
    c36c:	400a      	ands	r2, r1
    c36e:	4302      	orrs	r2, r0
    c370:	805a      	strh	r2, [r3, #2]
	cpu_irq_leave_critical();
    c372:	f000 f85d 	bl	c430 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();
}
    c376:	bd10      	pop	{r4, pc}
    c378:	40000c02 	.word	0x40000c02
    c37c:	fffff0ff 	.word	0xfffff0ff
    c380:	40000c00 	.word	0x40000c00
    c384:	ffffbfff 	.word	0xffffbfff

0000c388 <system_gclk_chan_set_config>:
{
    c388:	b510      	push	{r4, lr}
	new_clkctrl_config |= config->source_generator << GCLK_CLKCTRL_GEN_Pos;
    c38a:	780c      	ldrb	r4, [r1, #0]
    c38c:	0224      	lsls	r4, r4, #8
    c38e:	4304      	orrs	r4, r0
	system_gclk_chan_disable(channel);
    c390:	f7ff ffd2 	bl	c338 <system_gclk_chan_disable>
	GCLK->CLKCTRL.reg = new_clkctrl_config;
    c394:	4b01      	ldr	r3, [pc, #4]	; (c39c <system_gclk_chan_set_config+0x14>)
    c396:	b2a4      	uxth	r4, r4
    c398:	805c      	strh	r4, [r3, #2]
}
    c39a:	bd10      	pop	{r4, pc}
    c39c:	40000c00 	.word	0x40000c00

0000c3a0 <system_gclk_chan_lock>:
 *
 * \param[in] channel   Generic Clock channel to enable
 */
void system_gclk_chan_lock(
		const uint8_t channel)
{
    c3a0:	b510      	push	{r4, lr}
    c3a2:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    c3a4:	f000 f82a 	bl	c3fc <cpu_irq_enter_critical>

	/* Select the requested generator channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;

	/* Lock the generic clock */
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_WRTLOCK;
    c3a8:	2180      	movs	r1, #128	; 0x80
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c3aa:	4b05      	ldr	r3, [pc, #20]	; (c3c0 <system_gclk_chan_lock+0x20>)
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_WRTLOCK;
    c3ac:	4a05      	ldr	r2, [pc, #20]	; (c3c4 <system_gclk_chan_lock+0x24>)
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c3ae:	701c      	strb	r4, [r3, #0]
	GCLK->CLKCTRL.reg |= GCLK_CLKCTRL_WRTLOCK;
    c3b0:	8853      	ldrh	r3, [r2, #2]
    c3b2:	0209      	lsls	r1, r1, #8
    c3b4:	430b      	orrs	r3, r1
    c3b6:	8053      	strh	r3, [r2, #2]
	cpu_irq_leave_critical();
    c3b8:	f000 f83a 	bl	c430 <cpu_irq_leave_critical>

	system_interrupt_leave_critical_section();
}
    c3bc:	bd10      	pop	{r4, pc}
    c3be:	46c0      	nop			; (mov r8, r8)
    c3c0:	40000c02 	.word	0x40000c02
    c3c4:	40000c00 	.word	0x40000c00

0000c3c8 <system_gclk_chan_get_hz>:
 *
 * \return The frequency of the generic clock channel, in Hz.
 */
uint32_t system_gclk_chan_get_hz(
		const uint8_t channel)
{
    c3c8:	b510      	push	{r4, lr}
    c3ca:	0004      	movs	r4, r0
	cpu_irq_enter_critical();
    c3cc:	f000 f816 	bl	c3fc <cpu_irq_enter_critical>
	uint8_t gen_id;

	system_interrupt_enter_critical_section();

	/* Select the requested generic clock channel */
	*((uint8_t*)&GCLK->CLKCTRL.reg) = channel;
    c3d0:	4b05      	ldr	r3, [pc, #20]	; (c3e8 <system_gclk_chan_get_hz+0x20>)
    c3d2:	701c      	strb	r4, [r3, #0]
	gen_id = GCLK->CLKCTRL.bit.GEN;
    c3d4:	4b05      	ldr	r3, [pc, #20]	; (c3ec <system_gclk_chan_get_hz+0x24>)
    c3d6:	885c      	ldrh	r4, [r3, #2]
	cpu_irq_leave_critical();
    c3d8:	f000 f82a 	bl	c430 <cpu_irq_leave_critical>
    c3dc:	0524      	lsls	r4, r4, #20
    c3de:	0f24      	lsrs	r4, r4, #28

	system_interrupt_leave_critical_section();

	/* Return the clock speed of the associated GCLK generator */
	return system_gclk_gen_get_hz(gen_id);
    c3e0:	0020      	movs	r0, r4
    c3e2:	f7ff ff5d 	bl	c2a0 <system_gclk_gen_get_hz>
}
    c3e6:	bd10      	pop	{r4, pc}
    c3e8:	40000c02 	.word	0x40000c02
    c3ec:	40000c00 	.word	0x40000c00

0000c3f0 <system_init>:
 *  - Board hardware initialization (via the Board module)
 *  - Event system driver initialization (via the EVSYS module)
 *  - External Interrupt driver initialization (via the EXTINT module)
 */
void system_init(void)
{
    c3f0:	b510      	push	{r4, lr}
	/* Configure GCLK and clock sources according to conf_clocks.h */
	system_clock_init();
    c3f2:	f000 f8e3 	bl	c5bc <system_clock_init>

	/* Initialize External hardware */
        _system_extint_init();
    c3f6:	f000 fa0f 	bl	c818 <_system_extint_init>
}
    c3fa:	bd10      	pop	{r4, pc}

0000c3fc <cpu_irq_enter_critical>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
    c3fc:	4b09      	ldr	r3, [pc, #36]	; (c424 <cpu_irq_enter_critical+0x28>)
    c3fe:	6819      	ldr	r1, [r3, #0]
    c400:	2900      	cmp	r1, #0
    c402:	d10b      	bne.n	c41c <cpu_irq_enter_critical+0x20>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    c404:	f3ef 8010 	mrs	r0, PRIMASK
    c408:	4a07      	ldr	r2, [pc, #28]	; (c428 <cpu_irq_enter_critical+0x2c>)
		if (cpu_irq_is_enabled()) {
    c40a:	2800      	cmp	r0, #0
    c40c:	d105      	bne.n	c41a <cpu_irq_enter_critical+0x1e>
  __ASM volatile ("cpsid i" : : : "memory");
    c40e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    c410:	f3bf 8f5f 	dmb	sy
			cpu_irq_disable();
    c414:	4905      	ldr	r1, [pc, #20]	; (c42c <cpu_irq_enter_critical+0x30>)
    c416:	7008      	strb	r0, [r1, #0]
			cpu_irq_prev_interrupt_state = true;
    c418:	2101      	movs	r1, #1
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
    c41a:	7011      	strb	r1, [r2, #0]
		}

	}

	cpu_irq_critical_section_counter++;
    c41c:	681a      	ldr	r2, [r3, #0]
    c41e:	3201      	adds	r2, #1
    c420:	601a      	str	r2, [r3, #0]
}
    c422:	4770      	bx	lr
    c424:	20000128 	.word	0x20000128
    c428:	2000012c 	.word	0x2000012c
    c42c:	200000b4 	.word	0x200000b4

0000c430 <cpu_irq_leave_critical>:
void cpu_irq_leave_critical(void)
{
	/* Check if the user is trying to leave a critical section when not in a critical section */
	Assert(cpu_irq_critical_section_counter > 0);

	cpu_irq_critical_section_counter--;
    c430:	4b08      	ldr	r3, [pc, #32]	; (c454 <cpu_irq_leave_critical+0x24>)
    c432:	681a      	ldr	r2, [r3, #0]
    c434:	3a01      	subs	r2, #1
    c436:	601a      	str	r2, [r3, #0]

	/* Only enable global interrupts when the counter reaches 0 and the state of the global interrupt flag
	   was enabled when entering critical state */
	if ((cpu_irq_critical_section_counter == 0) && (cpu_irq_prev_interrupt_state)) {
    c438:	681b      	ldr	r3, [r3, #0]
    c43a:	2b00      	cmp	r3, #0
    c43c:	d109      	bne.n	c452 <cpu_irq_leave_critical+0x22>
    c43e:	4b06      	ldr	r3, [pc, #24]	; (c458 <cpu_irq_leave_critical+0x28>)
    c440:	781b      	ldrb	r3, [r3, #0]
    c442:	2b00      	cmp	r3, #0
    c444:	d005      	beq.n	c452 <cpu_irq_leave_critical+0x22>
		cpu_irq_enable();
    c446:	2201      	movs	r2, #1
    c448:	4b04      	ldr	r3, [pc, #16]	; (c45c <cpu_irq_leave_critical+0x2c>)
    c44a:	701a      	strb	r2, [r3, #0]
    c44c:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
    c450:	b662      	cpsie	i
	}
}
    c452:	4770      	bx	lr
    c454:	20000128 	.word	0x20000128
    c458:	2000012c 	.word	0x2000012c
    c45c:	200000b4 	.word	0x200000b4

0000c460 <_system_dfll_wait_for_sync>:
 * \internal
 * \brief Wait for sync to the DFLL control registers.
 */
static inline void _system_dfll_wait_for_sync(void)
{
	while (!(SYSCTRL->PCLKSR.reg & SYSCTRL_PCLKSR_DFLLRDY)) {
    c460:	2310      	movs	r3, #16
    c462:	4902      	ldr	r1, [pc, #8]	; (c46c <_system_dfll_wait_for_sync+0xc>)
    c464:	68ca      	ldr	r2, [r1, #12]
    c466:	421a      	tst	r2, r3
    c468:	d0fc      	beq.n	c464 <_system_dfll_wait_for_sync+0x4>
		/* Wait for DFLL sync */
	}
}
    c46a:	4770      	bx	lr
    c46c:	40000800 	.word	0x40000800

0000c470 <system_clock_source_get_hz>:
 *
 * \returns Frequency of the given clock source, in Hz.
 */
uint32_t system_clock_source_get_hz(
		const enum system_clock_source clock_source)
{
    c470:	b570      	push	{r4, r5, r6, lr}
	switch (clock_source) {
    c472:	2808      	cmp	r0, #8
    c474:	d806      	bhi.n	c484 <system_clock_source_get_hz+0x14>
    c476:	f003 ffdb 	bl	10430 <__gnu_thumb1_case_uqi>
    c47a:	0508      	.short	0x0508
    c47c:	122e2e05 	.word	0x122e2e05
    c480:	150b      	.short	0x150b
    c482:	26          	.byte	0x26
    c483:	00          	.byte	0x00

		return _system_clock_inst.dpll.frequency;
#endif

	default:
		return 0;
    c484:	2400      	movs	r4, #0
	}
}
    c486:	0020      	movs	r0, r4
    c488:	bd70      	pop	{r4, r5, r6, pc}
		return _system_clock_inst.xosc.frequency;
    c48a:	4b15      	ldr	r3, [pc, #84]	; (c4e0 <system_clock_source_get_hz+0x70>)
    c48c:	691c      	ldr	r4, [r3, #16]
    c48e:	e7fa      	b.n	c486 <system_clock_source_get_hz+0x16>
		return 8000000UL >> SYSCTRL->OSC8M.bit.PRESC;
    c490:	4b14      	ldr	r3, [pc, #80]	; (c4e4 <system_clock_source_get_hz+0x74>)
    c492:	4c15      	ldr	r4, [pc, #84]	; (c4e8 <system_clock_source_get_hz+0x78>)
    c494:	6a1b      	ldr	r3, [r3, #32]
    c496:	059b      	lsls	r3, r3, #22
    c498:	0f9b      	lsrs	r3, r3, #30
    c49a:	40dc      	lsrs	r4, r3
    c49c:	e7f3      	b.n	c486 <system_clock_source_get_hz+0x16>
		return _system_clock_inst.xosc32k.frequency;
    c49e:	4b10      	ldr	r3, [pc, #64]	; (c4e0 <system_clock_source_get_hz+0x70>)
    c4a0:	695c      	ldr	r4, [r3, #20]
    c4a2:	e7f0      	b.n	c486 <system_clock_source_get_hz+0x16>
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    c4a4:	4d0e      	ldr	r5, [pc, #56]	; (c4e0 <system_clock_source_get_hz+0x70>)
			return 0;
    c4a6:	2400      	movs	r4, #0
		if (!(_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_ENABLE))
    c4a8:	682b      	ldr	r3, [r5, #0]
    c4aa:	079b      	lsls	r3, r3, #30
    c4ac:	d5eb      	bpl.n	c486 <system_clock_source_get_hz+0x16>
		_system_dfll_wait_for_sync();
    c4ae:	f7ff ffd7 	bl	c460 <_system_dfll_wait_for_sync>
		if (_system_clock_inst.dfll.control & SYSCTRL_DFLLCTRL_MODE) {
    c4b2:	682b      	ldr	r3, [r5, #0]
    c4b4:	075b      	lsls	r3, r3, #29
    c4b6:	d511      	bpl.n	c4dc <system_clock_source_get_hz+0x6c>
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    c4b8:	0020      	movs	r0, r4
    c4ba:	f7ff ff85 	bl	c3c8 <system_gclk_chan_get_hz>
					(_system_clock_inst.dfll.mul & 0xffff);
    c4be:	68ac      	ldr	r4, [r5, #8]
    c4c0:	b2a4      	uxth	r4, r4
			return system_gclk_chan_get_hz(SYSCTRL_GCLK_ID_DFLL48) *
    c4c2:	4344      	muls	r4, r0
    c4c4:	e7df      	b.n	c486 <system_clock_source_get_hz+0x16>
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    c4c6:	4b09      	ldr	r3, [pc, #36]	; (c4ec <system_clock_source_get_hz+0x7c>)
			return 0;
    c4c8:	2400      	movs	r4, #0
		if (!(SYSCTRL->DPLLSTATUS.reg & SYSCTRL_DPLLSTATUS_ENABLE)) {
    c4ca:	781b      	ldrb	r3, [r3, #0]
    c4cc:	075b      	lsls	r3, r3, #29
    c4ce:	d5da      	bpl.n	c486 <system_clock_source_get_hz+0x16>
		return _system_clock_inst.dpll.frequency;
    c4d0:	4b03      	ldr	r3, [pc, #12]	; (c4e0 <system_clock_source_get_hz+0x70>)
    c4d2:	68dc      	ldr	r4, [r3, #12]
    c4d4:	e7d7      	b.n	c486 <system_clock_source_get_hz+0x16>
		return 32768UL;
    c4d6:	2480      	movs	r4, #128	; 0x80
    c4d8:	0224      	lsls	r4, r4, #8
    c4da:	e7d4      	b.n	c486 <system_clock_source_get_hz+0x16>
		return 48000000UL;
    c4dc:	4c04      	ldr	r4, [pc, #16]	; (c4f0 <system_clock_source_get_hz+0x80>)
    c4de:	e7d2      	b.n	c486 <system_clock_source_get_hz+0x16>
    c4e0:	20000130 	.word	0x20000130
    c4e4:	40000800 	.word	0x40000800
    c4e8:	007a1200 	.word	0x007a1200
    c4ec:	40000850 	.word	0x40000850
    c4f0:	02dc6c00 	.word	0x02dc6c00

0000c4f4 <system_clock_source_osc8m_set_config>:
 *
 * \param[in] config  OSC8M configuration structure containing the new config
 */
void system_clock_source_osc8m_set_config(
		struct system_clock_source_osc8m_config *const config)
{
    c4f4:	b570      	push	{r4, r5, r6, lr}
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;

	/* Use temporary struct to reduce register access */
	temp.bit.PRESC    = config->prescaler;
    c4f6:	7802      	ldrb	r2, [r0, #0]
	temp.bit.ONDEMAND = config->on_demand;
    c4f8:	7884      	ldrb	r4, [r0, #2]
	temp.bit.RUNSTDBY = config->run_in_standby;

	SYSCTRL->OSC8M = temp;
    c4fa:	7845      	ldrb	r5, [r0, #1]
    c4fc:	2001      	movs	r0, #1
    c4fe:	2640      	movs	r6, #64	; 0x40
    c500:	4005      	ands	r5, r0
    c502:	4020      	ands	r0, r4
    c504:	2480      	movs	r4, #128	; 0x80
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    c506:	4908      	ldr	r1, [pc, #32]	; (c528 <system_clock_source_osc8m_set_config+0x34>)
	SYSCTRL->OSC8M = temp;
    c508:	01ad      	lsls	r5, r5, #6
	SYSCTRL_OSC8M_Type temp = SYSCTRL->OSC8M;
    c50a:	6a0b      	ldr	r3, [r1, #32]
	SYSCTRL->OSC8M = temp;
    c50c:	01c0      	lsls	r0, r0, #7
    c50e:	43b3      	bics	r3, r6
    c510:	432b      	orrs	r3, r5
    c512:	43a3      	bics	r3, r4
    c514:	4303      	orrs	r3, r0
    c516:	2003      	movs	r0, #3
    c518:	4002      	ands	r2, r0
    c51a:	4804      	ldr	r0, [pc, #16]	; (c52c <system_clock_source_osc8m_set_config+0x38>)
    c51c:	0212      	lsls	r2, r2, #8
    c51e:	4003      	ands	r3, r0
    c520:	4313      	orrs	r3, r2
    c522:	620b      	str	r3, [r1, #32]
}
    c524:	bd70      	pop	{r4, r5, r6, pc}
    c526:	46c0      	nop			; (mov r8, r8)
    c528:	40000800 	.word	0x40000800
    c52c:	fffffcff 	.word	0xfffffcff

0000c530 <system_clock_source_enable>:
 * \retval STATUS_ERR_INVALID_ARG  The clock source is not available on this
 *                                 device
 */
enum status_code system_clock_source_enable(
		const enum system_clock_source clock_source)
{
    c530:	b570      	push	{r4, r5, r6, lr}
	switch (clock_source) {
    c532:	2808      	cmp	r0, #8
    c534:	d806      	bhi.n	c544 <system_clock_source_enable+0x14>
    c536:	f003 ff7b 	bl	10430 <__gnu_thumb1_case_uqi>
    c53a:	0514      	.short	0x0514
    c53c:	1a0e0c05 	.word	0x1a0e0c05
    c540:	2007      	.short	0x2007
    c542:	35          	.byte	0x35
    c543:	00          	.byte	0x00
		/* Always enabled */
		return STATUS_OK;

	default:
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    c544:	2017      	movs	r0, #23
	}

	return STATUS_OK;
}
    c546:	bd70      	pop	{r4, r5, r6, pc}
		SYSCTRL->OSC8M.reg |= SYSCTRL_OSC8M_ENABLE;
    c548:	2302      	movs	r3, #2
    c54a:	4a19      	ldr	r2, [pc, #100]	; (c5b0 <system_clock_source_enable+0x80>)
    c54c:	6a11      	ldr	r1, [r2, #32]
    c54e:	430b      	orrs	r3, r1
    c550:	6213      	str	r3, [r2, #32]
		return STATUS_OK;
    c552:	2000      	movs	r0, #0
    c554:	e7f7      	b.n	c546 <system_clock_source_enable+0x16>
		SYSCTRL->OSC32K.reg |= SYSCTRL_OSC32K_ENABLE;
    c556:	2302      	movs	r3, #2
    c558:	4a15      	ldr	r2, [pc, #84]	; (c5b0 <system_clock_source_enable+0x80>)
    c55a:	6991      	ldr	r1, [r2, #24]
    c55c:	430b      	orrs	r3, r1
    c55e:	6193      	str	r3, [r2, #24]
    c560:	e7f7      	b.n	c552 <system_clock_source_enable+0x22>
		SYSCTRL->XOSC.reg |= SYSCTRL_XOSC_ENABLE;
    c562:	2302      	movs	r3, #2
    c564:	4a12      	ldr	r2, [pc, #72]	; (c5b0 <system_clock_source_enable+0x80>)
    c566:	8a11      	ldrh	r1, [r2, #16]
    c568:	430b      	orrs	r3, r1
    c56a:	8213      	strh	r3, [r2, #16]
    c56c:	e7f1      	b.n	c552 <system_clock_source_enable+0x22>
		SYSCTRL->XOSC32K.reg |= SYSCTRL_XOSC32K_ENABLE;
    c56e:	2302      	movs	r3, #2
    c570:	4a0f      	ldr	r2, [pc, #60]	; (c5b0 <system_clock_source_enable+0x80>)
    c572:	8a91      	ldrh	r1, [r2, #20]
    c574:	430b      	orrs	r3, r1
    c576:	8293      	strh	r3, [r2, #20]
    c578:	e7eb      	b.n	c552 <system_clock_source_enable+0x22>
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    c57a:	2202      	movs	r2, #2
	SYSCTRL->DFLLCTRL.reg = 0;
    c57c:	2400      	movs	r4, #0
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    c57e:	4e0d      	ldr	r6, [pc, #52]	; (c5b4 <system_clock_source_enable+0x84>)
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    c580:	4d0b      	ldr	r5, [pc, #44]	; (c5b0 <system_clock_source_enable+0x80>)
		_system_clock_inst.dfll.control |= SYSCTRL_DFLLCTRL_ENABLE;
    c582:	6833      	ldr	r3, [r6, #0]
    c584:	4313      	orrs	r3, r2
    c586:	6033      	str	r3, [r6, #0]
	SYSCTRL->DFLLCTRL.reg = SYSCTRL_DFLLCTRL_ENABLE;
    c588:	84aa      	strh	r2, [r5, #36]	; 0x24
	_system_dfll_wait_for_sync();
    c58a:	f7ff ff69 	bl	c460 <_system_dfll_wait_for_sync>
	SYSCTRL->DFLLMUL.reg = _system_clock_inst.dfll.mul;
    c58e:	68b3      	ldr	r3, [r6, #8]
    c590:	62eb      	str	r3, [r5, #44]	; 0x2c
	SYSCTRL->DFLLVAL.reg = _system_clock_inst.dfll.val;
    c592:	6873      	ldr	r3, [r6, #4]
    c594:	62ab      	str	r3, [r5, #40]	; 0x28
	SYSCTRL->DFLLCTRL.reg = 0;
    c596:	84ac      	strh	r4, [r5, #36]	; 0x24
	_system_dfll_wait_for_sync();
    c598:	f7ff ff62 	bl	c460 <_system_dfll_wait_for_sync>
	SYSCTRL->DFLLCTRL.reg = _system_clock_inst.dfll.control;
    c59c:	6833      	ldr	r3, [r6, #0]
    c59e:	b29b      	uxth	r3, r3
    c5a0:	84ab      	strh	r3, [r5, #36]	; 0x24
    c5a2:	e7d6      	b.n	c552 <system_clock_source_enable+0x22>
		SYSCTRL->DPLLCTRLA.reg |= SYSCTRL_DPLLCTRLA_ENABLE;
    c5a4:	2302      	movs	r3, #2
    c5a6:	4a04      	ldr	r2, [pc, #16]	; (c5b8 <system_clock_source_enable+0x88>)
    c5a8:	7811      	ldrb	r1, [r2, #0]
    c5aa:	430b      	orrs	r3, r1
    c5ac:	7013      	strb	r3, [r2, #0]
    c5ae:	e7d0      	b.n	c552 <system_clock_source_enable+0x22>
    c5b0:	40000800 	.word	0x40000800
    c5b4:	20000130 	.word	0x20000130
    c5b8:	40000844 	.word	0x40000844

0000c5bc <system_clock_init>:
 * \note OSC8M is always enabled and if user selects other clocks for GCLK generators,
 * the OSC8M default enable can be disabled after system_clock_init. Make sure the
 * clock switch successfully before disabling OSC8M.
 */
void system_clock_init(void)
{
    c5bc:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	/* Various bits in the INTFLAG register can be set to one at startup.
	   This will ensure that these bits are cleared */
	SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
    c5be:	22c2      	movs	r2, #194	; 0xc2
static inline void system_flash_set_waitstates(uint8_t wait_states)
{
	Assert(NVMCTRL_CTRLB_RWS((uint32_t)wait_states) ==
			((uint32_t)wait_states << NVMCTRL_CTRLB_RWS_Pos));

	NVMCTRL->CTRLB.bit.RWS = wait_states;
    c5c0:	211e      	movs	r1, #30
    c5c2:	4b19      	ldr	r3, [pc, #100]	; (c628 <system_clock_init+0x6c>)
    c5c4:	00d2      	lsls	r2, r2, #3
    c5c6:	609a      	str	r2, [r3, #8]
    c5c8:	4a18      	ldr	r2, [pc, #96]	; (c62c <system_clock_init+0x70>)
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    c5ca:	2400      	movs	r4, #0
    c5cc:	6853      	ldr	r3, [r2, #4]
	gclk_conf.source_generator = GCLK_GENERATOR_1;
    c5ce:	ad01      	add	r5, sp, #4
    c5d0:	438b      	bics	r3, r1
    c5d2:	6053      	str	r3, [r2, #4]
    c5d4:	2301      	movs	r3, #1
    c5d6:	702b      	strb	r3, [r5, #0]
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    c5d8:	b2e0      	uxtb	r0, r4
    c5da:	0029      	movs	r1, r5
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    c5dc:	3401      	adds	r4, #1
		system_gclk_chan_set_config(gclk_id, &gclk_conf);
    c5de:	f7ff fed3 	bl	c388 <system_gclk_chan_set_config>
	for (gclk_id = 0; gclk_id < GCLK_NUM; gclk_id++) {
    c5e2:	2c25      	cmp	r4, #37	; 0x25
    c5e4:	d1f8      	bne.n	c5d8 <system_clock_init+0x1c>
	config->run_in_standby  = false;
    c5e6:	2400      	movs	r4, #0
    c5e8:	466b      	mov	r3, sp
	config->on_demand       = true;
    c5ea:	2601      	movs	r6, #1

	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
	osc8m_conf.on_demand       = CONF_CLOCK_OSC8M_ON_DEMAND;
	osc8m_conf.run_in_standby  = CONF_CLOCK_OSC8M_RUN_IN_STANDBY;

	system_clock_source_osc8m_set_config(&osc8m_conf);
    c5ec:	4668      	mov	r0, sp
    c5ee:	709e      	strb	r6, [r3, #2]
	config->run_in_standby  = false;
    c5f0:	705c      	strb	r4, [r3, #1]
	osc8m_conf.prescaler       = CONF_CLOCK_OSC8M_PRESCALER;
    c5f2:	701c      	strb	r4, [r3, #0]
	system_clock_source_osc8m_set_config(&osc8m_conf);
    c5f4:	f7ff ff7e 	bl	c4f4 <system_clock_source_osc8m_set_config>
	system_clock_source_enable(SYSTEM_CLOCK_SOURCE_OSC8M);
    c5f8:	2006      	movs	r0, #6
    c5fa:	f7ff ff99 	bl	c530 <system_clock_source_enable>


	/* GCLK */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	system_gclk_init();
    c5fe:	f7ff fdd5 	bl	c1ac <system_gclk_init>
	PM->CPUSEL.reg = (uint32_t)divider;
    c602:	4b0b      	ldr	r3, [pc, #44]	; (c630 <system_clock_init+0x74>)
	system_apb_clock_set_divider(SYSTEM_CLOCK_APB_APBC, CONF_CLOCK_APBC_DIVIDER);

	/* GCLK 0 */
#if CONF_CLOCK_CONFIGURE_GCLK == true
	/* Configure the main GCLK last as it might depend on other generators */
	_CONF_CLOCK_GCLK_CONFIG(0, ~);
    c604:	0029      	movs	r1, r5
    c606:	721c      	strb	r4, [r3, #8]
			PM->APBASEL.reg = (uint32_t)divider;
    c608:	725c      	strb	r4, [r3, #9]
			PM->APBBSEL.reg = (uint32_t)divider;
    c60a:	729c      	strb	r4, [r3, #10]
			PM->APBCSEL.reg = (uint32_t)divider;
    c60c:	72dc      	strb	r4, [r3, #11]
#if SAML21 || SAML22
	config->source_clock       = GCLK_SOURCE_OSC16M;
#elif (SAMC20) || (SAMC21)
	config->source_clock       = GCLK_SOURCE_OSC48M;
#else
	config->source_clock       = GCLK_SOURCE_OSC8M;
    c60e:	2306      	movs	r3, #6
    c610:	0020      	movs	r0, r4
	config->division_factor    = 1;
    c612:	606e      	str	r6, [r5, #4]
	config->source_clock       = GCLK_SOURCE_OSC8M;
    c614:	702b      	strb	r3, [r5, #0]
	config->high_when_disabled = false;
    c616:	706c      	strb	r4, [r5, #1]
#endif
	config->run_in_standby     = false;
    c618:	722c      	strb	r4, [r5, #8]
	config->output_enable      = false;
    c61a:	726c      	strb	r4, [r5, #9]
    c61c:	f7ff fdd6 	bl	c1cc <system_gclk_gen_set_config>
    c620:	0020      	movs	r0, r4
    c622:	f7ff fe21 	bl	c268 <system_gclk_gen_enable>
#endif
}
    c626:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}
    c628:	40000800 	.word	0x40000800
    c62c:	41004000 	.word	0x41004000
    c630:	40000400 	.word	0x40000400

0000c634 <_start>:

/*
 * Rudimentary startup function.
 */
void _start(void)
{
    c634:	b510      	push	{r4, lr}
    int rc;

    rc = main(0, NULL);
    exit(rc);
#else
    os_init(main);
    c636:	4803      	ldr	r0, [pc, #12]	; (c644 <_start+0x10>)
    c638:	f000 fa5a 	bl	caf0 <os_init>
    os_start();
    c63c:	f000 faa2 	bl	cb84 <os_start>
#endif
}
    c640:	bd10      	pop	{r4, pc}
    c642:	46c0      	nop			; (mov r8, r8)
    c644:	0000c64d 	.word	0x0000c64d

0000c648 <__libc_init_array>:

void
__libc_init_array(void)
{
}
    c648:	4770      	bx	lr
	...

0000c64c <main>:
 *
 * @return int NOTE: this function should never return!
 */
int
main(int argc, char **argv)
{
    c64c:	b570      	push	{r4, r5, r6, lr}

#ifdef ARCH_sim
    mcu_sim_parse_args(argc, argv);
#endif

    sysinit();
    c64e:	f001 fccf 	bl	dff0 <sysinit_start>
    c652:	f001 fcef 	bl	e034 <sysinit_app>
    c656:	f001 fcd1 	bl	dffc <sysinit_end>

    g_led_pin = LED_BLINK_PIN;
    c65a:	2011      	movs	r0, #17
    c65c:	4c08      	ldr	r4, [pc, #32]	; (c680 <main+0x34>)
    hal_gpio_init_out(g_led_pin, 1);
    c65e:	2101      	movs	r1, #1

    while (1) {
        ++g_task1_loops;

        /* Wait one second */
        os_time_delay(OS_TICKS_PER_SEC);
    c660:	25fa      	movs	r5, #250	; 0xfa
    g_led_pin = LED_BLINK_PIN;
    c662:	6020      	str	r0, [r4, #0]
    hal_gpio_init_out(g_led_pin, 1);
    c664:	f000 f888 	bl	c778 <hal_gpio_init_out>
        os_time_delay(OS_TICKS_PER_SEC);
    c668:	00ad      	lsls	r5, r5, #2
        ++g_task1_loops;
    c66a:	4a06      	ldr	r2, [pc, #24]	; (c684 <main+0x38>)
        os_time_delay(OS_TICKS_PER_SEC);
    c66c:	0028      	movs	r0, r5
        ++g_task1_loops;
    c66e:	6813      	ldr	r3, [r2, #0]
    c670:	3301      	adds	r3, #1
    c672:	6013      	str	r3, [r2, #0]
        os_time_delay(OS_TICKS_PER_SEC);
    c674:	f000 fe6a 	bl	d34c <os_time_delay>

        /* Toggle the LED */
        hal_gpio_toggle(g_led_pin);
    c678:	6820      	ldr	r0, [r4, #0]
    c67a:	f000 f8ab 	bl	c7d4 <hal_gpio_toggle>
    c67e:	e7f4      	b.n	c66a <main+0x1e>
    c680:	20002304 	.word	0x20002304
    c684:	20000148 	.word	0x20000148

0000c688 <NVIC_Relocate>:
     * designated in the linker script.
     */
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
    c688:	4a06      	ldr	r2, [pc, #24]	; (c6a4 <NVIC_Relocate+0x1c>)
    c68a:	4907      	ldr	r1, [pc, #28]	; (c6a8 <NVIC_Relocate+0x20>)
    c68c:	428a      	cmp	r2, r1
    c68e:	d005      	beq.n	c69c <NVIC_Relocate+0x14>
    c690:	2300      	movs	r3, #0
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
            new_location[i] = current_location[i];
    c692:	58c8      	ldr	r0, [r1, r3]
    c694:	50d0      	str	r0, [r2, r3]
    c696:	3304      	adds	r3, #4
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
    c698:	2bb4      	cmp	r3, #180	; 0xb4
    c69a:	d1fa      	bne.n	c692 <NVIC_Relocate+0xa>
    }

    /* Set VTOR except for M0 */
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
#else
    SCB->VTOR = (uint32_t)&__vector_tbl_reloc__;
    c69c:	4b03      	ldr	r3, [pc, #12]	; (c6ac <NVIC_Relocate+0x24>)
    c69e:	609a      	str	r2, [r3, #8]
#endif
}
    c6a0:	4770      	bx	lr
    c6a2:	46c0      	nop			; (mov r8, r8)
    c6a4:	20000000 	.word	0x20000000
    c6a8:	0000c020 	.word	0x0000c020
    c6ac:	e000ed00 	.word	0xe000ed00

0000c6b0 <NVIC_SetVector>:
{
    uint32_t *vectors;
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
    vectors = (uint32_t *)&__vector_tbl_reloc__;
#else
    vectors = (uint32_t *)SCB->VTOR;
    c6b0:	4b03      	ldr	r3, [pc, #12]	; (c6c0 <NVIC_SetVector+0x10>)
#endif
    vectors[IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    c6b2:	3010      	adds	r0, #16
    vectors = (uint32_t *)SCB->VTOR;
    c6b4:	689b      	ldr	r3, [r3, #8]
    vectors[IRQn + NVIC_USER_IRQ_OFFSET] = vector;
    c6b6:	0080      	lsls	r0, r0, #2
    c6b8:	50c1      	str	r1, [r0, r3]
  __ASM volatile ("dmb 0xF":::"memory");
    c6ba:	f3bf 8f5f 	dmb	sy
    __DMB();
}
    c6be:	4770      	bx	lr
    c6c0:	e000ed00 	.word	0xe000ed00

0000c6c4 <hal_gpio_read>:
 */
int
hal_gpio_read(int pin)
{
    int rc;
    int port = GPIO_PORT(pin);
    c6c4:	231f      	movs	r3, #31
    c6c6:	17c2      	asrs	r2, r0, #31
    c6c8:	401a      	ands	r2, r3
    int port_pin = GPIO_PIN(pin);
    c6ca:	4b17      	ldr	r3, [pc, #92]	; (c728 <hal_gpio_read+0x64>)
    int port = GPIO_PORT(pin);
    c6cc:	1812      	adds	r2, r2, r0
{
    c6ce:	b510      	push	{r4, lr}
    int port = GPIO_PORT(pin);
    c6d0:	1152      	asrs	r2, r2, #5
    int port_pin = GPIO_PIN(pin);
    c6d2:	4003      	ands	r3, r0
    c6d4:	d504      	bpl.n	c6e0 <hal_gpio_read+0x1c>
    c6d6:	2120      	movs	r1, #32
    c6d8:	3b01      	subs	r3, #1
    c6da:	4249      	negs	r1, r1
    c6dc:	430b      	orrs	r3, r1
    c6de:	3301      	adds	r3, #1

    assert(port <= GPIO_MAX_PORT);
    c6e0:	2a01      	cmp	r2, #1
    c6e2:	dd05      	ble.n	c6f0 <hal_gpio_read+0x2c>
    c6e4:	2300      	movs	r3, #0
    c6e6:	001a      	movs	r2, r3
    c6e8:	0019      	movs	r1, r3
    c6ea:	0018      	movs	r0, r3
    c6ec:	f000 f924 	bl	c938 <__assert_func>
    assert(((1 << port_pin) & valid_pins[port]) != 0);
    c6f0:	490e      	ldr	r1, [pc, #56]	; (c72c <hal_gpio_read+0x68>)
    c6f2:	0092      	lsls	r2, r2, #2
    c6f4:	5852      	ldr	r2, [r2, r1]
    c6f6:	411a      	asrs	r2, r3
    c6f8:	0013      	movs	r3, r2
    c6fa:	2201      	movs	r2, #1
    c6fc:	4213      	tst	r3, r2
    c6fe:	d0f1      	beq.n	c6e4 <hal_gpio_read+0x20>

    rc = port_pin_get_input_level(pin);
    c700:	b2c0      	uxtb	r0, r0
 */
static inline PortGroup* system_pinmux_get_group_from_gpio_pin(
		const uint8_t gpio_pin)
{
	uint8_t port_index  = (gpio_pin / 128);
	uint8_t group_index = (gpio_pin / 32);
    c702:	0943      	lsrs	r3, r0, #5

	/* Array of available ports */
	Port *const ports[PORT_INST_NUM] = PORT_INSTS;

	if (port_index < PORT_INST_NUM) {
    c704:	09c1      	lsrs	r1, r0, #7
    c706:	d002      	beq.n	c70e <hal_gpio_read+0x4a>
		const uint8_t gpio_pin)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));

	return (port_base->IN.reg & pin_mask);
    c708:	2300      	movs	r3, #0
    c70a:	6a1b      	ldr	r3, [r3, #32]
    c70c:	deff      	udf	#255	; 0xff
    c70e:	4908      	ldr	r1, [pc, #32]	; (c730 <hal_gpio_read+0x6c>)
    c710:	01db      	lsls	r3, r3, #7
    c712:	185b      	adds	r3, r3, r1
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    c714:	211f      	movs	r1, #31
    c716:	4008      	ands	r0, r1
    c718:	4082      	lsls	r2, r0
    c71a:	0010      	movs	r0, r2
	return (port_base->IN.reg & pin_mask);
    c71c:	6a1b      	ldr	r3, [r3, #32]
    c71e:	4018      	ands	r0, r3
    c720:	1e43      	subs	r3, r0, #1
    c722:	4198      	sbcs	r0, r3
    return rc;
}
    c724:	bd10      	pop	{r4, pc}
    c726:	46c0      	nop			; (mov r8, r8)
    c728:	8000001f 	.word	0x8000001f
    c72c:	000107dc 	.word	0x000107dc
    c730:	41004400 	.word	0x41004400

0000c734 <hal_gpio_write>:
 * @param pin Pin to set
 * @param val Value to set pin (0:low 1:high)
 */
void
hal_gpio_write(int pin, int val)
{
    c734:	b2c0      	uxtb	r0, r0
    c736:	0943      	lsrs	r3, r0, #5
    c738:	b510      	push	{r4, lr}
    c73a:	221f      	movs	r2, #31
    c73c:	09c4      	lsrs	r4, r0, #7
    c73e:	01db      	lsls	r3, r3, #7
    if (val) {
    c740:	2900      	cmp	r1, #0
    c742:	d008      	beq.n	c756 <hal_gpio_write+0x22>
    c744:	2c00      	cmp	r4, #0
    c746:	d10f      	bne.n	c768 <hal_gpio_write+0x34>
static inline void port_pin_set_output_level(
		const uint8_t gpio_pin,
		const bool level)
{
	PortGroup *const port_base = port_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    c748:	4010      	ands	r0, r2
    c74a:	3a1e      	subs	r2, #30
    c74c:	4082      	lsls	r2, r0

	/* Set the pin to high or low atomically based on the requested level */
	if (level) {
		port_base->OUTSET.reg = pin_mask;
    c74e:	4909      	ldr	r1, [pc, #36]	; (c774 <hal_gpio_write+0x40>)
    c750:	185b      	adds	r3, r3, r1
    c752:	619a      	str	r2, [r3, #24]
        port_pin_set_output_level(pin, true);
    } else {
        port_pin_set_output_level(pin, false);
    }
}
    c754:	bd10      	pop	{r4, pc}
    c756:	2c00      	cmp	r4, #0
    c758:	d109      	bne.n	c76e <hal_gpio_write+0x3a>
	uint32_t pin_mask  = (1UL << (gpio_pin % 32));
    c75a:	4010      	ands	r0, r2
    c75c:	2201      	movs	r2, #1
    c75e:	4082      	lsls	r2, r0
	} else {
		port_base->OUTCLR.reg = pin_mask;
    c760:	4904      	ldr	r1, [pc, #16]	; (c774 <hal_gpio_write+0x40>)
    c762:	185b      	adds	r3, r3, r1
    c764:	615a      	str	r2, [r3, #20]
    c766:	e7f5      	b.n	c754 <hal_gpio_write+0x20>
		port_base->OUTSET.reg = pin_mask;
    c768:	2300      	movs	r3, #0
    c76a:	619b      	str	r3, [r3, #24]
    c76c:	deff      	udf	#255	; 0xff
		port_base->OUTCLR.reg = pin_mask;
    c76e:	6149      	str	r1, [r1, #20]
    c770:	e7fc      	b.n	c76c <hal_gpio_write+0x38>
    c772:	46c0      	nop			; (mov r8, r8)
    c774:	41004400 	.word	0x41004400

0000c778 <hal_gpio_init_out>:
    int port = GPIO_PORT(pin);
    c778:	231f      	movs	r3, #31
    c77a:	17c2      	asrs	r2, r0, #31
    c77c:	401a      	ands	r2, r3
    int port_pin = GPIO_PIN(pin);
    c77e:	4b13      	ldr	r3, [pc, #76]	; (c7cc <hal_gpio_init_out+0x54>)
    int port = GPIO_PORT(pin);
    c780:	1812      	adds	r2, r2, r0
{
    c782:	b573      	push	{r0, r1, r4, r5, r6, lr}
    int port = GPIO_PORT(pin);
    c784:	1152      	asrs	r2, r2, #5
{
    c786:	0004      	movs	r4, r0
    c788:	000d      	movs	r5, r1
    int port_pin = GPIO_PIN(pin);
    c78a:	4003      	ands	r3, r0
    c78c:	d504      	bpl.n	c798 <hal_gpio_init_out+0x20>
    c78e:	2120      	movs	r1, #32
    c790:	3b01      	subs	r3, #1
    c792:	4249      	negs	r1, r1
    c794:	430b      	orrs	r3, r1
    c796:	3301      	adds	r3, #1
    if(port > GPIO_MAX_PORT) {
    c798:	2a01      	cmp	r2, #1
    c79a:	dc13      	bgt.n	c7c4 <hal_gpio_init_out+0x4c>
    if((port_pin & valid_pins[port]) == 0) {
    c79c:	490c      	ldr	r1, [pc, #48]	; (c7d0 <hal_gpio_init_out+0x58>)
    c79e:	0092      	lsls	r2, r2, #2
    c7a0:	5852      	ldr	r2, [r2, r1]
    c7a2:	421a      	tst	r2, r3
    c7a4:	d00e      	beq.n	c7c4 <hal_gpio_init_out+0x4c>
    cfg.direction = PORT_PIN_DIR_OUTPUT_WTH_READBACK;
    c7a6:	2302      	movs	r3, #2
    cfg.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    c7a8:	2600      	movs	r6, #0
    cfg.direction = PORT_PIN_DIR_OUTPUT_WTH_READBACK;
    c7aa:	a901      	add	r1, sp, #4
    port_pin_set_config(pin, &cfg);
    c7ac:	b2e0      	uxtb	r0, r4
    cfg.direction = PORT_PIN_DIR_OUTPUT_WTH_READBACK;
    c7ae:	700b      	strb	r3, [r1, #0]
    cfg.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    c7b0:	704e      	strb	r6, [r1, #1]
    cfg.powersave = false;
    c7b2:	708e      	strb	r6, [r1, #2]
    port_pin_set_config(pin, &cfg);
    c7b4:	f000 f85c 	bl	c870 <port_pin_set_config>
    hal_gpio_write(pin, val);
    c7b8:	0020      	movs	r0, r4
    c7ba:	0029      	movs	r1, r5
    c7bc:	f7ff ffba 	bl	c734 <hal_gpio_write>
    return 0;
    c7c0:	0030      	movs	r0, r6
}
    c7c2:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
        return -1;
    c7c4:	2001      	movs	r0, #1
    c7c6:	4240      	negs	r0, r0
    c7c8:	e7fb      	b.n	c7c2 <hal_gpio_init_out+0x4a>
    c7ca:	46c0      	nop			; (mov r8, r8)
    c7cc:	8000001f 	.word	0x8000001f
    c7d0:	000107dc 	.word	0x000107dc

0000c7d4 <hal_gpio_toggle>:
 * Toggles the specified pin
 *
 * @param pin Pin number to toggle
 */
int hal_gpio_toggle(int pin)
{
    c7d4:	b510      	push	{r4, lr}
    c7d6:	0004      	movs	r4, r0
    int pin_state;

    pin_state = (hal_gpio_read(pin) == 0);
    c7d8:	f7ff ff74 	bl	c6c4 <hal_gpio_read>
    c7dc:	4241      	negs	r1, r0
    c7de:	4141      	adcs	r1, r0
    hal_gpio_write(pin, pin_state);
    c7e0:	0020      	movs	r0, r4
    c7e2:	f7ff ffa7 	bl	c734 <hal_gpio_write>
    return hal_gpio_read(pin);
    c7e6:	0020      	movs	r0, r4
    c7e8:	f7ff ff6c 	bl	c6c4 <hal_gpio_read>
}
    c7ec:	bd10      	pop	{r4, pc}
	...

0000c7f0 <extint_is_syncing>:
static inline bool extint_is_syncing(void)
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		if (eics[i]->STATUS.reg & EIC_STATUS_SYNCBUSY) {
    c7f0:	4b01      	ldr	r3, [pc, #4]	; (c7f8 <extint_is_syncing+0x8>)
    c7f2:	7858      	ldrb	r0, [r3, #1]
    c7f4:	09c0      	lsrs	r0, r0, #7
			return true;
		}
	}
	return false;
}
    c7f6:	4770      	bx	lr
    c7f8:	40001800 	.word	0x40001800

0000c7fc <_extint_enable>:
{
	Eic *const eics[EIC_INST_NUM] = EIC_INSTS;

	/* Enable all EIC hardware modules. */
	for (uint32_t i = 0; i < EIC_INST_NUM; i++) {
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    c7fc:	2302      	movs	r3, #2
    c7fe:	4a05      	ldr	r2, [pc, #20]	; (c814 <_extint_enable+0x18>)
{
    c800:	b510      	push	{r4, lr}
		eics[i]->CTRL.reg |= EIC_CTRL_ENABLE;
    c802:	7811      	ldrb	r1, [r2, #0]
    c804:	430b      	orrs	r3, r1
    c806:	7013      	strb	r3, [r2, #0]
	}

	while (extint_is_syncing()) {
    c808:	f7ff fff2 	bl	c7f0 <extint_is_syncing>
    c80c:	2800      	cmp	r0, #0
    c80e:	d1fb      	bne.n	c808 <_extint_enable+0xc>
		/* Wait for all hardware modules to complete synchronization */
	}
}
    c810:	bd10      	pop	{r4, pc}
    c812:	46c0      	nop			; (mov r8, r8)
    c814:	40001800 	.word	0x40001800

0000c818 <_system_extint_init>:
			PM->APBAMASK.reg |= mask;
    c818:	2340      	movs	r3, #64	; 0x40
{
    c81a:	b507      	push	{r0, r1, r2, lr}
    c81c:	4a10      	ldr	r2, [pc, #64]	; (c860 <_system_extint_init+0x48>)
	system_gclk_chan_set_config(EIC_GCLK_ID, &gclk_chan_conf);
    c81e:	2005      	movs	r0, #5
    c820:	6991      	ldr	r1, [r2, #24]
    c822:	430b      	orrs	r3, r1
    c824:	6193      	str	r3, [r2, #24]
{
	/* Sanity check arguments */
	Assert(config);

	/* Default configuration values */
	config->source_generator = GCLK_GENERATOR_0;
    c826:	2300      	movs	r3, #0
    c828:	a901      	add	r1, sp, #4
    c82a:	700b      	strb	r3, [r1, #0]
    c82c:	f7ff fdac 	bl	c388 <system_gclk_chan_set_config>
	system_gclk_chan_enable(EIC_GCLK_ID);
    c830:	2005      	movs	r0, #5
    c832:	f7ff fd6d 	bl	c310 <system_gclk_chan_enable>
		eics[i]->CTRL.reg |= EIC_CTRL_SWRST;
    c836:	2301      	movs	r3, #1
    c838:	4a0a      	ldr	r2, [pc, #40]	; (c864 <_system_extint_init+0x4c>)
    c83a:	7811      	ldrb	r1, [r2, #0]
    c83c:	430b      	orrs	r3, r1
    c83e:	7013      	strb	r3, [r2, #0]
	while (extint_is_syncing()) {
    c840:	f7ff ffd6 	bl	c7f0 <extint_is_syncing>
    c844:	2800      	cmp	r0, #0
    c846:	d1fb      	bne.n	c840 <_system_extint_init+0x28>
		_extint_dev.callbacks[j] = NULL;
    c848:	0001      	movs	r1, r0
    c84a:	4a07      	ldr	r2, [pc, #28]	; (c868 <_system_extint_init+0x50>)
    c84c:	0083      	lsls	r3, r0, #2
    c84e:	3001      	adds	r0, #1
    c850:	50d1      	str	r1, [r2, r3]
	for (uint8_t j = 0; j < EIC_NUMBER_OF_INTERRUPTS; j++) {
    c852:	2810      	cmp	r0, #16
    c854:	d1fa      	bne.n	c84c <_system_extint_init+0x34>
 * \param[in] vector Interrupt vector to enable
 */
static inline void system_interrupt_enable(
		const enum system_interrupt_vector vector)
{
	NVIC->ISER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    c856:	4b05      	ldr	r3, [pc, #20]	; (c86c <_system_extint_init+0x54>)
    c858:	6018      	str	r0, [r3, #0]
	_extint_enable();
    c85a:	f7ff ffcf 	bl	c7fc <_extint_enable>
}
    c85e:	bd07      	pop	{r0, r1, r2, pc}
    c860:	40000400 	.word	0x40000400
    c864:	40001800 	.word	0x40001800
    c868:	20002308 	.word	0x20002308
    c86c:	e000e100 	.word	0xe000e100

0000c870 <port_pin_set_config>:
 *  \param[in] config    Configuration settings for the pin
 */
void port_pin_set_config(
		const uint8_t gpio_pin,
		const struct port_config *const config)
{
    c870:	b507      	push	{r0, r1, r2, lr}
	config->mux_position = SYSTEM_PINMUX_GPIO;
    c872:	2280      	movs	r2, #128	; 0x80
    c874:	ab01      	add	r3, sp, #4
    c876:	701a      	strb	r2, [r3, #0]

	struct system_pinmux_config pinmux_config;
	system_pinmux_get_config_defaults(&pinmux_config);

	pinmux_config.mux_position = SYSTEM_PINMUX_GPIO;
	pinmux_config.direction    = (enum system_pinmux_pin_dir)config->direction;
    c878:	780a      	ldrb	r2, [r1, #0]
    c87a:	705a      	strb	r2, [r3, #1]
	pinmux_config.input_pull   = (enum system_pinmux_pin_pull)config->input_pull;
    c87c:	784a      	ldrb	r2, [r1, #1]
    c87e:	709a      	strb	r2, [r3, #2]
	pinmux_config.powersave    = config->powersave;
    c880:	788a      	ldrb	r2, [r1, #2]

	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    c882:	0019      	movs	r1, r3
	pinmux_config.powersave    = config->powersave;
    c884:	70da      	strb	r2, [r3, #3]
	system_pinmux_pin_set_config(gpio_pin, &pinmux_config);
    c886:	f000 f843 	bl	c910 <system_pinmux_pin_set_config>
}
    c88a:	bd07      	pop	{r0, r1, r2, pc}

0000c88c <_system_pinmux_config>:
 */
static void _system_pinmux_config(
		PortGroup *const port,
		const uint32_t pin_mask,
		const struct system_pinmux_config *const config)
{
    c88c:	b5f0      	push	{r4, r5, r6, r7, lr}

	/* Track the configuration bits into a temporary variable before writing */
	uint32_t pin_cfg = 0;

	/* Enabled powersave mode, don't create configuration */
	if (!config->powersave) {
    c88e:	78d5      	ldrb	r5, [r2, #3]
    c890:	2d00      	cmp	r5, #0
    c892:	d135      	bne.n	c900 <_system_pinmux_config+0x74>
		/* Enable the pin peripheral MUX flag if non-GPIO selected (pinmux will
		 * be written later) and store the new MUX mask */
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    c894:	7814      	ldrb	r4, [r2, #0]
	uint32_t pin_cfg = 0;
    c896:	002b      	movs	r3, r5
		if (config->mux_position != SYSTEM_PINMUX_GPIO) {
    c898:	2c80      	cmp	r4, #128	; 0x80
    c89a:	d003      	beq.n	c8a4 <_system_pinmux_config+0x18>
			pin_cfg |= PORT_WRCONFIG_PMUXEN;
			pin_cfg |= (config->mux_position << PORT_WRCONFIG_PMUX_Pos);
    c89c:	2380      	movs	r3, #128	; 0x80
    c89e:	0624      	lsls	r4, r4, #24
    c8a0:	025b      	lsls	r3, r3, #9
    c8a2:	4323      	orrs	r3, r4
		}

		/* Check if the user has requested that the input buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_INPUT) ||
    c8a4:	7854      	ldrb	r4, [r2, #1]
    c8a6:	2602      	movs	r6, #2
    c8a8:	0027      	movs	r7, r4
    c8aa:	43b7      	bics	r7, r6
    c8ac:	d106      	bne.n	c8bc <_system_pinmux_config+0x30>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Enable input buffer flag */
			pin_cfg |= PORT_WRCONFIG_INEN;

			/* Enable pull-up/pull-down control flag if requested */
			if (config->input_pull != SYSTEM_PINMUX_PIN_PULL_NONE) {
    c8ae:	7896      	ldrb	r6, [r2, #2]
    c8b0:	2e00      	cmp	r6, #0
    c8b2:	d122      	bne.n	c8fa <_system_pinmux_config+0x6e>
			pin_cfg |= PORT_WRCONFIG_INEN;
    c8b4:	2680      	movs	r6, #128	; 0x80
    c8b6:	02b6      	lsls	r6, r6, #10
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    c8b8:	4333      	orrs	r3, r6
			}

			/* Clear the port DIR bits to disable the output buffer */
			port->DIRCLR.reg = pin_mask;
    c8ba:	6041      	str	r1, [r0, #4]
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    c8bc:	3c01      	subs	r4, #1
    c8be:	2c01      	cmp	r4, #1
    c8c0:	d801      	bhi.n	c8c6 <_system_pinmux_config+0x3a>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Cannot use a pull-up if the output driver is enabled,
			 * if requested the input buffer can only sample the current
			 * output state */
			pin_cfg &= ~PORT_WRCONFIG_PULLEN;
    c8c2:	4c12      	ldr	r4, [pc, #72]	; (c90c <_system_pinmux_config+0x80>)
    c8c4:	4023      	ands	r3, r4

	/* Configure the lower 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    c8c6:	24a0      	movs	r4, #160	; 0xa0
	uint32_t lower_pin_mask = (pin_mask & 0xFFFF);
    c8c8:	b28e      	uxth	r6, r1
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG;
    c8ca:	05e4      	lsls	r4, r4, #23
    c8cc:	4334      	orrs	r4, r6
    c8ce:	431c      	orrs	r4, r3
		= (lower_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    c8d0:	6284      	str	r4, [r0, #40]	; 0x28

	/* Configure the upper 16-bits of the port to the desired configuration,
	 * including the pin peripheral multiplexer just in case it is enabled */
	port->WRCONFIG.reg
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    c8d2:	24d0      	movs	r4, #208	; 0xd0
	uint32_t upper_pin_mask = (pin_mask >> 16);
    c8d4:	0c0e      	lsrs	r6, r1, #16
			pin_cfg | PORT_WRCONFIG_WRPMUX | PORT_WRCONFIG_WRPINCFG |
    c8d6:	0624      	lsls	r4, r4, #24
    c8d8:	4334      	orrs	r4, r6
    c8da:	431c      	orrs	r4, r3
		= (upper_pin_mask << PORT_WRCONFIG_PINMASK_Pos) |
    c8dc:	6284      	str	r4, [r0, #40]	; 0x28
			PORT_WRCONFIG_HWSEL;

	if(!config->powersave) {
    c8de:	2d00      	cmp	r5, #0
    c8e0:	d10a      	bne.n	c8f8 <_system_pinmux_config+0x6c>
		/* Set the pull-up state once the port pins are configured if one was
		 * requested and it does not violate the valid set of port
		 * configurations */
		if (pin_cfg & PORT_WRCONFIG_PULLEN) {
    c8e2:	035b      	lsls	r3, r3, #13
    c8e4:	d503      	bpl.n	c8ee <_system_pinmux_config+0x62>
			/* Set the OUT register bits to enable the pull-up if requested,
			 * clear to enable pull-down */
			if (config->input_pull == SYSTEM_PINMUX_PIN_PULL_UP) {
    c8e6:	7893      	ldrb	r3, [r2, #2]
    c8e8:	2b01      	cmp	r3, #1
    c8ea:	d10c      	bne.n	c906 <_system_pinmux_config+0x7a>
				port->OUTSET.reg = pin_mask;
    c8ec:	6181      	str	r1, [r0, #24]
				port->OUTCLR.reg = pin_mask;
			}
		}

		/* Check if the user has requested that the output buffer be enabled */
		if ((config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT) ||
    c8ee:	7853      	ldrb	r3, [r2, #1]
    c8f0:	3b01      	subs	r3, #1
    c8f2:	2b01      	cmp	r3, #1
    c8f4:	d800      	bhi.n	c8f8 <_system_pinmux_config+0x6c>
				(config->direction == SYSTEM_PINMUX_PIN_DIR_OUTPUT_WITH_READBACK)) {
			/* Set the port DIR bits to enable the output buffer */
			port->DIRSET.reg = pin_mask;
    c8f6:	6081      	str	r1, [r0, #8]
		}
	}
}
    c8f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
				pin_cfg |= PORT_WRCONFIG_PULLEN;
    c8fa:	26c0      	movs	r6, #192	; 0xc0
    c8fc:	02f6      	lsls	r6, r6, #11
    c8fe:	e7db      	b.n	c8b8 <_system_pinmux_config+0x2c>
		port->DIRCLR.reg = pin_mask;
    c900:	6041      	str	r1, [r0, #4]
	uint32_t pin_cfg = 0;
    c902:	2300      	movs	r3, #0
    c904:	e7df      	b.n	c8c6 <_system_pinmux_config+0x3a>
				port->OUTCLR.reg = pin_mask;
    c906:	6141      	str	r1, [r0, #20]
    c908:	e7f1      	b.n	c8ee <_system_pinmux_config+0x62>
    c90a:	46c0      	nop			; (mov r8, r8)
    c90c:	fffbffff 	.word	0xfffbffff

0000c910 <system_pinmux_pin_set_config>:
 * \param[in] config    Configuration settings for the pin
 */
void system_pinmux_pin_set_config(
		const uint8_t gpio_pin,
		const struct system_pinmux_config *const config)
{
    c910:	b510      	push	{r4, lr}
    c912:	0003      	movs	r3, r0
    c914:	000a      	movs	r2, r1
	uint8_t group_index = (gpio_pin / 32);
    c916:	0944      	lsrs	r4, r0, #5
	if (port_index < PORT_INST_NUM) {
    c918:	09c1      	lsrs	r1, r0, #7
		return &(ports[port_index]->Group[group_index]);
	} else {
		Assert(false);
		return NULL;
    c91a:	2000      	movs	r0, #0
	if (port_index < PORT_INST_NUM) {
    c91c:	4281      	cmp	r1, r0
    c91e:	d102      	bne.n	c926 <system_pinmux_pin_set_config+0x16>
		return &(ports[port_index]->Group[group_index]);
    c920:	4904      	ldr	r1, [pc, #16]	; (c934 <system_pinmux_pin_set_config+0x24>)
    c922:	01e0      	lsls	r0, r4, #7
    c924:	1840      	adds	r0, r0, r1
	PortGroup *const port = system_pinmux_get_group_from_gpio_pin(gpio_pin);
	uint32_t pin_mask = (1UL << (gpio_pin % 32));
    c926:	211f      	movs	r1, #31
    c928:	400b      	ands	r3, r1
    c92a:	391e      	subs	r1, #30
    c92c:	4099      	lsls	r1, r3

	_system_pinmux_config(port, pin_mask, config);
    c92e:	f7ff ffad 	bl	c88c <_system_pinmux_config>
}
    c932:	bd10      	pop	{r4, pc}
    c934:	41004400 	.word	0x41004400

0000c938 <__assert_func>:
}
#endif

void
__assert_func(const char *file, int line, const char *func, const char *e)
{
    c938:	b510      	push	{r4, lr}
    c93a:	4674      	mov	r4, lr
    int sr;

    OS_ENTER_CRITICAL(sr);
    c93c:	f000 fd28 	bl	d390 <os_arch_save_sr>
    (void)sr;
    console_blocking_mode();
    c940:	f001 f8fe 	bl	db40 <console_blocking_mode>
    console_printf("Assert @ 0x%x\n",
    c944:	0021      	movs	r1, r4
    c946:	4807      	ldr	r0, [pc, #28]	; (c964 <__assert_func+0x2c>)
    c948:	f001 fa4c 	bl	dde4 <console_printf>
                   (unsigned int)__builtin_return_address(0));
    if (hal_debugger_connected()) {
    c94c:	f001 fd58 	bl	e400 <hal_debugger_connected>
    c950:	2800      	cmp	r0, #0
    c952:	d000      	beq.n	c956 <__assert_func+0x1e>
       /*
        * If debugger is attached, breakpoint before the trap.
        */
       asm("bkpt");
    c954:	be00      	bkpt	0x0000
    }
    SCB->ICSR = SCB_ICSR_NMIPENDSET_Msk;
    c956:	2280      	movs	r2, #128	; 0x80
    c958:	4b03      	ldr	r3, [pc, #12]	; (c968 <__assert_func+0x30>)
    c95a:	0612      	lsls	r2, r2, #24
    c95c:	605a      	str	r2, [r3, #4]
    /* Exception happens right away. Next line not executed. */
    hal_system_reset();
    c95e:	f001 fd3b 	bl	e3d8 <hal_system_reset>
    c962:	46c0      	nop			; (mov r8, r8)
    c964:	000107e4 	.word	0x000107e4
    c968:	e000ed00 	.word	0xe000ed00

0000c96c <os_default_irq>:
}

void
os_default_irq(struct trap_frame *tf)
{
    c96c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    c96e:	0004      	movs	r4, r0
    struct coredump_regs regs;
#endif

    console_blocking_mode();
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    c970:	4d18      	ldr	r5, [pc, #96]	; (c9d4 <os_default_irq+0x68>)
    console_blocking_mode();
    c972:	f001 f8e5 	bl	db40 <console_blocking_mode>
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
    c976:	6869      	ldr	r1, [r5, #4]
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
    c978:	6822      	ldr	r2, [r4, #0]
    c97a:	05c9      	lsls	r1, r1, #23
    c97c:	0dc9      	lsrs	r1, r1, #23
    c97e:	4816      	ldr	r0, [pc, #88]	; (c9d8 <os_default_irq+0x6c>)
    c980:	f001 fa30 	bl	dde4 <console_printf>
    console_printf(" r0:0x%08lx  r1:0x%08lx  r2:0x%08lx  r3:0x%08lx\n",
      tf->ef->r0, tf->ef->r1, tf->ef->r2, tf->ef->r3);
    c984:	6821      	ldr	r1, [r4, #0]
    console_printf(" r0:0x%08lx  r1:0x%08lx  r2:0x%08lx  r3:0x%08lx\n",
    c986:	4815      	ldr	r0, [pc, #84]	; (c9dc <os_default_irq+0x70>)
    c988:	68cb      	ldr	r3, [r1, #12]
    c98a:	9300      	str	r3, [sp, #0]
    c98c:	688b      	ldr	r3, [r1, #8]
    c98e:	684a      	ldr	r2, [r1, #4]
    c990:	6809      	ldr	r1, [r1, #0]
    c992:	f001 fa27 	bl	dde4 <console_printf>
    console_printf(" r4:0x%08lx  r5:0x%08lx  r6:0x%08lx  r7:0x%08lx\n",
    c996:	6923      	ldr	r3, [r4, #16]
    c998:	68a2      	ldr	r2, [r4, #8]
    c99a:	9300      	str	r3, [sp, #0]
    c99c:	6861      	ldr	r1, [r4, #4]
    c99e:	68e3      	ldr	r3, [r4, #12]
    c9a0:	480f      	ldr	r0, [pc, #60]	; (c9e0 <os_default_irq+0x74>)
    c9a2:	f001 fa1f 	bl	dde4 <console_printf>
      tf->r4, tf->r5, tf->r6, tf->r7);
    console_printf(" r8:0x%08lx  r9:0x%08lx r10:0x%08lx r11:0x%08lx\n",
    c9a6:	6a23      	ldr	r3, [r4, #32]
    c9a8:	69a2      	ldr	r2, [r4, #24]
    c9aa:	9300      	str	r3, [sp, #0]
    c9ac:	6961      	ldr	r1, [r4, #20]
    c9ae:	69e3      	ldr	r3, [r4, #28]
    c9b0:	480c      	ldr	r0, [pc, #48]	; (c9e4 <os_default_irq+0x78>)
    c9b2:	f001 fa17 	bl	dde4 <console_printf>
      tf->r8, tf->r9, tf->r10, tf->r11);
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
      tf->ef->r12, tf->ef->lr, tf->ef->pc, tf->ef->psr);
    c9b6:	6821      	ldr	r1, [r4, #0]
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
    c9b8:	480b      	ldr	r0, [pc, #44]	; (c9e8 <os_default_irq+0x7c>)
    c9ba:	69cb      	ldr	r3, [r1, #28]
    c9bc:	9300      	str	r3, [sp, #0]
    c9be:	698b      	ldr	r3, [r1, #24]
    c9c0:	694a      	ldr	r2, [r1, #20]
    c9c2:	6909      	ldr	r1, [r1, #16]
    c9c4:	f001 fa0e 	bl	dde4 <console_printf>
    console_printf("ICSR:0x%08lx\n", SCB->ICSR);
    c9c8:	6869      	ldr	r1, [r5, #4]
    c9ca:	4808      	ldr	r0, [pc, #32]	; (c9ec <os_default_irq+0x80>)
    c9cc:	f001 fa0a 	bl	dde4 <console_printf>
#if MYNEWT_VAL(OS_COREDUMP)
    trap_to_coredump(tf, &regs);
    coredump_dump(&regs, sizeof(regs));
#endif
    hal_system_reset();
    c9d0:	f001 fd02 	bl	e3d8 <hal_system_reset>
    c9d4:	e000ed00 	.word	0xe000ed00
    c9d8:	000107f3 	.word	0x000107f3
    c9dc:	00010824 	.word	0x00010824
    c9e0:	00010855 	.word	0x00010855
    c9e4:	00010886 	.word	0x00010886
    c9e8:	000108b7 	.word	0x000108b7
    c9ec:	000108e8 	.word	0x000108e8

0000c9f0 <os_idle_task>:
 *
 * @param arg unused
 */
void
os_idle_task(void *arg)
{
    c9f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_time_t sanity_itvl_ticks;

    sanity_itvl_ticks = (MYNEWT_VAL(SANITY_INTERVAL) * OS_TICKS_PER_SEC) / 1000;
    sanity_last = 0;

    hal_watchdog_tickle();
    c9f2:	f002 f897 	bl	eb24 <hal_watchdog_tickle>
    sanity_last = 0;
    c9f6:	2400      	movs	r4, #0

    while (1) {
        ++g_os_idle_ctr;
    c9f8:	4a19      	ldr	r2, [pc, #100]	; (ca60 <os_idle_task+0x70>)
    c9fa:	6813      	ldr	r3, [r2, #0]
    c9fc:	3301      	adds	r3, #1
    c9fe:	6013      	str	r3, [r2, #0]

        now = os_time_get();
    ca00:	f000 fc62 	bl	d2c8 <os_time_get>
        if (OS_TIME_TICK_GT(now, sanity_last + sanity_itvl_ticks)) {
    ca04:	4b17      	ldr	r3, [pc, #92]	; (ca64 <os_idle_task+0x74>)
        now = os_time_get();
    ca06:	0005      	movs	r5, r0
        if (OS_TIME_TICK_GT(now, sanity_last + sanity_itvl_ticks)) {
    ca08:	18c3      	adds	r3, r0, r3
    ca0a:	1b1b      	subs	r3, r3, r4
    ca0c:	2b00      	cmp	r3, #0
    ca0e:	dd04      	ble.n	ca1a <os_idle_task+0x2a>
            os_sanity_run();
    ca10:	f000 fa72 	bl	cef8 <os_sanity_run>
            /* Tickle the watchdog after successfully running sanity */
            hal_watchdog_tickle();
            sanity_last = now;
    ca14:	002c      	movs	r4, r5
            hal_watchdog_tickle();
    ca16:	f002 f885 	bl	eb24 <hal_watchdog_tickle>
        }

        OS_ENTER_CRITICAL(sr);
    ca1a:	f000 fcb9 	bl	d390 <os_arch_save_sr>
    ca1e:	0005      	movs	r5, r0
        now = os_time_get();
    ca20:	f000 fc52 	bl	d2c8 <os_time_get>
    ca24:	0006      	movs	r6, r0
        sticks = os_sched_wakeup_ticks(now);
    ca26:	f000 fb83 	bl	d130 <os_sched_wakeup_ticks>
    ca2a:	0007      	movs	r7, r0
        cticks = os_callout_wakeup_ticks(now);
    ca2c:	0030      	movs	r0, r6
    ca2e:	f000 f8f9 	bl	cc24 <os_callout_wakeup_ticks>
        iticks = min(sticks, cticks);
    ca32:	4287      	cmp	r7, r0
    ca34:	d900      	bls.n	ca38 <os_idle_task+0x48>
    ca36:	0007      	movs	r7, r0
        /* Wakeup in time to run sanity as well from the idle context,
         * as the idle task does not schedule itself.
         */
        iticks = min(iticks, ((sanity_last + sanity_itvl_ticks) - now));
    ca38:	4b0b      	ldr	r3, [pc, #44]	; (ca68 <os_idle_task+0x78>)
    ca3a:	18e3      	adds	r3, r4, r3
    ca3c:	1b9b      	subs	r3, r3, r6
    ca3e:	42bb      	cmp	r3, r7
    ca40:	d900      	bls.n	ca44 <os_idle_task+0x54>
    ca42:	003b      	movs	r3, r7

        if (iticks < MIN_IDLE_TICKS) {
            iticks = 0;
    ca44:	2000      	movs	r0, #0
        if (iticks < MIN_IDLE_TICKS) {
    ca46:	2b63      	cmp	r3, #99	; 0x63
    ca48:	d904      	bls.n	ca54 <os_idle_task+0x64>
    ca4a:	0018      	movs	r0, r3
    ca4c:	4b07      	ldr	r3, [pc, #28]	; (ca6c <os_idle_task+0x7c>)
    ca4e:	4298      	cmp	r0, r3
    ca50:	d900      	bls.n	ca54 <os_idle_task+0x64>
    ca52:	0018      	movs	r0, r3
        /* Tell the architecture specific support to put the processor to sleep
         * for 'n' ticks.
         */

        os_trace_idle();
        os_tick_idle(iticks);
    ca54:	f001 fc96 	bl	e384 <os_tick_idle>
        OS_EXIT_CRITICAL(sr);
    ca58:	0028      	movs	r0, r5
    ca5a:	f000 fc9f 	bl	d39c <os_arch_restore_sr>
        ++g_os_idle_ctr;
    ca5e:	e7cb      	b.n	c9f8 <os_idle_task+0x8>
    ca60:	20002398 	.word	0x20002398
    ca64:	ffffc568 	.word	0xffffc568
    ca68:	00003a98 	.word	0x00003a98
    ca6c:	000927c0 	.word	0x000927c0

0000ca70 <os_main>:
os_main(void *arg)
{
    int (*fn)(int argc, char **argv) = arg;

#if !MYNEWT_VAL(SELFTEST)
    fn(0, NULL);
    ca70:	2100      	movs	r1, #0
{
    ca72:	0003      	movs	r3, r0
    ca74:	b510      	push	{r4, lr}
    fn(0, NULL);
    ca76:	0008      	movs	r0, r1
    ca78:	4798      	blx	r3
    (void)fn;
    while (1) {
        os_eventq_run(os_eventq_dflt_get());
    }
#endif
    assert(0);
    ca7a:	2300      	movs	r3, #0
    ca7c:	001a      	movs	r2, r3
    ca7e:	0019      	movs	r1, r3
    ca80:	0018      	movs	r0, r3
    ca82:	f7ff ff59 	bl	c938 <__assert_func>
	...

0000ca88 <os_started>:
    return (g_os_started);
    ca88:	4b01      	ldr	r3, [pc, #4]	; (ca90 <os_started+0x8>)
    ca8a:	6818      	ldr	r0, [r3, #0]
}
    ca8c:	4770      	bx	lr
    ca8e:	46c0      	nop			; (mov r8, r8)
    ca90:	2000249c 	.word	0x2000249c

0000ca94 <os_init_idle_task>:
}

void
os_init_idle_task(void)
{
    ca94:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    int rc;

    rc = os_task_init(&g_idle_task, "idle", os_idle_task, NULL,
    ca96:	2340      	movs	r3, #64	; 0x40
    ca98:	9303      	str	r3, [sp, #12]
    ca9a:	4b10      	ldr	r3, [pc, #64]	; (cadc <os_init_idle_task+0x48>)
    ca9c:	4a10      	ldr	r2, [pc, #64]	; (cae0 <os_init_idle_task+0x4c>)
    ca9e:	9302      	str	r3, [sp, #8]
    caa0:	2301      	movs	r3, #1
    caa2:	425b      	negs	r3, r3
    caa4:	9301      	str	r3, [sp, #4]
    caa6:	3301      	adds	r3, #1
    caa8:	33ff      	adds	r3, #255	; 0xff
    caaa:	9300      	str	r3, [sp, #0]
    caac:	490d      	ldr	r1, [pc, #52]	; (cae4 <os_init_idle_task+0x50>)
    caae:	2300      	movs	r3, #0
    cab0:	480d      	ldr	r0, [pc, #52]	; (cae8 <os_init_idle_task+0x54>)
    cab2:	f000 fb75 	bl	d1a0 <os_task_init>
            OS_IDLE_PRIO, OS_WAIT_FOREVER, g_idle_task_stack,
            OS_STACK_ALIGN(OS_IDLE_STACK_SIZE));
    assert(rc == 0);
    cab6:	2800      	cmp	r0, #0
    cab8:	d005      	beq.n	cac6 <os_init_idle_task+0x32>
    caba:	2300      	movs	r3, #0
    cabc:	001a      	movs	r2, r3
    cabe:	0019      	movs	r1, r3
    cac0:	0018      	movs	r0, r3
    cac2:	f7ff ff39 	bl	c938 <__assert_func>

    /* Initialize sanity */
    rc = os_sanity_init();
    cac6:	f000 fa43 	bl	cf50 <os_sanity_init>
    assert(rc == 0);
    caca:	2800      	cmp	r0, #0
    cacc:	d1f5      	bne.n	caba <os_init_idle_task+0x26>

    assert(MYNEWT_VAL(WATCHDOG_INTERVAL) - 200 > MYNEWT_VAL(SANITY_INTERVAL));

    rc = hal_watchdog_init(MYNEWT_VAL(WATCHDOG_INTERVAL));
    cace:	4807      	ldr	r0, [pc, #28]	; (caec <os_init_idle_task+0x58>)
    cad0:	f001 ffe6 	bl	eaa0 <hal_watchdog_init>
    assert(rc == 0);
    cad4:	2800      	cmp	r0, #0
    cad6:	d1f0      	bne.n	caba <os_init_idle_task+0x26>
}
    cad8:	b005      	add	sp, #20
    cada:	bd00      	pop	{pc}
    cadc:	2000239c 	.word	0x2000239c
    cae0:	0000c9f1 	.word	0x0000c9f1
    cae4:	000108fb 	.word	0x000108fb
    cae8:	20002348 	.word	0x20002348
    caec:	00007530 	.word	0x00007530

0000caf0 <os_init>:
 * Initialize the operating system, calls into the architecture specific
 * support to initialize the operating system.
 */
void
os_init(int (*main_fn)(int argc, char **arg))
{
    caf0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    os_error_t err;

    TAILQ_INIT(&g_callout_list);
    caf2:	2200      	movs	r2, #0
    caf4:	4b1d      	ldr	r3, [pc, #116]	; (cb6c <os_init+0x7c>)
{
    caf6:	0004      	movs	r4, r0
    TAILQ_INIT(&g_callout_list);
    caf8:	601a      	str	r2, [r3, #0]
    cafa:	605b      	str	r3, [r3, #4]
    STAILQ_INIT(&g_os_task_list);
    cafc:	4b1c      	ldr	r3, [pc, #112]	; (cb70 <os_init+0x80>)
    cafe:	601a      	str	r2, [r3, #0]
    cb00:	605b      	str	r3, [r3, #4]
    os_eventq_init(os_eventq_dflt_get());
    cb02:	f000 f98d 	bl	ce20 <os_eventq_dflt_get>
    cb06:	f000 f947 	bl	cd98 <os_eventq_init>

    /* Initialize device list. */
    os_dev_reset();
    cb0a:	f000 f93d 	bl	cd88 <os_dev_reset>

    err = os_arch_os_init();
    cb0e:	f000 fc6b 	bl	d3e8 <os_arch_os_init>
    assert(err == OS_OK);
    cb12:	2800      	cmp	r0, #0
    cb14:	d005      	beq.n	cb22 <os_init+0x32>
    cb16:	2300      	movs	r3, #0
    cb18:	001a      	movs	r2, r3
    cb1a:	0019      	movs	r1, r3
    cb1c:	0018      	movs	r0, r3
    cb1e:	f7ff ff0b 	bl	c938 <__assert_func>

    if (main_fn) {
    cb22:	2c00      	cmp	r4, #0
    cb24:	d012      	beq.n	cb4c <os_init+0x5c>
        err = os_task_init(&os_main_task, "main", os_main, main_fn,
    cb26:	2380      	movs	r3, #128	; 0x80
    cb28:	00db      	lsls	r3, r3, #3
    cb2a:	9303      	str	r3, [sp, #12]
    cb2c:	4b11      	ldr	r3, [pc, #68]	; (cb74 <os_init+0x84>)
    cb2e:	4a12      	ldr	r2, [pc, #72]	; (cb78 <os_init+0x88>)
    cb30:	9302      	str	r3, [sp, #8]
    cb32:	2301      	movs	r3, #1
    cb34:	425b      	negs	r3, r3
    cb36:	9301      	str	r3, [sp, #4]
    cb38:	3380      	adds	r3, #128	; 0x80
    cb3a:	9300      	str	r3, [sp, #0]
    cb3c:	490f      	ldr	r1, [pc, #60]	; (cb7c <os_init+0x8c>)
    cb3e:	0023      	movs	r3, r4
    cb40:	480f      	ldr	r0, [pc, #60]	; (cb80 <os_init+0x90>)
    cb42:	f000 fb2d 	bl	d1a0 <os_task_init>
                           OS_MAIN_TASK_PRIO, OS_WAIT_FOREVER, os_main_stack,
                           OS_STACK_ALIGN(OS_MAIN_STACK_SIZE));
        assert(err == 0);
    cb46:	b2c0      	uxtb	r0, r0
    cb48:	2800      	cmp	r0, #0
    cb4a:	d1e4      	bne.n	cb16 <os_init+0x26>
    }
    /* Call bsp related OS initializations */
    hal_bsp_init();
    cb4c:	f001 fa84 	bl	e058 <hal_bsp_init>

    err = (os_error_t) os_dev_initialize_all(OS_DEV_INIT_PRIMARY);
    cb50:	2001      	movs	r0, #1
    cb52:	f000 f8cf 	bl	ccf4 <os_dev_initialize_all>
    assert(err == OS_OK);
    cb56:	b2c0      	uxtb	r0, r0
    cb58:	2800      	cmp	r0, #0
    cb5a:	d1dc      	bne.n	cb16 <os_init+0x26>

    err = (os_error_t) os_dev_initialize_all(OS_DEV_INIT_SECONDARY);
    cb5c:	3002      	adds	r0, #2
    cb5e:	f000 f8c9 	bl	ccf4 <os_dev_initialize_all>
    assert(err == OS_OK);
    cb62:	b2c0      	uxtb	r0, r0
    cb64:	2800      	cmp	r0, #0
    cb66:	d1d6      	bne.n	cb16 <os_init+0x26>
}
    cb68:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
    cb6a:	46c0      	nop			; (mov r8, r8)
    cb6c:	200024a0 	.word	0x200024a0
    cb70:	200024bc 	.word	0x200024bc
    cb74:	2000014c 	.word	0x2000014c
    cb78:	0000ca71 	.word	0x0000ca71
    cb7c:	000108f6 	.word	0x000108f6
    cb80:	2000114c 	.word	0x2000114c

0000cb84 <os_start>:
 * Start the operating system, calls into the architecture specific support
 * to start the operating system.
 */
void
os_start(void)
{
    cb84:	b510      	push	{r4, lr}
#if MYNEWT_VAL(OS_SCHEDULING)
    os_error_t err;

    /* Enable the watchdog prior to starting the OS */
    hal_watchdog_enable();
    cb86:	f001 ffc3 	bl	eb10 <hal_watchdog_enable>

    err = os_arch_os_start();
    cb8a:	f000 fcab 	bl	d4e4 <os_arch_os_start>
    assert(err == OS_OK);
    cb8e:	2800      	cmp	r0, #0
    cb90:	d005      	beq.n	cb9e <os_start+0x1a>
    cb92:	2300      	movs	r3, #0
    cb94:	001a      	movs	r2, r3
    cb96:	0019      	movs	r1, r3
    cb98:	0018      	movs	r0, r3
    cb9a:	f7ff fecd 	bl	c938 <__assert_func>
#else
    assert(0);
#endif
}
    cb9e:	bd10      	pop	{r4, pc}

0000cba0 <os_pkg_init>:

void
os_pkg_init(void)
{
    cba0:	b510      	push	{r4, lr}
    os_error_t err;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
    cba2:	4b09      	ldr	r3, [pc, #36]	; (cbc8 <os_pkg_init+0x28>)
    cba4:	781b      	ldrb	r3, [r3, #0]
    cba6:	2b00      	cmp	r3, #0
    cba8:	d105      	bne.n	cbb6 <os_pkg_init+0x16>
    cbaa:	2300      	movs	r3, #0
    cbac:	001a      	movs	r2, r3
    cbae:	0019      	movs	r1, r3
    cbb0:	0018      	movs	r0, r3
    cbb2:	f7ff fec1 	bl	c938 <__assert_func>

    err = os_dev_initialize_all(OS_DEV_INIT_KERNEL);
    cbb6:	2003      	movs	r0, #3
    cbb8:	f000 f89c 	bl	ccf4 <os_dev_initialize_all>
    assert(err == OS_OK);
    cbbc:	b2c0      	uxtb	r0, r0
    cbbe:	2800      	cmp	r0, #0
    cbc0:	d1f3      	bne.n	cbaa <os_pkg_init+0xa>

    os_msys_init();
    cbc2:	f000 f931 	bl	ce28 <os_msys_init>
}
    cbc6:	bd10      	pop	{r4, pc}
    cbc8:	200024d0 	.word	0x200024d0

0000cbcc <os_callout_tick>:
 * to run, it posts an event for each callout that's ready to run,
 * to the event queue provided to os_callout_init().
 */
void
os_callout_tick(void)
{
    cbcc:	b570      	push	{r4, r5, r6, lr}
    os_sr_t sr;
    struct os_callout *c;
    uint32_t now;

    now = os_time_get();
    cbce:	f000 fb7b 	bl	d2c8 <os_time_get>
    cbd2:	0005      	movs	r5, r0

    while (1) {
        OS_ENTER_CRITICAL(sr);
    cbd4:	f000 fbdc 	bl	d390 <os_arch_save_sr>
        c = TAILQ_FIRST(&g_callout_list);
    cbd8:	4a11      	ldr	r2, [pc, #68]	; (cc20 <os_callout_tick+0x54>)
    cbda:	6814      	ldr	r4, [r2, #0]
        if (c) {
    cbdc:	2c00      	cmp	r4, #0
    cbde:	d00b      	beq.n	cbf8 <os_callout_tick+0x2c>
            if (OS_TIME_TICK_GEQ(now, c->c_ticks)) {
    cbe0:	6963      	ldr	r3, [r4, #20]
    cbe2:	1aeb      	subs	r3, r5, r3
    cbe4:	d415      	bmi.n	cc12 <os_callout_tick+0x46>
                TAILQ_REMOVE(&g_callout_list, c, c_next);
    cbe6:	69a3      	ldr	r3, [r4, #24]
    cbe8:	69e1      	ldr	r1, [r4, #28]
    cbea:	2b00      	cmp	r3, #0
    cbec:	d00f      	beq.n	cc0e <os_callout_tick+0x42>
    cbee:	61d9      	str	r1, [r3, #28]
    cbf0:	69e2      	ldr	r2, [r4, #28]
    cbf2:	6013      	str	r3, [r2, #0]
                c->c_next.tqe_prev = NULL;
    cbf4:	2300      	movs	r3, #0
    cbf6:	61e3      	str	r3, [r4, #28]
            } else {
                c = NULL;
            }
        }
        OS_EXIT_CRITICAL(sr);
    cbf8:	f000 fbd0 	bl	d39c <os_arch_restore_sr>

        if (c) {
    cbfc:	2c00      	cmp	r4, #0
    cbfe:	d00e      	beq.n	cc1e <os_callout_tick+0x52>
            if (c->c_evq) {
    cc00:	6920      	ldr	r0, [r4, #16]
    cc02:	2800      	cmp	r0, #0
    cc04:	d007      	beq.n	cc16 <os_callout_tick+0x4a>
                os_eventq_put(c->c_evq, &c->c_ev);
    cc06:	0021      	movs	r1, r4
    cc08:	f000 f8d2 	bl	cdb0 <os_eventq_put>
    cc0c:	e7e2      	b.n	cbd4 <os_callout_tick+0x8>
                TAILQ_REMOVE(&g_callout_list, c, c_next);
    cc0e:	6051      	str	r1, [r2, #4]
    cc10:	e7ee      	b.n	cbf0 <os_callout_tick+0x24>
    cc12:	2400      	movs	r4, #0
    cc14:	e7f0      	b.n	cbf8 <os_callout_tick+0x2c>
            } else {
                c->c_ev.ev_cb(&c->c_ev);
    cc16:	6863      	ldr	r3, [r4, #4]
    cc18:	0020      	movs	r0, r4
    cc1a:	4798      	blx	r3
    cc1c:	e7da      	b.n	cbd4 <os_callout_tick+0x8>
            }
        } else {
            break;
        }
    }
}
    cc1e:	bd70      	pop	{r4, r5, r6, pc}
    cc20:	200024a0 	.word	0x200024a0

0000cc24 <os_callout_wakeup_ticks>:
 *
 * @return Number of ticks to first pending callout
 */
os_time_t
os_callout_wakeup_ticks(os_time_t now)
{
    cc24:	b510      	push	{r4, lr}
    cc26:	0004      	movs	r4, r0
    os_time_t rt;
    struct os_callout *c;

    OS_ASSERT_CRITICAL();
    cc28:	f000 fbbc 	bl	d3a4 <os_arch_in_critical>
    cc2c:	2800      	cmp	r0, #0
    cc2e:	d104      	bne.n	cc3a <os_callout_wakeup_ticks+0x16>
    cc30:	0003      	movs	r3, r0
    cc32:	0002      	movs	r2, r0
    cc34:	0001      	movs	r1, r0
    cc36:	f7ff fe7f 	bl	c938 <__assert_func>

    c = TAILQ_FIRST(&g_callout_list);
    cc3a:	4b06      	ldr	r3, [pc, #24]	; (cc54 <os_callout_wakeup_ticks+0x30>)
    cc3c:	681b      	ldr	r3, [r3, #0]
    if (c != NULL) {
    cc3e:	2b00      	cmp	r3, #0
    cc40:	d005      	beq.n	cc4e <os_callout_wakeup_ticks+0x2a>
        if (OS_TIME_TICK_GEQ(c->c_ticks, now)) {
    cc42:	6958      	ldr	r0, [r3, #20]
    cc44:	1b00      	subs	r0, r0, r4
            rt = c->c_ticks - now;
        } else {
            rt = 0;     /* callout time is in the past */
    cc46:	43c3      	mvns	r3, r0
    cc48:	17db      	asrs	r3, r3, #31
    cc4a:	4018      	ands	r0, r3
    } else {
        rt = OS_TIMEOUT_NEVER;
    }

    return (rt);
}
    cc4c:	bd10      	pop	{r4, pc}
        rt = OS_TIMEOUT_NEVER;
    cc4e:	2001      	movs	r0, #1
    cc50:	4240      	negs	r0, r0
    cc52:	e7fb      	b.n	cc4c <os_callout_wakeup_ticks+0x28>
    cc54:	200024a0 	.word	0x200024a0

0000cc58 <os_dev_initialize>:
 *
 * @return 0 on success, non-zero on failure.
 */
static int
os_dev_initialize(struct os_dev *dev)
{
    cc58:	b510      	push	{r4, lr}
    int rc;

    rc = dev->od_init(dev, dev->od_init_arg);
    cc5a:	6903      	ldr	r3, [r0, #16]
    cc5c:	6941      	ldr	r1, [r0, #20]
{
    cc5e:	0004      	movs	r4, r0
    rc = dev->od_init(dev, dev->od_init_arg);
    cc60:	4798      	blx	r3
    cc62:	7ee3      	ldrb	r3, [r4, #27]
    if (rc != 0) {
    cc64:	2800      	cmp	r0, #0
    cc66:	d003      	beq.n	cc70 <os_dev_initialize+0x18>
        if (dev->od_flags & OS_DEV_F_INIT_CRITICAL) {
    cc68:	071b      	lsls	r3, r3, #28
            goto err;
        }
    } else {
        dev->od_flags |= OS_DEV_F_STATUS_READY;
    }
    return 0;
    cc6a:	17db      	asrs	r3, r3, #31
    cc6c:	4018      	ands	r0, r3
err:
    return rc;
}
    cc6e:	bd10      	pop	{r4, pc}
        dev->od_flags |= OS_DEV_F_STATUS_READY;
    cc70:	2201      	movs	r2, #1
    cc72:	4313      	orrs	r3, r2
    cc74:	76e3      	strb	r3, [r4, #27]
    cc76:	e7fa      	b.n	cc6e <os_dev_initialize+0x16>

0000cc78 <os_dev_create>:
 * @return 0 on success, non-zero on failure.
 */
int
os_dev_create(struct os_dev *dev, char *name, uint8_t stage,
        uint8_t priority, os_dev_init_func_t od_init, void *arg)
{
    cc78:	b570      	push	{r4, r5, r6, lr}
    cc7a:	0004      	movs	r4, r0
    dev->od_name = name;
    cc7c:	61c1      	str	r1, [r0, #28]
    dev->od_open_ref = 0;
    cc7e:	2100      	movs	r1, #0
    dev->od_priority = priority;
    cc80:	7663      	strb	r3, [r4, #25]
{
    cc82:	001e      	movs	r6, r3
    dev->od_init = od_init;
    cc84:	9b04      	ldr	r3, [sp, #16]
    dev->od_stage = stage;
    cc86:	7622      	strb	r2, [r4, #24]
    dev->od_init = od_init;
    cc88:	6103      	str	r3, [r0, #16]
    dev->od_init_arg = arg;
    cc8a:	9b05      	ldr	r3, [sp, #20]
{
    cc8c:	0015      	movs	r5, r2
    dev->od_init_arg = arg;
    cc8e:	6143      	str	r3, [r0, #20]
    memset(&dev->od_handlers, 0, sizeof(dev->od_handlers));
    cc90:	2210      	movs	r2, #16
    dev->od_open_ref = 0;
    cc92:	8341      	strh	r1, [r0, #26]
    memset(&dev->od_handlers, 0, sizeof(dev->od_handlers));
    cc94:	f000 fe0c 	bl	d8b0 <memset>
    if (STAILQ_FIRST(&g_os_dev_list) == NULL) {
    cc98:	4a14      	ldr	r2, [pc, #80]	; (ccec <os_dev_create+0x74>)
    cc9a:	6813      	ldr	r3, [r2, #0]
    cc9c:	2b00      	cmp	r3, #0
    cc9e:	d10c      	bne.n	ccba <os_dev_create+0x42>
        STAILQ_INSERT_HEAD(&g_os_dev_list, dev, od_next);
    cca0:	6223      	str	r3, [r4, #32]
    cca2:	0023      	movs	r3, r4
    cca4:	3320      	adds	r3, #32
    cca6:	6053      	str	r3, [r2, #4]
    cca8:	6014      	str	r4, [r2, #0]
    rc = os_dev_add(dev);
    if (rc != 0) {
        goto err;
    }

    if (g_os_started) {
    ccaa:	4b11      	ldr	r3, [pc, #68]	; (ccf0 <os_dev_create+0x78>)
    ccac:	6818      	ldr	r0, [r3, #0]
    ccae:	2800      	cmp	r0, #0
    ccb0:	d002      	beq.n	ccb8 <os_dev_create+0x40>
        rc = os_dev_initialize(dev);
    ccb2:	0020      	movs	r0, r4
    ccb4:	f7ff ffd0 	bl	cc58 <os_dev_initialize>
    }
err:
    return (rc);
}
    ccb8:	bd70      	pop	{r4, r5, r6, pc}
        if (cur_dev->od_stage > dev->od_stage) {
    ccba:	7e18      	ldrb	r0, [r3, #24]
    ccbc:	6a19      	ldr	r1, [r3, #32]
    ccbe:	42a8      	cmp	r0, r5
    ccc0:	d802      	bhi.n	ccc8 <os_dev_create+0x50>
        if (dev->od_priority >= cur_dev->od_priority) {
    ccc2:	7e58      	ldrb	r0, [r3, #25]
    ccc4:	42b0      	cmp	r0, r6
    ccc6:	d908      	bls.n	ccda <os_dev_create+0x62>
    STAILQ_FOREACH(cur_dev, &g_os_dev_list, od_next) {
    ccc8:	1e0b      	subs	r3, r1, #0
    ccca:	d1f6      	bne.n	ccba <os_dev_create+0x42>
        STAILQ_INSERT_TAIL(&g_os_dev_list, dev, od_next);
    cccc:	6853      	ldr	r3, [r2, #4]
    ccce:	6221      	str	r1, [r4, #32]
    ccd0:	601c      	str	r4, [r3, #0]
    ccd2:	0023      	movs	r3, r4
    ccd4:	3320      	adds	r3, #32
    ccd6:	6053      	str	r3, [r2, #4]
    ccd8:	e7e7      	b.n	ccaa <os_dev_create+0x32>
        STAILQ_INSERT_AFTER(&g_os_dev_list, cur_dev, dev, od_next);
    ccda:	6221      	str	r1, [r4, #32]
    ccdc:	2900      	cmp	r1, #0
    ccde:	d102      	bne.n	cce6 <os_dev_create+0x6e>
    cce0:	0021      	movs	r1, r4
    cce2:	3120      	adds	r1, #32
    cce4:	6051      	str	r1, [r2, #4]
    cce6:	621c      	str	r4, [r3, #32]
    cce8:	e7df      	b.n	ccaa <os_dev_create+0x32>
    ccea:	46c0      	nop			; (mov r8, r8)
    ccec:	2000119c 	.word	0x2000119c
    ccf0:	2000249c 	.word	0x2000249c

0000ccf4 <os_dev_initialize_all>:
 *
 * @return 0 on success, non-zero on failure.
 */
int
os_dev_initialize_all(uint8_t stage)
{
    ccf4:	b570      	push	{r4, r5, r6, lr}
    ccf6:	0005      	movs	r5, r0
    struct os_dev *dev;
    int rc = 0;

    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    ccf8:	4b08      	ldr	r3, [pc, #32]	; (cd1c <os_dev_initialize_all+0x28>)
    ccfa:	681c      	ldr	r4, [r3, #0]
    ccfc:	2c00      	cmp	r4, #0
    ccfe:	d101      	bne.n	cd04 <os_dev_initialize_all+0x10>
    cd00:	0020      	movs	r0, r4
                break;
            }
        }
    }

    return (rc);
    cd02:	e009      	b.n	cd18 <os_dev_initialize_all+0x24>
        if (dev->od_stage == stage) {
    cd04:	7e23      	ldrb	r3, [r4, #24]
    cd06:	42ab      	cmp	r3, r5
    cd08:	d001      	beq.n	cd0e <os_dev_initialize_all+0x1a>
    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    cd0a:	6a24      	ldr	r4, [r4, #32]
    cd0c:	e7f6      	b.n	ccfc <os_dev_initialize_all+0x8>
            rc = os_dev_initialize(dev);
    cd0e:	0020      	movs	r0, r4
    cd10:	f7ff ffa2 	bl	cc58 <os_dev_initialize>
            if (rc) {
    cd14:	2800      	cmp	r0, #0
    cd16:	d0f8      	beq.n	cd0a <os_dev_initialize_all+0x16>
}
    cd18:	bd70      	pop	{r4, r5, r6, pc}
    cd1a:	46c0      	nop			; (mov r8, r8)
    cd1c:	2000119c 	.word	0x2000119c

0000cd20 <os_dev_lookup>:
 *
 * @return A pointer to the device corresponding to name, or NULL if not found.
 */
struct os_dev *
os_dev_lookup(char *name)
{
    cd20:	b570      	push	{r4, r5, r6, lr}
    cd22:	0005      	movs	r5, r0
    struct os_dev *dev;

    dev = NULL;
    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    cd24:	4b06      	ldr	r3, [pc, #24]	; (cd40 <os_dev_lookup+0x20>)
    cd26:	681c      	ldr	r4, [r3, #0]
    cd28:	2c00      	cmp	r4, #0
    cd2a:	d101      	bne.n	cd30 <os_dev_lookup+0x10>
        if (!strcmp(dev->od_name, name)) {
            break;
        }
    }
    return (dev);
}
    cd2c:	0020      	movs	r0, r4
    cd2e:	bd70      	pop	{r4, r5, r6, pc}
        if (!strcmp(dev->od_name, name)) {
    cd30:	0029      	movs	r1, r5
    cd32:	69e0      	ldr	r0, [r4, #28]
    cd34:	f000 fdc4 	bl	d8c0 <strcmp>
    cd38:	2800      	cmp	r0, #0
    cd3a:	d0f7      	beq.n	cd2c <os_dev_lookup+0xc>
    STAILQ_FOREACH(dev, &g_os_dev_list, od_next) {
    cd3c:	6a24      	ldr	r4, [r4, #32]
    cd3e:	e7f3      	b.n	cd28 <os_dev_lookup+0x8>
    cd40:	2000119c 	.word	0x2000119c

0000cd44 <os_dev_open>:
 *
 * @return 0 on success, non-zero on failure.
 */
struct os_dev *
os_dev_open(char *devname, uint32_t timo, void *arg)
{
    cd44:	b570      	push	{r4, r5, r6, lr}
    cd46:	000d      	movs	r5, r1
    cd48:	0016      	movs	r6, r2
    struct os_dev *dev;
    os_sr_t sr;
    int rc;

    dev = os_dev_lookup(devname);
    cd4a:	f7ff ffe9 	bl	cd20 <os_dev_lookup>
    cd4e:	1e04      	subs	r4, r0, #0
    if (dev == NULL) {
    cd50:	d102      	bne.n	cd58 <os_dev_open+0x14>
        return (NULL);
    cd52:	2400      	movs	r4, #0
    OS_EXIT_CRITICAL(sr);

    return (dev);
err:
    return (NULL);
}
    cd54:	0020      	movs	r0, r4
    cd56:	bd70      	pop	{r4, r5, r6, pc}
    if ((dev->od_flags & OS_DEV_F_STATUS_READY) == 0) {
    cd58:	7ec3      	ldrb	r3, [r0, #27]
    cd5a:	07db      	lsls	r3, r3, #31
    cd5c:	d5f9      	bpl.n	cd52 <os_dev_open+0xe>
    if (dev->od_handlers.od_open) {
    cd5e:	6803      	ldr	r3, [r0, #0]
    cd60:	2b00      	cmp	r3, #0
    cd62:	d10b      	bne.n	cd7c <os_dev_open+0x38>
    OS_ENTER_CRITICAL(sr);
    cd64:	f000 fb14 	bl	d390 <os_arch_save_sr>
    ++dev->od_open_ref;
    cd68:	7ea3      	ldrb	r3, [r4, #26]
    dev->od_flags |= OS_DEV_F_STATUS_OPEN;
    cd6a:	7ee2      	ldrb	r2, [r4, #27]
    ++dev->od_open_ref;
    cd6c:	3301      	adds	r3, #1
    cd6e:	76a3      	strb	r3, [r4, #26]
    dev->od_flags |= OS_DEV_F_STATUS_OPEN;
    cd70:	2302      	movs	r3, #2
    cd72:	4313      	orrs	r3, r2
    cd74:	76e3      	strb	r3, [r4, #27]
    OS_EXIT_CRITICAL(sr);
    cd76:	f000 fb11 	bl	d39c <os_arch_restore_sr>
    return (dev);
    cd7a:	e7eb      	b.n	cd54 <os_dev_open+0x10>
        rc = dev->od_handlers.od_open(dev, timo, arg);
    cd7c:	0032      	movs	r2, r6
    cd7e:	0029      	movs	r1, r5
    cd80:	4798      	blx	r3
        if (rc != 0) {
    cd82:	2800      	cmp	r0, #0
    cd84:	d0ee      	beq.n	cd64 <os_dev_open+0x20>
    cd86:	e7e4      	b.n	cd52 <os_dev_open+0xe>

0000cd88 <os_dev_reset>:
 * tests.
 */
void
os_dev_reset(void)
{
    STAILQ_INIT(&g_os_dev_list);
    cd88:	2200      	movs	r2, #0
    cd8a:	4b02      	ldr	r3, [pc, #8]	; (cd94 <os_dev_reset+0xc>)
    cd8c:	601a      	str	r2, [r3, #0]
    cd8e:	605b      	str	r3, [r3, #4]
}
    cd90:	4770      	bx	lr
    cd92:	46c0      	nop			; (mov r8, r8)
    cd94:	2000119c 	.word	0x2000119c

0000cd98 <os_eventq_init>:
 *
 * @param evq The event queue to initialize
 */
void
os_eventq_init(struct os_eventq *evq)
{
    cd98:	b510      	push	{r4, lr}
    memset(evq, 0, sizeof(*evq));
    cd9a:	2208      	movs	r2, #8
    cd9c:	2100      	movs	r1, #0
{
    cd9e:	0004      	movs	r4, r0
    memset(evq, 0, sizeof(*evq));
    cda0:	f000 fd86 	bl	d8b0 <memset>
    STAILQ_INIT(&evq->evq_list);
    cda4:	2300      	movs	r3, #0
    cda6:	60a3      	str	r3, [r4, #8]
    cda8:	0023      	movs	r3, r4
    cdaa:	3308      	adds	r3, #8
    cdac:	60e3      	str	r3, [r4, #12]
}
    cdae:	bd10      	pop	{r4, pc}

0000cdb0 <os_eventq_put>:
 * @param evq The event queue to put an event on
 * @param ev The event to put on the queue
 */
void
os_eventq_put(struct os_eventq *evq, struct os_event *ev)
{
    cdb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    cdb2:	000d      	movs	r5, r1
    cdb4:	0004      	movs	r4, r0
    int resched;
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    cdb6:	f000 faeb 	bl	d390 <os_arch_save_sr>

    /* Do not queue if already queued */
    if (OS_EVENT_QUEUED(ev)) {
    cdba:	782b      	ldrb	r3, [r5, #0]
    OS_ENTER_CRITICAL(sr);
    cdbc:	0006      	movs	r6, r0
    if (OS_EVENT_QUEUED(ev)) {
    cdbe:	2b00      	cmp	r3, #0
    cdc0:	d002      	beq.n	cdc8 <os_eventq_put+0x18>
        OS_EXIT_CRITICAL(sr);
    cdc2:	f000 faeb 	bl	d39c <os_arch_restore_sr>
    OS_EXIT_CRITICAL(sr);

    if (resched) {
        os_sched(NULL);
    }
}
    cdc6:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    ev->ev_queued = 1;
    cdc8:	2701      	movs	r7, #1
    cdca:	702f      	strb	r7, [r5, #0]
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);
    cdcc:	68e2      	ldr	r2, [r4, #12]
    if (evq->evq_task) {
    cdce:	6860      	ldr	r0, [r4, #4]
    STAILQ_INSERT_TAIL(&evq->evq_list, ev, ev_next);
    cdd0:	60eb      	str	r3, [r5, #12]
    cdd2:	6015      	str	r5, [r2, #0]
    cdd4:	350c      	adds	r5, #12
    cdd6:	60e5      	str	r5, [r4, #12]
    cdd8:	9301      	str	r3, [sp, #4]
    resched = 0;
    cdda:	1e05      	subs	r5, r0, #0
    if (evq->evq_task) {
    cddc:	d008      	beq.n	cdf0 <os_eventq_put+0x40>
        if (evq->evq_task->t_state == OS_TASK_SLEEP) {
    cdde:	7b03      	ldrb	r3, [r0, #12]
    resched = 0;
    cde0:	9d01      	ldr	r5, [sp, #4]
        if (evq->evq_task->t_state == OS_TASK_SLEEP) {
    cde2:	2b02      	cmp	r3, #2
    cde4:	d102      	bne.n	cdec <os_eventq_put+0x3c>
            os_sched_wakeup(evq->evq_task);
    cde6:	f000 f951 	bl	d08c <os_sched_wakeup>
            resched = 1;
    cdea:	003d      	movs	r5, r7
        evq->evq_task = NULL;
    cdec:	9b01      	ldr	r3, [sp, #4]
    cdee:	6063      	str	r3, [r4, #4]
    OS_EXIT_CRITICAL(sr);
    cdf0:	0030      	movs	r0, r6
    cdf2:	f000 fad3 	bl	d39c <os_arch_restore_sr>
    if (resched) {
    cdf6:	2d00      	cmp	r5, #0
    cdf8:	d0e5      	beq.n	cdc6 <os_eventq_put+0x16>
        os_sched(NULL);
    cdfa:	2000      	movs	r0, #0
    cdfc:	f000 f8f8 	bl	cff0 <os_sched>
    ce00:	e7e1      	b.n	cdc6 <os_eventq_put+0x16>

0000ce02 <os_eventq_get_no_wait>:
struct os_event *
os_eventq_get_no_wait(struct os_eventq *evq)
{
    struct os_event *ev;

    ev = STAILQ_FIRST(&evq->evq_list);
    ce02:	6883      	ldr	r3, [r0, #8]
    if (ev) {
    ce04:	2b00      	cmp	r3, #0
    ce06:	d008      	beq.n	ce1a <os_eventq_get_no_wait+0x18>
        STAILQ_REMOVE(&evq->evq_list, ev, os_event, ev_next);
    ce08:	68da      	ldr	r2, [r3, #12]
    ce0a:	6082      	str	r2, [r0, #8]
    ce0c:	2a00      	cmp	r2, #0
    ce0e:	d102      	bne.n	ce16 <os_eventq_get_no_wait+0x14>
    ce10:	0002      	movs	r2, r0
    ce12:	3208      	adds	r2, #8
    ce14:	60c2      	str	r2, [r0, #12]
        ev->ev_queued = 0;
    ce16:	2200      	movs	r2, #0
    ce18:	701a      	strb	r2, [r3, #0]
    }

    return ev;
}
    ce1a:	0018      	movs	r0, r3
    ce1c:	4770      	bx	lr
	...

0000ce20 <os_eventq_dflt_get>:
 */
struct os_eventq *
os_eventq_dflt_get(void)
{
    return &os_eventq_main;
}
    ce20:	4800      	ldr	r0, [pc, #0]	; (ce24 <os_eventq_dflt_get+0x4>)
    ce22:	4770      	bx	lr
    ce24:	200011a4 	.word	0x200011a4

0000ce28 <os_msys_init>:
    SYSINIT_PANIC_ASSERT(rc == 0);
}

void
os_msys_init(void)
{
    ce28:	b537      	push	{r0, r1, r2, r4, r5, lr}
    os_msys_reset();
    ce2a:	f000 fba5 	bl	d578 <os_msys_reset>
    rc = mem_init_mbuf_pool(data, mempool, mbuf_pool, block_count, block_size,
    ce2e:	4b12      	ldr	r3, [pc, #72]	; (ce78 <os_msys_init+0x50>)
    ce30:	4c12      	ldr	r4, [pc, #72]	; (ce7c <os_msys_init+0x54>)
    ce32:	9301      	str	r3, [sp, #4]
    ce34:	2392      	movs	r3, #146	; 0x92
    ce36:	005b      	lsls	r3, r3, #1
    ce38:	9300      	str	r3, [sp, #0]
    ce3a:	3b19      	subs	r3, #25
    ce3c:	3bff      	subs	r3, #255	; 0xff
    ce3e:	0022      	movs	r2, r4
    ce40:	490f      	ldr	r1, [pc, #60]	; (ce80 <os_msys_init+0x58>)
    ce42:	4810      	ldr	r0, [pc, #64]	; (ce84 <os_msys_init+0x5c>)
    ce44:	f001 f8e0 	bl	e008 <mem_init_mbuf_pool>
    SYSINIT_PANIC_ASSERT(rc == 0);
    ce48:	2800      	cmp	r0, #0
    ce4a:	d007      	beq.n	ce5c <os_msys_init+0x34>
    ce4c:	2000      	movs	r0, #0
    ce4e:	4b0e      	ldr	r3, [pc, #56]	; (ce88 <os_msys_init+0x60>)
    ce50:	9000      	str	r0, [sp, #0]
    ce52:	681d      	ldr	r5, [r3, #0]
    ce54:	0002      	movs	r2, r0
    ce56:	0003      	movs	r3, r0
    ce58:	0001      	movs	r1, r0
    ce5a:	47a8      	blx	r5
    rc = os_msys_register(mbuf_pool);
    ce5c:	0020      	movs	r0, r4
    ce5e:	f000 fb6d 	bl	d53c <os_msys_register>
    SYSINIT_PANIC_ASSERT(rc == 0);
    ce62:	2800      	cmp	r0, #0
    ce64:	d007      	beq.n	ce76 <os_msys_init+0x4e>
    ce66:	2000      	movs	r0, #0
    ce68:	4b07      	ldr	r3, [pc, #28]	; (ce88 <os_msys_init+0x60>)
    ce6a:	9000      	str	r0, [sp, #0]
    ce6c:	681c      	ldr	r4, [r3, #0]
    ce6e:	0002      	movs	r2, r0
    ce70:	0003      	movs	r3, r0
    ce72:	0001      	movs	r1, r0
    ce74:	47a0      	blx	r4
                      &os_msys_init_5_mbuf_pool,
                      MYNEWT_VAL(MSYS_5_BLOCK_COUNT),
                      SYSINIT_MSYS_5_MEMBLOCK_SIZE,
                      "msys_5");
#endif
}
    ce76:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
    ce78:	00010900 	.word	0x00010900
    ce7c:	20001f64 	.word	0x20001f64
    ce80:	20001f70 	.word	0x20001f70
    ce84:	200011b4 	.word	0x200011b4
    ce88:	200000e0 	.word	0x200000e0

0000ce8c <os_sanity_check_list_lock>:
static int
os_sanity_check_list_lock(void)
{
    int rc;

    if (!g_os_started) {
    ce8c:	4b05      	ldr	r3, [pc, #20]	; (cea4 <os_sanity_check_list_lock+0x18>)
{
    ce8e:	b510      	push	{r4, lr}
    if (!g_os_started) {
    ce90:	6818      	ldr	r0, [r3, #0]
    ce92:	2800      	cmp	r0, #0
    ce94:	d004      	beq.n	cea0 <os_sanity_check_list_lock+0x14>
        return (0);
    }

    rc = os_mutex_pend(&g_os_sanity_check_mu, OS_WAIT_FOREVER);
    ce96:	2101      	movs	r1, #1
    ce98:	4803      	ldr	r0, [pc, #12]	; (cea8 <os_sanity_check_list_lock+0x1c>)
    ce9a:	4249      	negs	r1, r1
    ce9c:	f000 fc16 	bl	d6cc <os_mutex_pend>
    }

    return (0);
err:
    return (rc);
}
    cea0:	bd10      	pop	{r4, pc}
    cea2:	46c0      	nop			; (mov r8, r8)
    cea4:	2000249c 	.word	0x2000249c
    cea8:	200024a8 	.word	0x200024a8

0000ceac <os_sanity_check_list_unlock>:
static int
os_sanity_check_list_unlock(void)
{
    int rc;

    if (!g_os_started) {
    ceac:	4b04      	ldr	r3, [pc, #16]	; (cec0 <os_sanity_check_list_unlock+0x14>)
{
    ceae:	b510      	push	{r4, lr}
    if (!g_os_started) {
    ceb0:	6818      	ldr	r0, [r3, #0]
    ceb2:	2800      	cmp	r0, #0
    ceb4:	d002      	beq.n	cebc <os_sanity_check_list_unlock+0x10>
        return (0);
    }

    rc = os_mutex_release(&g_os_sanity_check_mu);
    ceb6:	4803      	ldr	r0, [pc, #12]	; (cec4 <os_sanity_check_list_unlock+0x18>)
    ceb8:	f000 fbaa 	bl	d610 <os_mutex_release>
    }

    return (0);
err:
    return (rc);
}
    cebc:	bd10      	pop	{r4, pc}
    cebe:	46c0      	nop			; (mov r8, r8)
    cec0:	2000249c 	.word	0x2000249c
    cec4:	200024a8 	.word	0x200024a8

0000cec8 <os_sanity_check_init>:
{
    cec8:	b510      	push	{r4, lr}
    memset(sc, 0, sizeof(*sc));
    ceca:	2214      	movs	r2, #20
    cecc:	2100      	movs	r1, #0
    cece:	f000 fcef 	bl	d8b0 <memset>
}
    ced2:	2000      	movs	r0, #0
    ced4:	bd10      	pop	{r4, pc}
	...

0000ced8 <os_sanity_check_register>:
 *
 * @return 0 on success, error code on failure
 */
int
os_sanity_check_register(struct os_sanity_check *sc)
{
    ced8:	b510      	push	{r4, lr}
    ceda:	0004      	movs	r4, r0
    int rc;

    rc = os_sanity_check_list_lock();
    cedc:	f7ff ffd6 	bl	ce8c <os_sanity_check_list_lock>
    if (rc != OS_OK) {
    cee0:	2800      	cmp	r0, #0
    cee2:	d105      	bne.n	cef0 <os_sanity_check_register+0x18>
        goto err;
    }

    SLIST_INSERT_HEAD(&g_os_sanity_check_list, sc, sc_next);
    cee4:	4b03      	ldr	r3, [pc, #12]	; (cef4 <os_sanity_check_register+0x1c>)
    cee6:	681a      	ldr	r2, [r3, #0]
    cee8:	601c      	str	r4, [r3, #0]
    ceea:	6122      	str	r2, [r4, #16]

    rc = os_sanity_check_list_unlock();
    ceec:	f7ff ffde 	bl	ceac <os_sanity_check_list_unlock>
    }

    return (0);
err:
    return (rc);
}
    cef0:	bd10      	pop	{r4, pc}
    cef2:	46c0      	nop			; (mov r8, r8)
    cef4:	20001f90 	.word	0x20001f90

0000cef8 <os_sanity_run>:
 * Goes through the sanity check list, and performs sanity checks.  If any of
 * these checks failed, or tasks have not checked in, it resets the processor.
 */
void
os_sanity_run(void)
{
    cef8:	b510      	push	{r4, lr}
    struct os_sanity_check *sc;
    int rc;

    rc = os_sanity_check_list_lock();
    cefa:	f7ff ffc7 	bl	ce8c <os_sanity_check_list_lock>
    if (rc != 0) {
    cefe:	2800      	cmp	r0, #0
    cf00:	d005      	beq.n	cf0e <os_sanity_run+0x16>
        assert(0);
    cf02:	2300      	movs	r3, #0
    cf04:	001a      	movs	r2, r3
    cf06:	0019      	movs	r1, r3
    cf08:	0018      	movs	r0, r3
    cf0a:	f7ff fd15 	bl	c938 <__assert_func>
    }

    SLIST_FOREACH(sc, &g_os_sanity_check_list, sc_next) {
    cf0e:	4b0f      	ldr	r3, [pc, #60]	; (cf4c <os_sanity_run+0x54>)
    cf10:	681c      	ldr	r4, [r3, #0]
    cf12:	2c00      	cmp	r4, #0
    cf14:	d104      	bne.n	cf20 <os_sanity_run+0x28>
                    sc->sc_checkin_last + sc->sc_checkin_itvl)) {
            assert(0);
        }
    }

    rc = os_sanity_check_list_unlock();
    cf16:	f7ff ffc9 	bl	ceac <os_sanity_check_list_unlock>
    if (rc != 0) {
    cf1a:	2800      	cmp	r0, #0
    cf1c:	d1f1      	bne.n	cf02 <os_sanity_run+0xa>
        assert(0);
    }
}
    cf1e:	bd10      	pop	{r4, pc}
        if (sc->sc_func) {
    cf20:	68a3      	ldr	r3, [r4, #8]
    cf22:	2b00      	cmp	r3, #0
    cf24:	d009      	beq.n	cf3a <os_sanity_run+0x42>
            rc = sc->sc_func(sc, sc->sc_arg);
    cf26:	68e1      	ldr	r1, [r4, #12]
    cf28:	0020      	movs	r0, r4
    cf2a:	4798      	blx	r3
            if (rc == OS_OK) {
    cf2c:	2800      	cmp	r0, #0
    cf2e:	d104      	bne.n	cf3a <os_sanity_run+0x42>
                sc->sc_checkin_last = os_time_get();
    cf30:	f000 f9ca 	bl	d2c8 <os_time_get>
    cf34:	6020      	str	r0, [r4, #0]
    SLIST_FOREACH(sc, &g_os_sanity_check_list, sc_next) {
    cf36:	6924      	ldr	r4, [r4, #16]
    cf38:	e7eb      	b.n	cf12 <os_sanity_run+0x1a>
        if (OS_TIME_TICK_GT(os_time_get(),
    cf3a:	f000 f9c5 	bl	d2c8 <os_time_get>
    cf3e:	6823      	ldr	r3, [r4, #0]
    cf40:	6862      	ldr	r2, [r4, #4]
    cf42:	189b      	adds	r3, r3, r2
    cf44:	1ac0      	subs	r0, r0, r3
    cf46:	2800      	cmp	r0, #0
    cf48:	ddf5      	ble.n	cf36 <os_sanity_run+0x3e>
    cf4a:	e7da      	b.n	cf02 <os_sanity_run+0xa>
    cf4c:	20001f90 	.word	0x20001f90

0000cf50 <os_sanity_init>:
 *
 * @return 0 on success, error code on failure
 */
int
os_sanity_init(void)
{
    cf50:	b510      	push	{r4, lr}
    int rc;

    rc = os_mutex_init(&g_os_sanity_check_mu);
    cf52:	4802      	ldr	r0, [pc, #8]	; (cf5c <os_sanity_init+0xc>)
    cf54:	f000 fb52 	bl	d5fc <os_mutex_init>
    }

    return (0);
err:
    return (rc);
}
    cf58:	bd10      	pop	{r4, pc}
    cf5a:	46c0      	nop			; (mov r8, r8)
    cf5c:	200024a8 	.word	0x200024a8

0000cf60 <os_sched_insert>:
 * @return int  OS_OK: task was inserted into run list
 *              OS_EINVAL: Task was not in ready state.
 */
os_error_t
os_sched_insert(struct os_task *t)
{
    cf60:	b570      	push	{r4, r5, r6, lr}
    struct os_task *entry;
    os_sr_t sr;
    os_error_t rc;

    if (t->t_state != OS_TASK_READY) {
    cf62:	7b03      	ldrb	r3, [r0, #12]
{
    cf64:	0004      	movs	r4, r0
    }
    OS_EXIT_CRITICAL(sr);

    return (0);
err:
    return (rc);
    cf66:	2002      	movs	r0, #2
    if (t->t_state != OS_TASK_READY) {
    cf68:	2b01      	cmp	r3, #1
    cf6a:	d11c      	bne.n	cfa6 <os_sched_insert+0x46>
    OS_ENTER_CRITICAL(sr);
    cf6c:	f000 fa10 	bl	d390 <os_arch_save_sr>
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    cf70:	4a0d      	ldr	r2, [pc, #52]	; (cfa8 <os_sched_insert+0x48>)
    cf72:	6813      	ldr	r3, [r2, #0]
    cf74:	2b00      	cmp	r3, #0
    cf76:	d106      	bne.n	cf86 <os_sched_insert+0x26>
        TAILQ_INSERT_TAIL(&g_os_run_list, (struct os_task *) t, t_os_list);
    cf78:	6463      	str	r3, [r4, #68]	; 0x44
    cf7a:	6853      	ldr	r3, [r2, #4]
    cf7c:	64a3      	str	r3, [r4, #72]	; 0x48
    cf7e:	601c      	str	r4, [r3, #0]
    cf80:	3444      	adds	r4, #68	; 0x44
    cf82:	6054      	str	r4, [r2, #4]
    cf84:	e00c      	b.n	cfa0 <os_sched_insert+0x40>
        if (t->t_prio < entry->t_prio) {
    cf86:	7ae5      	ldrb	r5, [r4, #11]
    cf88:	7ad9      	ldrb	r1, [r3, #11]
    cf8a:	428d      	cmp	r5, r1
    cf8c:	d301      	bcc.n	cf92 <os_sched_insert+0x32>
    TAILQ_FOREACH(entry, &g_os_run_list, t_os_list) {
    cf8e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    cf90:	e7f0      	b.n	cf74 <os_sched_insert+0x14>
        TAILQ_INSERT_BEFORE(entry, (struct os_task *) t, t_os_list);
    cf92:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    cf94:	6463      	str	r3, [r4, #68]	; 0x44
    cf96:	64a2      	str	r2, [r4, #72]	; 0x48
    cf98:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    cf9a:	6014      	str	r4, [r2, #0]
    cf9c:	3444      	adds	r4, #68	; 0x44
    cf9e:	649c      	str	r4, [r3, #72]	; 0x48
    OS_EXIT_CRITICAL(sr);
    cfa0:	f000 f9fc 	bl	d39c <os_arch_restore_sr>
    cfa4:	2000      	movs	r0, #0
}
    cfa6:	bd70      	pop	{r4, r5, r6, pc}
    cfa8:	200000b8 	.word	0x200000b8

0000cfac <os_sched_ctx_sw_hook>:

void
os_sched_ctx_sw_hook(struct os_task *next_t)
{
    os_trace_task_start_exec(next_t->t_taskid);
    next_t->t_ctx_sw_cnt++;
    cfac:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
    cfae:	b510      	push	{r4, lr}
    next_t->t_ctx_sw_cnt++;
    cfb0:	3301      	adds	r3, #1
    cfb2:	63c3      	str	r3, [r0, #60]	; 0x3c
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    cfb4:	4b05      	ldr	r3, [pc, #20]	; (cfcc <os_sched_ctx_sw_hook+0x20>)
    cfb6:	4a06      	ldr	r2, [pc, #24]	; (cfd0 <os_sched_ctx_sw_hook+0x24>)
    cfb8:	6818      	ldr	r0, [r3, #0]
    cfba:	4b06      	ldr	r3, [pc, #24]	; (cfd4 <os_sched_ctx_sw_hook+0x28>)
    cfbc:	6814      	ldr	r4, [r2, #0]
    cfbe:	6819      	ldr	r1, [r3, #0]
    cfc0:	6b83      	ldr	r3, [r0, #56]	; 0x38
    g_os_last_ctx_sw_time = g_os_time;
    cfc2:	6011      	str	r1, [r2, #0]
    g_current_task->t_run_time += g_os_time - g_os_last_ctx_sw_time;
    cfc4:	1b1b      	subs	r3, r3, r4
    cfc6:	185b      	adds	r3, r3, r1
    cfc8:	6383      	str	r3, [r0, #56]	; 0x38
}
    cfca:	bd10      	pop	{r4, pc}
    cfcc:	200024b4 	.word	0x200024b4
    cfd0:	200024b8 	.word	0x200024b8
    cfd4:	200024c8 	.word	0x200024c8

0000cfd8 <os_sched_get_current_task>:
 * @return struct os_task*
 */
struct os_task *
os_sched_get_current_task(void)
{
    return (g_current_task);
    cfd8:	4b01      	ldr	r3, [pc, #4]	; (cfe0 <os_sched_get_current_task+0x8>)
    cfda:	6818      	ldr	r0, [r3, #0]
}
    cfdc:	4770      	bx	lr
    cfde:	46c0      	nop			; (mov r8, r8)
    cfe0:	200024b4 	.word	0x200024b4

0000cfe4 <os_sched_set_current_task>:
 * @param t Pointer to currently running task.
 */
void
os_sched_set_current_task(struct os_task *t)
{
    g_current_task = t;
    cfe4:	4b01      	ldr	r3, [pc, #4]	; (cfec <os_sched_set_current_task+0x8>)
    cfe6:	6018      	str	r0, [r3, #0]
}
    cfe8:	4770      	bx	lr
    cfea:	46c0      	nop			; (mov r8, r8)
    cfec:	200024b4 	.word	0x200024b4

0000cff0 <os_sched>:
 *
 * @param next_t Task to run
 */
void
os_sched(struct os_task *next_t)
{
    cff0:	b570      	push	{r4, r5, r6, lr}
    cff2:	0004      	movs	r4, r0
    os_sr_t sr;

    OS_ENTER_CRITICAL(sr);
    cff4:	f000 f9cc 	bl	d390 <os_arch_save_sr>
    cff8:	0005      	movs	r5, r0

    if (!next_t) {
    cffa:	2c00      	cmp	r4, #0
    cffc:	d101      	bne.n	d002 <os_sched+0x12>
 * @return struct os_task*
 */
struct os_task *
os_sched_next_task(void)
{
    return (TAILQ_FIRST(&g_os_run_list));
    cffe:	4b04      	ldr	r3, [pc, #16]	; (d010 <os_sched+0x20>)
    d000:	681c      	ldr	r4, [r3, #0]
    os_arch_ctx_sw(next_t);
    d002:	0020      	movs	r0, r4
    d004:	f000 f9ba 	bl	d37c <os_arch_ctx_sw>
    OS_EXIT_CRITICAL(sr);
    d008:	0028      	movs	r0, r5
    d00a:	f000 f9c7 	bl	d39c <os_arch_restore_sr>
}
    d00e:	bd70      	pop	{r4, r5, r6, pc}
    d010:	200000b8 	.word	0x200000b8

0000d014 <os_sched_sleep>:
    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d014:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
    d016:	b570      	push	{r4, r5, r6, lr}
    d018:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d01a:	0004      	movs	r4, r0
    d01c:	000d      	movs	r5, r1
    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d01e:	2b00      	cmp	r3, #0
    d020:	d019      	beq.n	d056 <os_sched_sleep+0x42>
    d022:	649a      	str	r2, [r3, #72]	; 0x48
    d024:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    d026:	6013      	str	r3, [r2, #0]
    t->t_state = OS_TASK_SLEEP;
    d028:	2302      	movs	r3, #2
    d02a:	7323      	strb	r3, [r4, #12]
    t->t_next_wakeup = os_time_get() + nticks;
    d02c:	f000 f94c 	bl	d2c8 <os_time_get>
    d030:	0021      	movs	r1, r4
    d032:	1940      	adds	r0, r0, r5
    d034:	6360      	str	r0, [r4, #52]	; 0x34
    d036:	3144      	adds	r1, #68	; 0x44
    d038:	4a12      	ldr	r2, [pc, #72]	; (d084 <os_sched_sleep+0x70>)
    if (nticks == OS_TIMEOUT_NEVER) {
    d03a:	1c6b      	adds	r3, r5, #1
    d03c:	d10e      	bne.n	d05c <os_sched_sleep+0x48>
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
    d03e:	2301      	movs	r3, #1
    d040:	7b60      	ldrb	r0, [r4, #13]
    d042:	4303      	orrs	r3, r0
    d044:	7363      	strb	r3, [r4, #13]
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
    d046:	2300      	movs	r3, #0
            TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
    d048:	6463      	str	r3, [r4, #68]	; 0x44
    d04a:	6853      	ldr	r3, [r2, #4]
    d04c:	64a3      	str	r3, [r4, #72]	; 0x48
    d04e:	601c      	str	r4, [r3, #0]
    d050:	6051      	str	r1, [r2, #4]
}
    d052:	2000      	movs	r0, #0
    d054:	bd70      	pop	{r4, r5, r6, pc}
    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d056:	490c      	ldr	r1, [pc, #48]	; (d088 <os_sched_sleep+0x74>)
    d058:	604a      	str	r2, [r1, #4]
    d05a:	e7e3      	b.n	d024 <os_sched_sleep+0x10>
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    d05c:	2601      	movs	r6, #1
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    d05e:	6813      	ldr	r3, [r2, #0]
    d060:	2b00      	cmp	r3, #0
    d062:	d0f1      	beq.n	d048 <os_sched_sleep+0x34>
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    d064:	7b5d      	ldrb	r5, [r3, #13]
    d066:	4235      	tst	r5, r6
    d068:	d105      	bne.n	d076 <os_sched_sleep+0x62>
                    OS_TIME_TICK_GT(entry->t_next_wakeup, t->t_next_wakeup)) {
    d06a:	6b5d      	ldr	r5, [r3, #52]	; 0x34
    d06c:	1a2d      	subs	r5, r5, r0
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
    d06e:	2d00      	cmp	r5, #0
    d070:	dc01      	bgt.n	d076 <os_sched_sleep+0x62>
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
    d072:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    d074:	e7f4      	b.n	d060 <os_sched_sleep+0x4c>
            TAILQ_INSERT_BEFORE(entry, t, t_os_list);
    d076:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    d078:	6463      	str	r3, [r4, #68]	; 0x44
    d07a:	64a2      	str	r2, [r4, #72]	; 0x48
    d07c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    d07e:	6014      	str	r4, [r2, #0]
    d080:	6499      	str	r1, [r3, #72]	; 0x48
    return (0);
    d082:	e7e6      	b.n	d052 <os_sched_sleep+0x3e>
    d084:	200000c0 	.word	0x200000c0
    d088:	200000b8 	.word	0x200000b8

0000d08c <os_sched_wakeup>:
{
    d08c:	b510      	push	{r4, lr}
    assert(t->t_state == OS_TASK_SLEEP);
    d08e:	7b03      	ldrb	r3, [r0, #12]
    d090:	2b02      	cmp	r3, #2
    d092:	d005      	beq.n	d0a0 <os_sched_wakeup+0x14>
    d094:	2300      	movs	r3, #0
    d096:	001a      	movs	r2, r3
    d098:	0019      	movs	r1, r3
    d09a:	0018      	movs	r0, r3
    d09c:	f7ff fc4c 	bl	c938 <__assert_func>
    if (t->t_obj) {
    d0a0:	69c2      	ldr	r2, [r0, #28]
    d0a2:	2a00      	cmp	r2, #0
    d0a4:	d009      	beq.n	d0ba <os_sched_wakeup+0x2e>
        assert(!SLIST_EMPTY(&os_obj->obj_head));
    d0a6:	6813      	ldr	r3, [r2, #0]
    d0a8:	2b00      	cmp	r3, #0
    d0aa:	d0f3      	beq.n	d094 <os_sched_wakeup+0x8>
    d0ac:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
        SLIST_REMOVE(&os_obj->obj_head, t, os_task, t_obj_list);
    d0ae:	4283      	cmp	r3, r0
    d0b0:	d116      	bne.n	d0e0 <os_sched_wakeup+0x54>
    d0b2:	6011      	str	r1, [r2, #0]
        SLIST_NEXT(t, t_obj_list) = NULL;
    d0b4:	2300      	movs	r3, #0
    d0b6:	64c3      	str	r3, [r0, #76]	; 0x4c
        t->t_obj = NULL;
    d0b8:	61c3      	str	r3, [r0, #28]
    t->t_next_wakeup = 0;
    d0ba:	2300      	movs	r3, #0
    t->t_state = OS_TASK_READY;
    d0bc:	2201      	movs	r2, #1
    t->t_next_wakeup = 0;
    d0be:	6343      	str	r3, [r0, #52]	; 0x34
    t->t_flags &= ~OS_TASK_FLAG_NO_TIMEOUT;
    d0c0:	7b43      	ldrb	r3, [r0, #13]
    t->t_state = OS_TASK_READY;
    d0c2:	7302      	strb	r2, [r0, #12]
    t->t_flags &= ~OS_TASK_FLAG_NO_TIMEOUT;
    d0c4:	4393      	bics	r3, r2
    d0c6:	7343      	strb	r3, [r0, #13]
    TAILQ_REMOVE(&g_os_sleep_list, t, t_os_list);
    d0c8:	6c43      	ldr	r3, [r0, #68]	; 0x44
    d0ca:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d0cc:	2b00      	cmp	r3, #0
    d0ce:	d00c      	beq.n	d0ea <os_sched_wakeup+0x5e>
    d0d0:	649a      	str	r2, [r3, #72]	; 0x48
    d0d2:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d0d4:	6013      	str	r3, [r2, #0]
    os_sched_insert(t);
    d0d6:	f7ff ff43 	bl	cf60 <os_sched_insert>
}
    d0da:	2000      	movs	r0, #0
    d0dc:	bd10      	pop	{r4, pc}
    d0de:	0013      	movs	r3, r2
        SLIST_REMOVE(&os_obj->obj_head, t, os_task, t_obj_list);
    d0e0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    d0e2:	4282      	cmp	r2, r0
    d0e4:	d1fb      	bne.n	d0de <os_sched_wakeup+0x52>
    d0e6:	64d9      	str	r1, [r3, #76]	; 0x4c
    d0e8:	e7e4      	b.n	d0b4 <os_sched_wakeup+0x28>
    TAILQ_REMOVE(&g_os_sleep_list, t, t_os_list);
    d0ea:	4901      	ldr	r1, [pc, #4]	; (d0f0 <os_sched_wakeup+0x64>)
    d0ec:	604a      	str	r2, [r1, #4]
    d0ee:	e7f0      	b.n	d0d2 <os_sched_wakeup+0x46>
    d0f0:	200000c0 	.word	0x200000c0

0000d0f4 <os_sched_os_timer_exp>:
{
    d0f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    now = os_time_get();
    d0f6:	f000 f8e7 	bl	d2c8 <os_time_get>
    d0fa:	0005      	movs	r5, r0
    OS_ENTER_CRITICAL(sr);
    d0fc:	f000 f948 	bl	d390 <os_arch_save_sr>
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
    d100:	2601      	movs	r6, #1
    t = TAILQ_FIRST(&g_os_sleep_list);
    d102:	4b0a      	ldr	r3, [pc, #40]	; (d12c <os_sched_os_timer_exp+0x38>)
    OS_ENTER_CRITICAL(sr);
    d104:	0004      	movs	r4, r0
    t = TAILQ_FIRST(&g_os_sleep_list);
    d106:	6818      	ldr	r0, [r3, #0]
    while (t) {
    d108:	2800      	cmp	r0, #0
    d10a:	d103      	bne.n	d114 <os_sched_os_timer_exp+0x20>
    OS_EXIT_CRITICAL(sr);
    d10c:	0020      	movs	r0, r4
    d10e:	f000 f945 	bl	d39c <os_arch_restore_sr>
}
    d112:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT) {
    d114:	7b43      	ldrb	r3, [r0, #13]
    d116:	4233      	tst	r3, r6
    d118:	d1f8      	bne.n	d10c <os_sched_os_timer_exp+0x18>
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
    d11a:	6b43      	ldr	r3, [r0, #52]	; 0x34
        next = TAILQ_NEXT(t, t_os_list);
    d11c:	6c47      	ldr	r7, [r0, #68]	; 0x44
        if (OS_TIME_TICK_GEQ(now, t->t_next_wakeup)) {
    d11e:	1aeb      	subs	r3, r5, r3
    d120:	d4f4      	bmi.n	d10c <os_sched_os_timer_exp+0x18>
            os_sched_wakeup(t);
    d122:	f7ff ffb3 	bl	d08c <os_sched_wakeup>
        t = next;
    d126:	0038      	movs	r0, r7
    d128:	e7ee      	b.n	d108 <os_sched_os_timer_exp+0x14>
    d12a:	46c0      	nop			; (mov r8, r8)
    d12c:	200000c0 	.word	0x200000c0

0000d130 <os_sched_wakeup_ticks>:
{
    d130:	b510      	push	{r4, lr}
    d132:	0004      	movs	r4, r0
    OS_ASSERT_CRITICAL();
    d134:	f000 f936 	bl	d3a4 <os_arch_in_critical>
    d138:	2800      	cmp	r0, #0
    d13a:	d104      	bne.n	d146 <os_sched_wakeup_ticks+0x16>
    d13c:	0003      	movs	r3, r0
    d13e:	0002      	movs	r2, r0
    d140:	0001      	movs	r1, r0
    d142:	f7ff fbf9 	bl	c938 <__assert_func>
    t = TAILQ_FIRST(&g_os_sleep_list);
    d146:	4b08      	ldr	r3, [pc, #32]	; (d168 <os_sched_wakeup_ticks+0x38>)
    d148:	681b      	ldr	r3, [r3, #0]
    if (t == NULL || (t->t_flags & OS_TASK_FLAG_NO_TIMEOUT)) {
    d14a:	2b00      	cmp	r3, #0
    d14c:	d008      	beq.n	d160 <os_sched_wakeup_ticks+0x30>
    d14e:	7b5a      	ldrb	r2, [r3, #13]
    d150:	07d2      	lsls	r2, r2, #31
    d152:	d405      	bmi.n	d160 <os_sched_wakeup_ticks+0x30>
    } else if (OS_TIME_TICK_GEQ(t->t_next_wakeup, now)) {
    d154:	6b58      	ldr	r0, [r3, #52]	; 0x34
    d156:	1b00      	subs	r0, r0, r4
        rt = 0;     /* wakeup time was in the past */
    d158:	43c3      	mvns	r3, r0
    d15a:	17db      	asrs	r3, r3, #31
    d15c:	4018      	ands	r0, r3
}
    d15e:	bd10      	pop	{r4, pc}
        rt = OS_TIMEOUT_NEVER;
    d160:	2001      	movs	r0, #1
    d162:	4240      	negs	r0, r0
    d164:	e7fb      	b.n	d15e <os_sched_wakeup_ticks+0x2e>
    d166:	46c0      	nop			; (mov r8, r8)
    d168:	200000c0 	.word	0x200000c0

0000d16c <os_sched_next_task>:
    return (TAILQ_FIRST(&g_os_run_list));
    d16c:	4b01      	ldr	r3, [pc, #4]	; (d174 <os_sched_next_task+0x8>)
    d16e:	6818      	ldr	r0, [r3, #0]
}
    d170:	4770      	bx	lr
    d172:	46c0      	nop			; (mov r8, r8)
    d174:	200000b8 	.word	0x200000b8

0000d178 <os_sched_resort>:
 * NOTE: this function expects interrupts to be disabled so they
 * are not disabled here.
 */
void
os_sched_resort(struct os_task *t)
{
    d178:	b510      	push	{r4, lr}
    if (t->t_state == OS_TASK_READY) {
    d17a:	7b03      	ldrb	r3, [r0, #12]
    d17c:	2b01      	cmp	r3, #1
    d17e:	d108      	bne.n	d192 <os_sched_resort+0x1a>
        TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d180:	6c43      	ldr	r3, [r0, #68]	; 0x44
    d182:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d184:	2b00      	cmp	r3, #0
    d186:	d005      	beq.n	d194 <os_sched_resort+0x1c>
    d188:	649a      	str	r2, [r3, #72]	; 0x48
    d18a:	6c82      	ldr	r2, [r0, #72]	; 0x48
    d18c:	6013      	str	r3, [r2, #0]
        os_sched_insert(t);
    d18e:	f7ff fee7 	bl	cf60 <os_sched_insert>
    }
}
    d192:	bd10      	pop	{r4, pc}
        TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
    d194:	4901      	ldr	r1, [pc, #4]	; (d19c <os_sched_resort+0x24>)
    d196:	604a      	str	r2, [r1, #4]
    d198:	e7f7      	b.n	d18a <os_sched_resort+0x12>
    d19a:	46c0      	nop			; (mov r8, r8)
    d19c:	200000b8 	.word	0x200000b8

0000d1a0 <os_task_init>:
 */
int
os_task_init(struct os_task *t, const char *name, os_task_func_t func,
        void *arg, uint8_t prio, os_time_t sanity_itvl,
        os_stack_t *stack_bottom, uint16_t stack_size)
{
    d1a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    d1a2:	0007      	movs	r7, r0
    d1a4:	0014      	movs	r4, r2
    d1a6:	9300      	str	r3, [sp, #0]
    d1a8:	ab08      	add	r3, sp, #32
    d1aa:	781b      	ldrb	r3, [r3, #0]
    d1ac:	000e      	movs	r6, r1
    struct os_sanity_check *sc;
    int rc;
    struct os_task *task;

    memset(t, 0, sizeof(*t));
    d1ae:	2250      	movs	r2, #80	; 0x50
    d1b0:	2100      	movs	r1, #0
{
    d1b2:	9301      	str	r3, [sp, #4]
    d1b4:	ab0b      	add	r3, sp, #44	; 0x2c
    d1b6:	881d      	ldrh	r5, [r3, #0]
    memset(t, 0, sizeof(*t));
    d1b8:	f000 fb7a 	bl	d8b0 <memset>

    t->t_func = func;
    t->t_arg = arg;
    d1bc:	9b00      	ldr	r3, [sp, #0]
    t->t_func = func;
    d1be:	617c      	str	r4, [r7, #20]
    t->t_arg = arg;
    d1c0:	61bb      	str	r3, [r7, #24]
    OS_ENTER_CRITICAL(sr);
    d1c2:	f000 f8e5 	bl	d390 <os_arch_save_sr>
    rc = g_task_id;
    d1c6:	4b27      	ldr	r3, [pc, #156]	; (d264 <os_task_init+0xc4>)
    d1c8:	781c      	ldrb	r4, [r3, #0]
    g_task_id++;
    d1ca:	1c62      	adds	r2, r4, #1
    d1cc:	701a      	strb	r2, [r3, #0]
    OS_EXIT_CRITICAL(sr);
    d1ce:	f000 f8e5 	bl	d39c <os_arch_restore_sr>

    t->t_taskid = os_task_next_id();
    t->t_prio = prio;
    d1d2:	466b      	mov	r3, sp
    d1d4:	791b      	ldrb	r3, [r3, #4]

    t->t_state = OS_TASK_READY;
    t->t_name = name;
    d1d6:	613e      	str	r6, [r7, #16]
    t->t_prio = prio;
    d1d8:	72fb      	strb	r3, [r7, #11]
    t->t_state = OS_TASK_READY;
    d1da:	2301      	movs	r3, #1
    t->t_next_wakeup = 0;

    rc = os_sanity_check_init(&t->t_sanity_check);
    d1dc:	003e      	movs	r6, r7
    t->t_state = OS_TASK_READY;
    d1de:	733b      	strb	r3, [r7, #12]
    t->t_next_wakeup = 0;
    d1e0:	2300      	movs	r3, #0
    rc = os_sanity_check_init(&t->t_sanity_check);
    d1e2:	3620      	adds	r6, #32
    t->t_taskid = os_task_next_id();
    d1e4:	72bc      	strb	r4, [r7, #10]
    t->t_next_wakeup = 0;
    d1e6:	637b      	str	r3, [r7, #52]	; 0x34
    rc = os_sanity_check_init(&t->t_sanity_check);
    d1e8:	0030      	movs	r0, r6
    d1ea:	f7ff fe6d 	bl	cec8 <os_sanity_check_init>
    d1ee:	1e04      	subs	r4, r0, #0
    if (rc != OS_OK) {
    d1f0:	d125      	bne.n	d23e <os_task_init+0x9e>
        goto err;
    }

    if (sanity_itvl != OS_WAIT_FOREVER) {
    d1f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d1f4:	3301      	adds	r3, #1
    d1f6:	d11b      	bne.n	d230 <os_task_init+0x90>
        stack_bottom[i] = OS_STACK_PATTERN;
    d1f8:	4b1b      	ldr	r3, [pc, #108]	; (d268 <os_task_init+0xc8>)
    for (i = 0; i < size; i++) {
    d1fa:	42a5      	cmp	r5, r4
    d1fc:	dc20      	bgt.n	d240 <os_task_init+0xa0>
            goto err;
        }
    }

    _clear_stack(stack_bottom, stack_size);
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
    d1fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d200:	00ac      	lsls	r4, r5, #2
    d202:	191c      	adds	r4, r3, r4
    d204:	002a      	movs	r2, r5
    d206:	0021      	movs	r1, r4
    d208:	0038      	movs	r0, r7
    d20a:	f000 f8d0 	bl	d3ae <os_arch_task_stack_init>
            stack_size);
    t->t_stacktop = &stack_bottom[stack_size];
    t->t_stacksize = stack_size;

    STAILQ_FOREACH(task, &g_os_task_list, t_os_task_list) {
    d20e:	4a17      	ldr	r2, [pc, #92]	; (d26c <os_task_init+0xcc>)
    t->t_stackptr = os_arch_task_stack_init(t, &stack_bottom[stack_size],
    d210:	6038      	str	r0, [r7, #0]
    STAILQ_FOREACH(task, &g_os_task_list, t_os_task_list) {
    d212:	6813      	ldr	r3, [r2, #0]
    t->t_stacktop = &stack_bottom[stack_size];
    d214:	607c      	str	r4, [r7, #4]
    t->t_stacksize = stack_size;
    d216:	813d      	strh	r5, [r7, #8]
    STAILQ_FOREACH(task, &g_os_task_list, t_os_task_list) {
    d218:	2b00      	cmp	r3, #0
    d21a:	d116      	bne.n	d24a <os_task_init+0xaa>
        assert(t->t_prio != task->t_prio);
    }

    /* insert this task into the task list */
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    d21c:	643b      	str	r3, [r7, #64]	; 0x40
    d21e:	6853      	ldr	r3, [r2, #4]

    /* insert this task into the scheduler list */
    rc = os_sched_insert(t);
    d220:	0038      	movs	r0, r7
    STAILQ_INSERT_TAIL(&g_os_task_list, t, t_os_task_list);
    d222:	601f      	str	r7, [r3, #0]
    d224:	003b      	movs	r3, r7
    d226:	3340      	adds	r3, #64	; 0x40
    d228:	6053      	str	r3, [r2, #4]
    rc = os_sched_insert(t);
    d22a:	f7ff fe99 	bl	cf60 <os_sched_insert>
    }

    os_trace_task_info(t);

    return (0);
err:
    d22e:	e006      	b.n	d23e <os_task_init+0x9e>
        sc->sc_checkin_itvl = sanity_itvl;
    d230:	9b09      	ldr	r3, [sp, #36]	; 0x24
        rc = os_sanity_check_register(sc);
    d232:	0030      	movs	r0, r6
        sc->sc_checkin_itvl = sanity_itvl;
    d234:	627b      	str	r3, [r7, #36]	; 0x24
        rc = os_sanity_check_register(sc);
    d236:	f7ff fe4f 	bl	ced8 <os_sanity_check_register>
        if (rc != OS_OK) {
    d23a:	2800      	cmp	r0, #0
    d23c:	d0dc      	beq.n	d1f8 <os_task_init+0x58>
    return (rc);
}
    d23e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        stack_bottom[i] = OS_STACK_PATTERN;
    d240:	990a      	ldr	r1, [sp, #40]	; 0x28
    d242:	00a2      	lsls	r2, r4, #2
    d244:	508b      	str	r3, [r1, r2]
    for (i = 0; i < size; i++) {
    d246:	3401      	adds	r4, #1
    d248:	e7d7      	b.n	d1fa <os_task_init+0x5a>
        assert(t->t_prio != task->t_prio);
    d24a:	7af8      	ldrb	r0, [r7, #11]
    d24c:	7ad9      	ldrb	r1, [r3, #11]
    d24e:	4288      	cmp	r0, r1
    d250:	d105      	bne.n	d25e <os_task_init+0xbe>
    d252:	2300      	movs	r3, #0
    d254:	001a      	movs	r2, r3
    d256:	0019      	movs	r1, r3
    d258:	0018      	movs	r0, r3
    d25a:	f7ff fb6d 	bl	c938 <__assert_func>
    STAILQ_FOREACH(task, &g_os_task_list, t_os_task_list) {
    d25e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    d260:	e7da      	b.n	d218 <os_task_init+0x78>
    d262:	46c0      	nop			; (mov r8, r8)
    d264:	200024c4 	.word	0x200024c4
    d268:	deadbeef 	.word	0xdeadbeef
    d26c:	200024bc 	.word	0x200024bc

0000d270 <os_deltatime>:
} basetod;

static void
os_deltatime(os_time_t delta, const struct os_timeval *base,
    struct os_timeval *result)
{
    d270:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    d272:	000f      	movs	r7, r1
    struct os_timeval tvdelta;

    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    d274:	21fa      	movs	r1, #250	; 0xfa
    d276:	0089      	lsls	r1, r1, #2
{
    d278:	0016      	movs	r6, r2
    d27a:	9001      	str	r0, [sp, #4]
    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    d27c:	f003 f8e2 	bl	10444 <__udivsi3>
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    os_timeradd(base, &tvdelta, result);
    d280:	683a      	ldr	r2, [r7, #0]
    d282:	687b      	ldr	r3, [r7, #4]
    tvdelta.tv_sec = delta / OS_TICKS_PER_SEC;
    d284:	0004      	movs	r4, r0
    d286:	2500      	movs	r5, #0
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    d288:	21fa      	movs	r1, #250	; 0xfa
    os_timeradd(base, &tvdelta, result);
    d28a:	18a4      	adds	r4, r4, r2
    d28c:	415d      	adcs	r5, r3
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    d28e:	0089      	lsls	r1, r1, #2
    os_timeradd(base, &tvdelta, result);
    d290:	6034      	str	r4, [r6, #0]
    d292:	6075      	str	r5, [r6, #4]
    tvdelta.tv_usec = (delta % OS_TICKS_PER_SEC) * OS_USEC_PER_TICK;
    d294:	9801      	ldr	r0, [sp, #4]
    d296:	f003 f95b 	bl	10550 <__aeabi_uidivmod>
    d29a:	23fa      	movs	r3, #250	; 0xfa
    d29c:	009b      	lsls	r3, r3, #2
    d29e:	4359      	muls	r1, r3
    os_timeradd(base, &tvdelta, result);
    d2a0:	68bb      	ldr	r3, [r7, #8]
    d2a2:	18c9      	adds	r1, r1, r3
    d2a4:	4b06      	ldr	r3, [pc, #24]	; (d2c0 <os_deltatime+0x50>)
    d2a6:	60b1      	str	r1, [r6, #8]
    d2a8:	4299      	cmp	r1, r3
    d2aa:	dd08      	ble.n	d2be <os_deltatime+0x4e>
    d2ac:	2300      	movs	r3, #0
    d2ae:	2201      	movs	r2, #1
    d2b0:	18a4      	adds	r4, r4, r2
    d2b2:	415d      	adcs	r5, r3
    d2b4:	4b03      	ldr	r3, [pc, #12]	; (d2c4 <os_deltatime+0x54>)
    d2b6:	6034      	str	r4, [r6, #0]
    d2b8:	6075      	str	r5, [r6, #4]
    d2ba:	18c9      	adds	r1, r1, r3
    d2bc:	60b1      	str	r1, [r6, #8]
}
    d2be:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    d2c0:	000f423f 	.word	0x000f423f
    d2c4:	fff0bdc0 	.word	0xfff0bdc0

0000d2c8 <os_time_get>:
 * @return OS time in ticks
 */
os_time_t
os_time_get(void)
{
    return (g_os_time);
    d2c8:	4b01      	ldr	r3, [pc, #4]	; (d2d0 <os_time_get+0x8>)
    d2ca:	6818      	ldr	r0, [r3, #0]
}
    d2cc:	4770      	bx	lr
    d2ce:	46c0      	nop			; (mov r8, r8)
    d2d0:	200024c8 	.word	0x200024c8

0000d2d4 <os_time_advance>:
 *
 * @param ticks The number of ticks to move time forward.
 */
void
os_time_advance(int ticks)
{
    d2d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    d2d6:	1e04      	subs	r4, r0, #0
    assert(ticks >= 0);
    d2d8:	da05      	bge.n	d2e6 <os_time_advance+0x12>
    d2da:	2300      	movs	r3, #0
    d2dc:	001a      	movs	r2, r3
    d2de:	0019      	movs	r1, r3
    d2e0:	0018      	movs	r0, r3
    d2e2:	f7ff fb29 	bl	c938 <__assert_func>

    if (ticks > 0) {
    d2e6:	2800      	cmp	r0, #0
    d2e8:	d007      	beq.n	d2fa <os_time_advance+0x26>
        if (!os_started()) {
    d2ea:	f7ff fbcd 	bl	ca88 <os_started>
    d2ee:	4d15      	ldr	r5, [pc, #84]	; (d344 <os_time_advance+0x70>)
    d2f0:	2800      	cmp	r0, #0
    d2f2:	d103      	bne.n	d2fc <os_time_advance+0x28>
            g_os_time += ticks;
    d2f4:	682b      	ldr	r3, [r5, #0]
    d2f6:	191c      	adds	r4, r3, r4
    d2f8:	602c      	str	r4, [r5, #0]
            os_callout_tick();
            os_sched_os_timer_exp();
            os_sched(NULL);
        }
    }
}
    d2fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    OS_ENTER_CRITICAL(sr);
    d2fc:	f000 f848 	bl	d390 <os_arch_save_sr>
    prev_os_time = g_os_time;
    d300:	682b      	ldr	r3, [r5, #0]
    OS_ENTER_CRITICAL(sr);
    d302:	0006      	movs	r6, r0
    g_os_time += ticks;
    d304:	18e4      	adds	r4, r4, r3
    d306:	602c      	str	r4, [r5, #0]
    if ((prev_os_time ^ g_os_time) >> 31) {
    d308:	4063      	eors	r3, r4
    d30a:	d510      	bpl.n	d32e <os_time_advance+0x5a>
        delta = g_os_time - basetod.ostime;
    d30c:	4f0e      	ldr	r7, [pc, #56]	; (d348 <os_time_advance+0x74>)
        os_deltatime(delta, &basetod.uptime, &basetod.uptime);
    d30e:	0039      	movs	r1, r7
        delta = g_os_time - basetod.ostime;
    d310:	683b      	ldr	r3, [r7, #0]
        os_deltatime(delta, &basetod.uptime, &basetod.uptime);
    d312:	3108      	adds	r1, #8
        delta = g_os_time - basetod.ostime;
    d314:	1ae4      	subs	r4, r4, r3
        os_deltatime(delta, &basetod.uptime, &basetod.uptime);
    d316:	000a      	movs	r2, r1
    d318:	0020      	movs	r0, r4
    d31a:	f7ff ffa9 	bl	d270 <os_deltatime>
        os_deltatime(delta, &basetod.utctime, &basetod.utctime);
    d31e:	0039      	movs	r1, r7
    d320:	3118      	adds	r1, #24
    d322:	000a      	movs	r2, r1
    d324:	0020      	movs	r0, r4
    d326:	f7ff ffa3 	bl	d270 <os_deltatime>
        basetod.ostime = g_os_time;
    d32a:	682b      	ldr	r3, [r5, #0]
    d32c:	603b      	str	r3, [r7, #0]
    OS_EXIT_CRITICAL(sr);
    d32e:	0030      	movs	r0, r6
    d330:	f000 f834 	bl	d39c <os_arch_restore_sr>
            os_callout_tick();
    d334:	f7ff fc4a 	bl	cbcc <os_callout_tick>
            os_sched_os_timer_exp();
    d338:	f7ff fedc 	bl	d0f4 <os_sched_os_timer_exp>
            os_sched(NULL);
    d33c:	2000      	movs	r0, #0
    d33e:	f7ff fe57 	bl	cff0 <os_sched>
}
    d342:	e7da      	b.n	d2fa <os_time_advance+0x26>
    d344:	200024c8 	.word	0x200024c8
    d348:	20001f98 	.word	0x20001f98

0000d34c <os_time_delay>:
 *
 * @param osticks Number of ticks to delay (<= 0 means no delay).
 */
void
os_time_delay(int32_t osticks)
{
    d34c:	b570      	push	{r4, r5, r6, lr}
    d34e:	1e04      	subs	r4, r0, #0
    os_sr_t sr;

    if (osticks > 0) {
    d350:	dd0d      	ble.n	d36e <os_time_delay+0x22>
        OS_ENTER_CRITICAL(sr);
    d352:	f000 f81d 	bl	d390 <os_arch_save_sr>
    d356:	0005      	movs	r5, r0
        os_sched_sleep(os_sched_get_current_task(), (os_time_t)osticks);
    d358:	f7ff fe3e 	bl	cfd8 <os_sched_get_current_task>
    d35c:	0021      	movs	r1, r4
    d35e:	f7ff fe59 	bl	d014 <os_sched_sleep>
        OS_EXIT_CRITICAL(sr);
    d362:	0028      	movs	r0, r5
    d364:	f000 f81a 	bl	d39c <os_arch_restore_sr>
        os_sched(NULL);
    d368:	2000      	movs	r0, #0
    d36a:	f7ff fe41 	bl	cff0 <os_sched>
    }
}
    d36e:	bd70      	pop	{r4, r5, r6, pc}

0000d370 <timer_handler>:
/* XXX: determine how we will deal with running un-privileged */
uint32_t os_flags = OS_RUN_PRIV;

void
timer_handler(void)
{
    d370:	b510      	push	{r4, lr}
    os_time_advance(1);
    d372:	2001      	movs	r0, #1
    d374:	f7ff ffae 	bl	d2d4 <os_time_advance>
}
    d378:	bd10      	pop	{r4, pc}
	...

0000d37c <os_arch_ctx_sw>:

void
os_arch_ctx_sw(struct os_task *t)
{
    d37c:	b510      	push	{r4, lr}
    os_sched_ctx_sw_hook(t);
    d37e:	f7ff fe15 	bl	cfac <os_sched_ctx_sw_hook>

    /* Set PendSV interrupt pending bit to force context switch */
    SCB->ICSR = SCB_ICSR_PENDSVSET_Msk;
    d382:	2280      	movs	r2, #128	; 0x80
    d384:	4b01      	ldr	r3, [pc, #4]	; (d38c <os_arch_ctx_sw+0x10>)
    d386:	0552      	lsls	r2, r2, #21
    d388:	605a      	str	r2, [r3, #4]
}
    d38a:	bd10      	pop	{r4, pc}
    d38c:	e000ed00 	.word	0xe000ed00

0000d390 <os_arch_save_sr>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    d390:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
    d394:	b672      	cpsid	i
{
    uint32_t isr_ctx;

    isr_ctx = __get_PRIMASK();
    __disable_irq();
    return (isr_ctx & 1);
    d396:	2301      	movs	r3, #1
    d398:	4018      	ands	r0, r3
}
    d39a:	4770      	bx	lr

0000d39c <os_arch_restore_sr>:

void
os_arch_restore_sr(os_sr_t isr_ctx)
{
    if (!isr_ctx) {
    d39c:	2800      	cmp	r0, #0
    d39e:	d100      	bne.n	d3a2 <os_arch_restore_sr+0x6>
  __ASM volatile ("cpsie i" : : : "memory");
    d3a0:	b662      	cpsie	i
        __enable_irq();
    }
}
    d3a2:	4770      	bx	lr

0000d3a4 <os_arch_in_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
    d3a4:	f3ef 8010 	mrs	r0, PRIMASK
os_arch_in_critical(void)
{
    uint32_t isr_ctx;

    isr_ctx = __get_PRIMASK();
    return (isr_ctx & 1);
    d3a8:	2301      	movs	r3, #1
    d3aa:	4018      	ands	r0, r3
}
    d3ac:	4770      	bx	lr

0000d3ae <os_arch_task_stack_init>:

os_stack_t *
os_arch_task_stack_init(struct os_task *t, os_stack_t *stack_top, int size)
{
    d3ae:	b570      	push	{r4, r5, r6, lr}
    /* Get stack frame pointer */
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));

    /* Zero out R1-R3, R12, LR */
    for (i = 9; i < 14; ++i) {
        s[i] = 0;
    d3b0:	000a      	movs	r2, r1
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));
    d3b2:	000c      	movs	r4, r1
        s[i] = 0;
    d3b4:	2300      	movs	r3, #0
    s = (os_stack_t *) ((uint8_t *) stack_top - sizeof(*sf));
    d3b6:	3c40      	subs	r4, #64	; 0x40
        s[i] = 0;
    d3b8:	3a1c      	subs	r2, #28
    d3ba:	390c      	subs	r1, #12
{
    d3bc:	0005      	movs	r5, r0
        s[i] = 0;
    d3be:	6013      	str	r3, [r2, #0]
    d3c0:	6053      	str	r3, [r2, #4]
    d3c2:	6093      	str	r3, [r2, #8]
    d3c4:	60d3      	str	r3, [r2, #12]
    }

    /* Set registers R4 - R11 on stack. */
    os_arch_init_task_stack(s);
    d3c6:	0020      	movs	r0, r4
        s[i] = 0;
    d3c8:	600b      	str	r3, [r1, #0]
    os_arch_init_task_stack(s);
    d3ca:	f000 f9f9 	bl	d7c0 <os_arch_init_task_stack>

    /* Set remaining portions of stack frame */
    sf = (struct stack_frame *) s;
    sf->xpsr = INITIAL_xPSR;
    d3ce:	2380      	movs	r3, #128	; 0x80
    d3d0:	045b      	lsls	r3, r3, #17
    d3d2:	63e3      	str	r3, [r4, #60]	; 0x3c
    sf->pc = (uint32_t)t->t_func;
    d3d4:	696b      	ldr	r3, [r5, #20]
    sf->r0 = (uint32_t)t->t_arg;

    return (s);
}
    d3d6:	0020      	movs	r0, r4
    sf->pc = (uint32_t)t->t_func;
    d3d8:	63a3      	str	r3, [r4, #56]	; 0x38
    sf->r0 = (uint32_t)t->t_arg;
    d3da:	69ab      	ldr	r3, [r5, #24]
    d3dc:	6223      	str	r3, [r4, #32]
}
    d3de:	bd70      	pop	{r4, r5, r6, pc}

0000d3e0 <os_arch_init>:

void
os_arch_init(void)
{
    d3e0:	b510      	push	{r4, lr}
    os_init_idle_task();
    d3e2:	f7ff fb57 	bl	ca94 <os_init_idle_task>
}
    d3e6:	bd10      	pop	{r4, pc}

0000d3e8 <os_arch_os_init>:
    SVC_Call(os_arch_init);
}

os_error_t
os_arch_os_init(void)
{
    d3e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    d3ea:	f3ef 8305 	mrs	r3, IPSR
    os_error_t err;
    int i;

    /* Cannot be called within an ISR */
    err = OS_ERR_IN_ISR;
    d3ee:	2007      	movs	r0, #7
    if (__get_IPSR() == 0) {
    d3f0:	2b00      	cmp	r3, #0
    d3f2:	d146      	bne.n	d482 <os_arch_os_init+0x9a>
        err = OS_OK;

        /* Drop priority for all interrupts */
        for (i = 0; i < sizeof(NVIC->IP); i++) {
            NVIC->IP[i] = -1;
    d3f4:	4925      	ldr	r1, [pc, #148]	; (d48c <os_arch_os_init+0xa4>)
    d3f6:	3808      	subs	r0, #8
    d3f8:	001a      	movs	r2, r3
    d3fa:	32c0      	adds	r2, #192	; 0xc0
    d3fc:	0092      	lsls	r2, r2, #2
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    d3fe:	3301      	adds	r3, #1
            NVIC->IP[i] = -1;
    d400:	5050      	str	r0, [r2, r1]
        for (i = 0; i < sizeof(NVIC->IP); i++) {
    d402:	2b20      	cmp	r3, #32
    d404:	d1f8      	bne.n	d3f8 <os_arch_os_init+0x10>
        }

        NVIC_SetVector(SVCall_IRQn, (uint32_t)SVC_Handler);
    d406:	2005      	movs	r0, #5
    d408:	4921      	ldr	r1, [pc, #132]	; (d490 <os_arch_os_init+0xa8>)
    d40a:	4240      	negs	r0, r0
    d40c:	f7ff f950 	bl	c6b0 <NVIC_SetVector>
        NVIC_SetVector(PendSV_IRQn, (uint32_t)PendSV_Handler);
    d410:	2002      	movs	r0, #2
    d412:	4920      	ldr	r1, [pc, #128]	; (d494 <os_arch_os_init+0xac>)
    d414:	4240      	negs	r0, r0
    d416:	f7ff f94b 	bl	c6b0 <NVIC_SetVector>
        NVIC_SetVector(SysTick_IRQn, (uint32_t)SysTick_Handler);
    d41a:	2001      	movs	r0, #1
    d41c:	491e      	ldr	r1, [pc, #120]	; (d498 <os_arch_os_init+0xb0>)
    d41e:	4240      	negs	r0, r0
    d420:	f7ff f946 	bl	c6b0 <NVIC_SetVector>
        /*
         * Install default interrupt handler, which'll print out system
         * state at the time of the interrupt, and few other regs which
         * should help in trying to figure out what went wrong.
         */
        NVIC_SetVector(NonMaskableInt_IRQn, (uint32_t)os_default_irq_asm);
    d424:	200e      	movs	r0, #14
    d426:	4d1d      	ldr	r5, [pc, #116]	; (d49c <os_arch_os_init+0xb4>)
    d428:	4240      	negs	r0, r0
    d42a:	0029      	movs	r1, r5
    d42c:	f7ff f940 	bl	c6b0 <NVIC_SetVector>
        NVIC_SetVector(HardFault_IRQn, (uint32_t)os_default_irq_asm);
    d430:	200d      	movs	r0, #13
    d432:	0029      	movs	r1, r5
    d434:	4240      	negs	r0, r0
    d436:	f7ff f93b 	bl	c6b0 <NVIC_SetVector>
        NVIC_SetVector(-13, (uint32_t)os_default_irq_asm); /* Hardfault */
    d43a:	200d      	movs	r0, #13
    d43c:	0029      	movs	r1, r5
    d43e:	4240      	negs	r0, r0
    d440:	f7ff f936 	bl	c6b0 <NVIC_SetVector>
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    d444:	2400      	movs	r4, #0
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
    d446:	b260      	sxtb	r0, r4
    d448:	0029      	movs	r1, r5
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    d44a:	3401      	adds	r4, #1
            NVIC_SetVector(i, (uint32_t)os_default_irq_asm);
    d44c:	f7ff f930 	bl	c6b0 <NVIC_SetVector>
        for (i = 0; i < NVIC_NUM_VECTORS - NVIC_USER_IRQ_OFFSET; i++) {
    d450:	2c1d      	cmp	r4, #29
    d452:	d1f8      	bne.n	d446 <os_arch_os_init+0x5e>
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    d454:	4d12      	ldr	r5, [pc, #72]	; (d4a0 <os_arch_os_init+0xb8>)
    d456:	4e13      	ldr	r6, [pc, #76]	; (d4a4 <os_arch_os_init+0xbc>)
    d458:	6a2c      	ldr	r4, [r5, #32]
    d45a:	4026      	ands	r6, r4
    d45c:	24c0      	movs	r4, #192	; 0xc0
    d45e:	0424      	lsls	r4, r4, #16
    d460:	4334      	orrs	r4, r6
    d462:	2680      	movs	r6, #128	; 0x80
    d464:	622c      	str	r4, [r5, #32]
    d466:	69ec      	ldr	r4, [r5, #28]
    d468:	05f6      	lsls	r6, r6, #23
    d46a:	0224      	lsls	r4, r4, #8
    d46c:	0a24      	lsrs	r4, r4, #8
    d46e:	4334      	orrs	r4, r6
    d470:	61ec      	str	r4, [r5, #28]
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    d472:	f3ef 8414 	mrs	r4, CONTROL

        /* Set the SVC interrupt to priority 0 (highest configurable) */
        NVIC_SetPriority(SVCall_IRQn, SVC_PRIO);

        /* Check if privileged or not */
        if ((__get_CONTROL() & 1) == 0) {
    d476:	2501      	movs	r5, #1
    d478:	402c      	ands	r4, r5
    d47a:	d103      	bne.n	d484 <os_arch_os_init+0x9c>
    os_init_idle_task();
    d47c:	f7ff fb0a 	bl	ca94 <os_init_idle_task>
        err = OS_OK;
    d480:	2000      	movs	r0, #0
            svc_os_arch_init();
        }
    }

    return err;
}
    d482:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    SVC_Call(os_arch_init);
    d484:	4f08      	ldr	r7, [pc, #32]	; (d4a8 <os_arch_os_init+0xc0>)
    d486:	46bc      	mov	ip, r7
    d488:	df00      	svc	0
    d48a:	e7f9      	b.n	d480 <os_arch_os_init+0x98>
    d48c:	e000e100 	.word	0xe000e100
    d490:	0000d7d3 	.word	0x0000d7d3
    d494:	0000d813 	.word	0x0000d813
    d498:	0000d851 	.word	0x0000d851
    d49c:	0000d863 	.word	0x0000d863
    d4a0:	e000ed00 	.word	0xe000ed00
    d4a4:	ff00ffff 	.word	0xff00ffff
    d4a8:	0000d3e1 	.word	0x0000d3e1

0000d4ac <os_arch_start>:

uint32_t
os_arch_start(void)
{
    d4ac:	b5b0      	push	{r4, r5, r7, lr}
    d4ae:	af00      	add	r7, sp, #0
    struct os_task *t;

    /* Get the highest priority ready to run to set the current task */
    t = os_sched_next_task();
    d4b0:	f7ff fe5c 	bl	d16c <os_sched_next_task>
    d4b4:	0004      	movs	r4, r0
    os_sched_set_current_task(t);
    d4b6:	f7ff fd95 	bl	cfe4 <os_sched_set_current_task>

    /* Adjust PSP so it looks like this task just took an exception */
    __set_PSP((uint32_t)t->t_stackptr + offsetof(struct stack_frame, r0));
    d4ba:	6823      	ldr	r3, [r4, #0]
    d4bc:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
    d4be:	f383 8809 	msr	PSP, r3

    /* Intitialize and start system clock timer */
    os_tick_init(OS_TICKS_PER_SEC, OS_TICK_PRIO);
    d4c2:	2102      	movs	r1, #2
    d4c4:	20fa      	movs	r0, #250	; 0xfa
    d4c6:	4088      	lsls	r0, r1
    d4c8:	f000 ff6a 	bl	e3a0 <os_tick_init>

    /* Mark the OS as started, right before we run our first task */
    g_os_started = 1;
    d4cc:	2201      	movs	r2, #1
    d4ce:	4b04      	ldr	r3, [pc, #16]	; (d4e0 <os_arch_start+0x34>)

    /* Perform context switch */
    os_arch_ctx_sw(t);
    d4d0:	0020      	movs	r0, r4
    g_os_started = 1;
    d4d2:	601a      	str	r2, [r3, #0]
    os_arch_ctx_sw(t);
    d4d4:	f7ff ff52 	bl	d37c <os_arch_ctx_sw>

    return (uint32_t)(t->t_arg);
}
    d4d8:	46bd      	mov	sp, r7
    return (uint32_t)(t->t_arg);
    d4da:	69a0      	ldr	r0, [r4, #24]
}
    d4dc:	bdb0      	pop	{r4, r5, r7, pc}
    d4de:	46c0      	nop			; (mov r8, r8)
    d4e0:	2000249c 	.word	0x2000249c

0000d4e4 <os_arch_os_start>:
     * priviliged or un-privileged mode.
     *
     * We switch to using "empty" part of idle task's stack until
     * the svc_os_arch_start() executes SVC, and we will never return.
     */
    os_set_env(g_idle_task.t_stackptr - 1);
    d4e4:	4812      	ldr	r0, [pc, #72]	; (d530 <os_arch_os_start+0x4c>)
{
    d4e6:	b5b0      	push	{r4, r5, r7, lr}
    os_set_env(g_idle_task.t_stackptr - 1);
    d4e8:	6800      	ldr	r0, [r0, #0]
    d4ea:	3804      	subs	r0, #4
    d4ec:	f000 f95e 	bl	d7ac <os_set_env>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    d4f0:	f3ef 8505 	mrs	r5, IPSR

    err = OS_ERR_IN_ISR;
    d4f4:	2407      	movs	r4, #7
    if (__get_IPSR() == 0) {
    d4f6:	2d00      	cmp	r5, #0
    d4f8:	d10e      	bne.n	d518 <os_arch_os_start+0x34>
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    d4fa:	f3ef 8414 	mrs	r4, CONTROL
         * The following switch statement is really just a sanity check to
         * insure that the os initialization routine was called prior to the
         * os start routine.
         */
        err = OS_OK;
        switch (__get_CONTROL() & 0x03) {
    d4fe:	3503      	adds	r5, #3
    d500:	402c      	ands	r4, r5
    d502:	2c02      	cmp	r4, #2
    d504:	d003      	beq.n	d50e <os_arch_os_start+0x2a>
    d506:	42ac      	cmp	r4, r5
    d508:	d008      	beq.n	d51c <os_arch_os_start+0x38>
         *
         * Fall-through intentional!
         */
        case 0x00:
        case 0x01:
            err = OS_ERR_PRIV;
    d50a:	2408      	movs	r4, #8
    d50c:	e004      	b.n	d518 <os_arch_os_start+0x34>
        case 0x02:
            /*
             * We are running in Privileged Thread mode w/SP = PSP but we
             * are supposed to be un-privileged.
             */
            if ((os_flags & 1) == OS_RUN_UNPRIV) {
    d50e:	4c09      	ldr	r4, [pc, #36]	; (d534 <os_arch_os_start+0x50>)
    d510:	6825      	ldr	r5, [r4, #0]
                err = OS_ERR_PRIV;
    d512:	2408      	movs	r4, #8
            if ((os_flags & 1) == OS_RUN_UNPRIV) {
    d514:	07ed      	lsls	r5, r5, #31
    d516:	d506      	bpl.n	d526 <os_arch_os_start+0x42>
            svc_os_arch_start();
        }
    }

    return err;
}
    d518:	0020      	movs	r0, r4
    d51a:	bdb0      	pop	{r4, r5, r7, pc}
            if  ((os_flags & 1) == OS_RUN_PRIV) {
    d51c:	4c05      	ldr	r4, [pc, #20]	; (d534 <os_arch_os_start+0x50>)
    d51e:	6825      	ldr	r5, [r4, #0]
                err = OS_ERR_PRIV;
    d520:	2408      	movs	r4, #8
            if  ((os_flags & 1) == OS_RUN_PRIV) {
    d522:	07ed      	lsls	r5, r5, #31
    d524:	d5f8      	bpl.n	d518 <os_arch_os_start+0x34>
    SVC_Call(os_arch_start);
    d526:	4f04      	ldr	r7, [pc, #16]	; (d538 <os_arch_os_start+0x54>)
    d528:	46bc      	mov	ip, r7
    d52a:	df00      	svc	0
    d52c:	2400      	movs	r4, #0
    d52e:	e7f3      	b.n	d518 <os_arch_os_start+0x34>
    d530:	20002348 	.word	0x20002348
    d534:	20001fc8 	.word	0x20001fc8
    d538:	0000d4ad 	.word	0x0000d4ad

0000d53c <os_msys_register>:
 *
 * @return 0 on success, non-zero on failure
 */
int
os_msys_register(struct os_mbuf_pool *new_pool)
{
    d53c:	b530      	push	{r4, r5, lr}
    struct os_mbuf_pool *pool;

    pool = NULL;
    STAILQ_FOREACH(pool, &g_msys_pool_list, omp_next) {
    d53e:	4a0d      	ldr	r2, [pc, #52]	; (d574 <os_msys_register+0x38>)
    d540:	6813      	ldr	r3, [r2, #0]
    d542:	2b00      	cmp	r3, #0
    d544:	d105      	bne.n	d552 <os_msys_register+0x16>
    }

    if (pool) {
        STAILQ_INSERT_AFTER(&g_msys_pool_list, pool, new_pool, omp_next);
    } else {
        STAILQ_INSERT_TAIL(&g_msys_pool_list, new_pool, omp_next);
    d546:	6083      	str	r3, [r0, #8]
    d548:	6853      	ldr	r3, [r2, #4]
    d54a:	6018      	str	r0, [r3, #0]
    d54c:	3008      	adds	r0, #8
    d54e:	6050      	str	r0, [r2, #4]
    }

    return (0);
    d550:	e00d      	b.n	d56e <os_msys_register+0x32>
        if (new_pool->omp_databuf_len > pool->omp_databuf_len) {
    d552:	8805      	ldrh	r5, [r0, #0]
    d554:	881c      	ldrh	r4, [r3, #0]
    d556:	6899      	ldr	r1, [r3, #8]
    d558:	42a5      	cmp	r5, r4
    d55a:	d801      	bhi.n	d560 <os_msys_register+0x24>
    d55c:	000b      	movs	r3, r1
    d55e:	e7f0      	b.n	d542 <os_msys_register+0x6>
        STAILQ_INSERT_AFTER(&g_msys_pool_list, pool, new_pool, omp_next);
    d560:	6081      	str	r1, [r0, #8]
    d562:	2900      	cmp	r1, #0
    d564:	d102      	bne.n	d56c <os_msys_register+0x30>
    d566:	0001      	movs	r1, r0
    d568:	3108      	adds	r1, #8
    d56a:	6051      	str	r1, [r2, #4]
    d56c:	6098      	str	r0, [r3, #8]
}
    d56e:	2000      	movs	r0, #0
    d570:	bd30      	pop	{r4, r5, pc}
    d572:	46c0      	nop			; (mov r8, r8)
    d574:	200000c8 	.word	0x200000c8

0000d578 <os_msys_reset>:
 * De-registers all mbuf pools from msys.
 */
void
os_msys_reset(void)
{
    STAILQ_INIT(&g_msys_pool_list);
    d578:	2200      	movs	r2, #0
    d57a:	4b02      	ldr	r3, [pc, #8]	; (d584 <os_msys_reset+0xc>)
    d57c:	601a      	str	r2, [r3, #0]
    d57e:	605b      	str	r3, [r3, #4]
}
    d580:	4770      	bx	lr
    d582:	46c0      	nop			; (mov r8, r8)
    d584:	200000c8 	.word	0x200000c8

0000d588 <os_mbuf_pool_init>:
 */
int
os_mbuf_pool_init(struct os_mbuf_pool *omp, struct os_mempool *mp,
                  uint16_t buf_len, uint16_t nbufs)
{
    omp->omp_databuf_len = buf_len - sizeof(struct os_mbuf);
    d588:	3a10      	subs	r2, #16
    d58a:	8002      	strh	r2, [r0, #0]
    omp->omp_mbuf_count = nbufs;
    d58c:	8043      	strh	r3, [r0, #2]
    omp->omp_pool = mp;
    d58e:	6041      	str	r1, [r0, #4]

    return (0);
}
    d590:	2000      	movs	r0, #0
    d592:	4770      	bx	lr

0000d594 <os_mempool_init>:
 * @return os_error_t
 */
os_error_t
os_mempool_init(struct os_mempool *mp, int blocks, int block_size,
                void *membuf, char *name)
{
    d594:	b570      	push	{r4, r5, r6, lr}
    d596:	2603      	movs	r6, #3
    d598:	0004      	movs	r4, r0
    uint8_t *block_addr;
    struct os_memblock *block_ptr;

    /* Check for valid parameters */
    if ((!mp) || (blocks < 0) || (block_size <= 0)) {
        return OS_INVALID_PARM;
    d59a:	0030      	movs	r0, r6
    if ((!mp) || (blocks < 0) || (block_size <= 0)) {
    d59c:	2c00      	cmp	r4, #0
    d59e:	d008      	beq.n	d5b2 <os_mempool_init+0x1e>
    d5a0:	2900      	cmp	r1, #0
    d5a2:	db06      	blt.n	d5b2 <os_mempool_init+0x1e>
    d5a4:	2a00      	cmp	r2, #0
    d5a6:	dd04      	ble.n	d5b2 <os_mempool_init+0x1e>
    d5a8:	0035      	movs	r5, r6
    }

    if ((!membuf) && (blocks != 0)) {
    d5aa:	2b00      	cmp	r3, #0
    d5ac:	d102      	bne.n	d5b4 <os_mempool_init+0x20>
    d5ae:	2900      	cmp	r1, #0
    d5b0:	d003      	beq.n	d5ba <os_mempool_init+0x26>
    SLIST_NEXT(block_ptr, mb_next) = NULL;

    STAILQ_INSERT_TAIL(&g_os_mempool_list, mp, mp_list);

    return OS_OK;
}
    d5b2:	bd70      	pop	{r4, r5, r6, pc}
            return OS_MEM_NOT_ALIGNED;
    d5b4:	2004      	movs	r0, #4
        if (((uint32_t)membuf & (OS_ALIGNMENT - 1)) != 0) {
    d5b6:	4233      	tst	r3, r6
    d5b8:	d1fb      	bne.n	d5b2 <os_mempool_init+0x1e>
    true_block_size = OS_MEMPOOL_TRUE_BLOCK_SIZE(block_size);
    d5ba:	0028      	movs	r0, r5
    d5bc:	0015      	movs	r5, r2
    d5be:	4010      	ands	r0, r2
    d5c0:	d001      	beq.n	d5c6 <os_mempool_init+0x32>
    d5c2:	1a10      	subs	r0, r2, r0
    d5c4:	1d05      	adds	r5, r0, #4
    mp->mp_block_size = block_size;
    d5c6:	6022      	str	r2, [r4, #0]
    mp->name = name;
    d5c8:	9a04      	ldr	r2, [sp, #16]
    mp->mp_num_free = blocks;
    d5ca:	60a1      	str	r1, [r4, #8]
    mp->mp_min_free = blocks;
    d5cc:	60e1      	str	r1, [r4, #12]
    mp->mp_num_blocks = blocks;
    d5ce:	6061      	str	r1, [r4, #4]
    mp->mp_membuf_addr = (uint32_t)membuf;
    d5d0:	6123      	str	r3, [r4, #16]
    mp->name = name;
    d5d2:	61e2      	str	r2, [r4, #28]
    SLIST_FIRST(mp) = membuf;
    d5d4:	61a3      	str	r3, [r4, #24]
    while (blocks > 1) {
    d5d6:	2901      	cmp	r1, #1
    d5d8:	dc08      	bgt.n	d5ec <os_mempool_init+0x58>
    SLIST_NEXT(block_ptr, mb_next) = NULL;
    d5da:	2000      	movs	r0, #0
    d5dc:	6018      	str	r0, [r3, #0]
    STAILQ_INSERT_TAIL(&g_os_mempool_list, mp, mp_list);
    d5de:	4b06      	ldr	r3, [pc, #24]	; (d5f8 <os_mempool_init+0x64>)
    d5e0:	6160      	str	r0, [r4, #20]
    d5e2:	685a      	ldr	r2, [r3, #4]
    d5e4:	6014      	str	r4, [r2, #0]
    d5e6:	3414      	adds	r4, #20
    d5e8:	605c      	str	r4, [r3, #4]
    return OS_OK;
    d5ea:	e7e2      	b.n	d5b2 <os_mempool_init+0x1e>
        block_addr += true_block_size;
    d5ec:	195a      	adds	r2, r3, r5
        SLIST_NEXT(block_ptr, mb_next) = (struct os_memblock *)block_addr;
    d5ee:	601a      	str	r2, [r3, #0]
        --blocks;
    d5f0:	3901      	subs	r1, #1
        block_addr += true_block_size;
    d5f2:	0013      	movs	r3, r2
    d5f4:	e7ef      	b.n	d5d6 <os_mempool_init+0x42>
    d5f6:	46c0      	nop			; (mov r8, r8)
    d5f8:	200000d0 	.word	0x200000d0

0000d5fc <os_mutex_init>:
 */
os_error_t
os_mutex_init(struct os_mutex *mu)
{
    if (!mu) {
        return OS_INVALID_PARM;
    d5fc:	2303      	movs	r3, #3
    if (!mu) {
    d5fe:	2800      	cmp	r0, #0
    d600:	d004      	beq.n	d60c <os_mutex_init+0x10>
    }

    os_trace_void(OS_TRACE_ID_MUTEX_INIT);
    /* Initialize to 0 */
    mu->mu_prio = 0;
    d602:	2300      	movs	r3, #0
    d604:	7143      	strb	r3, [r0, #5]
    mu->mu_level = 0;
    d606:	80c3      	strh	r3, [r0, #6]
    mu->mu_owner = NULL;
    d608:	6083      	str	r3, [r0, #8]
    SLIST_FIRST(&mu->mu_head) = NULL;
    d60a:	6003      	str	r3, [r0, #0]
    os_trace_end_call(OS_TRACE_ID_MUTEX_INIT);

    return OS_OK;
}
    d60c:	0018      	movs	r0, r3
    d60e:	4770      	bx	lr

0000d610 <os_mutex_release>:
 *      OS_BAD_MUTEX    Mutex was not granted to current task (not owner).
 *      OS_OK           No error
 */
os_error_t
os_mutex_release(struct os_mutex *mu)
{
    d610:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    os_sr_t sr;
    struct os_task *current;
    struct os_task *rdy;

    /* Check if OS is started */
    if (!g_os_started) {
    d612:	4b2d      	ldr	r3, [pc, #180]	; (d6c8 <os_mutex_release+0xb8>)
{
    d614:	0006      	movs	r6, r0
    if (!g_os_started) {
    d616:	681b      	ldr	r3, [r3, #0]
    d618:	2b00      	cmp	r3, #0
    d61a:	d04f      	beq.n	d6bc <os_mutex_release+0xac>
        return (OS_NOT_STARTED);
    }

    /* Check for valid mutex */
    if (!mu) {
    d61c:	2800      	cmp	r0, #0
    d61e:	d04f      	beq.n	d6c0 <os_mutex_release+0xb0>
        return OS_INVALID_PARM;
    }

    /* We better own this mutex! */
    current = os_sched_get_current_task();
    d620:	f7ff fcda 	bl	cfd8 <os_sched_get_current_task>
    if ((mu->mu_level == 0) || (mu->mu_owner != current)) {
    d624:	88f3      	ldrh	r3, [r6, #6]
    d626:	2b00      	cmp	r3, #0
    d628:	d04c      	beq.n	d6c4 <os_mutex_release+0xb4>
    d62a:	68b5      	ldr	r5, [r6, #8]
        return (OS_BAD_MUTEX);
    d62c:	2205      	movs	r2, #5
    if ((mu->mu_level == 0) || (mu->mu_owner != current)) {
    d62e:	4285      	cmp	r5, r0
    d630:	d105      	bne.n	d63e <os_mutex_release+0x2e>
    }

    /* Decrement nesting level by 1. If not zero, nested (so dont release!) */
    --mu->mu_level;
    d632:	3b01      	subs	r3, #1
    d634:	b29b      	uxth	r3, r3
    d636:	80f3      	strh	r3, [r6, #6]
    if (mu->mu_level != 0) {
    d638:	2b00      	cmp	r3, #0
    d63a:	d002      	beq.n	d642 <os_mutex_release+0x32>
    if (resched) {
        os_sched(rdy);
    }
    os_trace_end_call(OS_TRACE_ID_MUTEX_RELEASE);

    return OS_OK;
    d63c:	2200      	movs	r2, #0
}
    d63e:	0010      	movs	r0, r2
    d640:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    OS_ENTER_CRITICAL(sr);
    d642:	f7ff fea5 	bl	d390 <os_arch_save_sr>
    if (current->t_prio != mu->mu_prio) {
    d646:	7973      	ldrb	r3, [r6, #5]
    d648:	7aea      	ldrb	r2, [r5, #11]
    OS_ENTER_CRITICAL(sr);
    d64a:	0007      	movs	r7, r0
    if (current->t_prio != mu->mu_prio) {
    d64c:	429a      	cmp	r2, r3
    d64e:	d003      	beq.n	d658 <os_mutex_release+0x48>
        current->t_prio = mu->mu_prio;
    d650:	72eb      	strb	r3, [r5, #11]
        os_sched_resort(current);
    d652:	0028      	movs	r0, r5
    d654:	f7ff fd90 	bl	d178 <os_sched_resort>
    rdy = SLIST_FIRST(&mu->mu_head);
    d658:	6834      	ldr	r4, [r6, #0]
    if (rdy) {
    d65a:	2c00      	cmp	r4, #0
    d65c:	d00e      	beq.n	d67c <os_mutex_release+0x6c>
        assert(rdy->t_obj);
    d65e:	69e0      	ldr	r0, [r4, #28]
    d660:	2800      	cmp	r0, #0
    d662:	d104      	bne.n	d66e <os_mutex_release+0x5e>
    d664:	0003      	movs	r3, r0
    d666:	0002      	movs	r2, r0
    d668:	0001      	movs	r1, r0
    d66a:	f7ff f965 	bl	c938 <__assert_func>
        os_sched_wakeup(rdy);
    d66e:	0020      	movs	r0, r4
    d670:	f7ff fd0c 	bl	d08c <os_sched_wakeup>
        mu->mu_level = 1;
    d674:	2301      	movs	r3, #1
    d676:	80f3      	strh	r3, [r6, #6]
        mu->mu_prio = rdy->t_prio;
    d678:	7ae3      	ldrb	r3, [r4, #11]
    d67a:	7173      	strb	r3, [r6, #5]
    mu->mu_owner = rdy;
    d67c:	60b4      	str	r4, [r6, #8]
    if (rdy) {
    d67e:	2c00      	cmp	r4, #0
    d680:	d006      	beq.n	d690 <os_mutex_release+0x80>
        rdy->t_lockcnt++;
    d682:	7ba3      	ldrb	r3, [r4, #14]
        rdy->t_flags |= OS_TASK_FLAG_LOCK_HELD;
    d684:	7b62      	ldrb	r2, [r4, #13]
        rdy->t_lockcnt++;
    d686:	3301      	adds	r3, #1
    d688:	73a3      	strb	r3, [r4, #14]
        rdy->t_flags |= OS_TASK_FLAG_LOCK_HELD;
    d68a:	2310      	movs	r3, #16
    d68c:	4313      	orrs	r3, r2
    d68e:	7363      	strb	r3, [r4, #13]
    if (--current->t_lockcnt == 0) {
    d690:	7bab      	ldrb	r3, [r5, #14]
    d692:	3b01      	subs	r3, #1
    d694:	b2db      	uxtb	r3, r3
    d696:	73ab      	strb	r3, [r5, #14]
    d698:	2b00      	cmp	r3, #0
    d69a:	d103      	bne.n	d6a4 <os_mutex_release+0x94>
        current->t_flags &= ~OS_TASK_FLAG_LOCK_HELD;
    d69c:	2210      	movs	r2, #16
    d69e:	7b6b      	ldrb	r3, [r5, #13]
    d6a0:	4393      	bics	r3, r2
    d6a2:	736b      	strb	r3, [r5, #13]
    rdy = os_sched_next_task();
    d6a4:	f7ff fd62 	bl	d16c <os_sched_next_task>
    d6a8:	0004      	movs	r4, r0
    OS_EXIT_CRITICAL(sr);
    d6aa:	0038      	movs	r0, r7
    d6ac:	f7ff fe76 	bl	d39c <os_arch_restore_sr>
    if (resched) {
    d6b0:	42a5      	cmp	r5, r4
    d6b2:	d0c3      	beq.n	d63c <os_mutex_release+0x2c>
        os_sched(rdy);
    d6b4:	0020      	movs	r0, r4
    d6b6:	f7ff fc9b 	bl	cff0 <os_sched>
    d6ba:	e7bf      	b.n	d63c <os_mutex_release+0x2c>
        return (OS_NOT_STARTED);
    d6bc:	2209      	movs	r2, #9
    d6be:	e7be      	b.n	d63e <os_mutex_release+0x2e>
        return OS_INVALID_PARM;
    d6c0:	2203      	movs	r2, #3
    d6c2:	e7bc      	b.n	d63e <os_mutex_release+0x2e>
        return (OS_BAD_MUTEX);
    d6c4:	2205      	movs	r2, #5
    d6c6:	e7ba      	b.n	d63e <os_mutex_release+0x2e>
    d6c8:	2000249c 	.word	0x2000249c

0000d6cc <os_mutex_pend>:
 *      OS_TIMEOUT          Mutex was owned by another task and timeout=0
 *      OS_OK               no error.
 */
os_error_t
os_mutex_pend(struct os_mutex *mu, uint32_t timeout)
{
    d6cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    struct os_task *current;
    struct os_task *entry;
    struct os_task *last;

    /* OS must be started when calling this function */
    if (!g_os_started) {
    d6ce:	4b36      	ldr	r3, [pc, #216]	; (d7a8 <os_mutex_pend+0xdc>)
{
    d6d0:	0006      	movs	r6, r0
    if (!g_os_started) {
    d6d2:	681b      	ldr	r3, [r3, #0]
{
    d6d4:	9101      	str	r1, [sp, #4]
        return (OS_NOT_STARTED);
    d6d6:	2009      	movs	r0, #9
    if (!g_os_started) {
    d6d8:	2b00      	cmp	r3, #0
    d6da:	d01b      	beq.n	d714 <os_mutex_pend+0x48>
    }

    /* Check for valid mutex */
    if (!mu) {
        return OS_INVALID_PARM;
    d6dc:	3806      	subs	r0, #6
    if (!mu) {
    d6de:	2e00      	cmp	r6, #0
    d6e0:	d018      	beq.n	d714 <os_mutex_pend+0x48>
    }

    OS_ENTER_CRITICAL(sr);
    d6e2:	f7ff fe55 	bl	d390 <os_arch_save_sr>
    d6e6:	0007      	movs	r7, r0

    /* Is this owned? */
    current = os_sched_get_current_task();
    d6e8:	f7ff fc76 	bl	cfd8 <os_sched_get_current_task>
    if (mu->mu_level == 0) {
    d6ec:	88f5      	ldrh	r5, [r6, #6]
    current = os_sched_get_current_task();
    d6ee:	0004      	movs	r4, r0
    if (mu->mu_level == 0) {
    d6f0:	2d00      	cmp	r5, #0
    d6f2:	d110      	bne.n	d716 <os_mutex_pend+0x4a>
        mu->mu_owner = current;
    d6f4:	60b0      	str	r0, [r6, #8]
        mu->mu_prio  = current->t_prio;
    d6f6:	7ac3      	ldrb	r3, [r0, #11]
    d6f8:	7173      	strb	r3, [r6, #5]
        current->t_lockcnt++;
    d6fa:	7b83      	ldrb	r3, [r0, #14]
        current->t_flags |= OS_TASK_FLAG_LOCK_HELD;
    d6fc:	7b42      	ldrb	r2, [r0, #13]
        current->t_lockcnt++;
    d6fe:	3301      	adds	r3, #1
    d700:	7383      	strb	r3, [r0, #14]
        current->t_flags |= OS_TASK_FLAG_LOCK_HELD;
    d702:	2310      	movs	r3, #16
    d704:	4313      	orrs	r3, r2
    d706:	7343      	strb	r3, [r0, #13]
        mu->mu_level = 1;
    d708:	2301      	movs	r3, #1
    d70a:	80f3      	strh	r3, [r6, #6]
    }

    /* Are we owner? */
    if (mu->mu_owner == current) {
        ++mu->mu_level;
        OS_EXIT_CRITICAL(sr);
    d70c:	0038      	movs	r0, r7
    d70e:	f7ff fe45 	bl	d39c <os_arch_restore_sr>
        return OS_OK;
    d712:	2000      	movs	r0, #0
        rc = OS_TIMEOUT;
    }
    os_trace_end_call(OS_TRACE_ID_MUTEX_PEND);

    return rc;
}
    d714:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if (mu->mu_owner == current) {
    d716:	68b0      	ldr	r0, [r6, #8]
    d718:	42a0      	cmp	r0, r4
    d71a:	d102      	bne.n	d722 <os_mutex_pend+0x56>
        ++mu->mu_level;
    d71c:	3501      	adds	r5, #1
    d71e:	80f5      	strh	r5, [r6, #6]
    d720:	e7f4      	b.n	d70c <os_mutex_pend+0x40>
    if (timeout == 0) {
    d722:	9b01      	ldr	r3, [sp, #4]
    d724:	2b00      	cmp	r3, #0
    d726:	d104      	bne.n	d732 <os_mutex_pend+0x66>
        OS_EXIT_CRITICAL(sr);
    d728:	0038      	movs	r0, r7
    d72a:	f7ff fe37 	bl	d39c <os_arch_restore_sr>
        return OS_TIMEOUT;
    d72e:	2006      	movs	r0, #6
    d730:	e7f0      	b.n	d714 <os_mutex_pend+0x48>
    if (mu->mu_owner->t_prio > current->t_prio) {
    d732:	7ae3      	ldrb	r3, [r4, #11]
    d734:	7ac2      	ldrb	r2, [r0, #11]
    d736:	429a      	cmp	r2, r3
    d738:	d902      	bls.n	d740 <os_mutex_pend+0x74>
        mu->mu_owner->t_prio = current->t_prio;
    d73a:	72c3      	strb	r3, [r0, #11]
        os_sched_resort(mu->mu_owner);
    d73c:	f7ff fd1c 	bl	d178 <os_sched_resort>
    if (!SLIST_EMPTY(&mu->mu_head)) {
    d740:	6831      	ldr	r1, [r6, #0]
    d742:	2900      	cmp	r1, #0
    d744:	d02c      	beq.n	d7a0 <os_mutex_pend+0xd4>
            if (current->t_prio < entry->t_prio) {
    d746:	000a      	movs	r2, r1
    last = NULL;
    d748:	2300      	movs	r3, #0
            if (current->t_prio < entry->t_prio) {
    d74a:	7ae5      	ldrb	r5, [r4, #11]
    d74c:	7ad0      	ldrb	r0, [r2, #11]
    d74e:	42a8      	cmp	r0, r5
    d750:	d824      	bhi.n	d79c <os_mutex_pend+0xd0>
        SLIST_FOREACH(entry, &mu->mu_head, t_obj_list) {
    d752:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
    d754:	0013      	movs	r3, r2
    d756:	2800      	cmp	r0, #0
    d758:	d11e      	bne.n	d798 <os_mutex_pend+0xcc>
        SLIST_INSERT_AFTER(last, current, t_obj_list);
    d75a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    d75c:	64e2      	str	r2, [r4, #76]	; 0x4c
    d75e:	64dc      	str	r4, [r3, #76]	; 0x4c
    current->t_flags |= OS_TASK_FLAG_MUTEX_WAIT;
    d760:	2504      	movs	r5, #4
    d762:	7b63      	ldrb	r3, [r4, #13]
    os_sched_sleep(current, timeout);
    d764:	9901      	ldr	r1, [sp, #4]
    current->t_flags |= OS_TASK_FLAG_MUTEX_WAIT;
    d766:	432b      	orrs	r3, r5
    d768:	7363      	strb	r3, [r4, #13]
    current->t_obj = mu;
    d76a:	61e6      	str	r6, [r4, #28]
    os_sched_sleep(current, timeout);
    d76c:	0020      	movs	r0, r4
    d76e:	f7ff fc51 	bl	d014 <os_sched_sleep>
    OS_EXIT_CRITICAL(sr);
    d772:	0038      	movs	r0, r7
    d774:	f7ff fe12 	bl	d39c <os_arch_restore_sr>
    os_sched(NULL);
    d778:	2000      	movs	r0, #0
    d77a:	f7ff fc39 	bl	cff0 <os_sched>
    OS_ENTER_CRITICAL(sr);
    d77e:	f7ff fe07 	bl	d390 <os_arch_save_sr>
    current->t_flags &= ~OS_TASK_FLAG_MUTEX_WAIT;
    d782:	7b63      	ldrb	r3, [r4, #13]
    d784:	43ab      	bics	r3, r5
    d786:	7363      	strb	r3, [r4, #13]
    OS_EXIT_CRITICAL(sr);
    d788:	f7ff fe08 	bl	d39c <os_arch_restore_sr>
    if (mu->mu_owner == current) {
    d78c:	68b3      	ldr	r3, [r6, #8]
        rc = OS_OK;
    d78e:	2000      	movs	r0, #0
    if (mu->mu_owner == current) {
    d790:	42a3      	cmp	r3, r4
    d792:	d0bf      	beq.n	d714 <os_mutex_pend+0x48>
        rc = OS_TIMEOUT;
    d794:	3006      	adds	r0, #6
    d796:	e7bd      	b.n	d714 <os_mutex_pend+0x48>
    d798:	0002      	movs	r2, r0
    d79a:	e7d7      	b.n	d74c <os_mutex_pend+0x80>
    if (last) {
    d79c:	2b00      	cmp	r3, #0
    d79e:	d1dc      	bne.n	d75a <os_mutex_pend+0x8e>
        SLIST_INSERT_HEAD(&mu->mu_head, current, t_obj_list);
    d7a0:	64e1      	str	r1, [r4, #76]	; 0x4c
    d7a2:	6034      	str	r4, [r6, #0]
    d7a4:	e7dc      	b.n	d760 <os_mutex_pend+0x94>
    d7a6:	46c0      	nop			; (mov r8, r8)
    d7a8:	2000249c 	.word	0x2000249c

0000d7ac <os_set_env>:
    d7ac:	f380 8809 	msr	PSP, r0
    d7b0:	4838      	ldr	r0, [pc, #224]	; (d894 <using_msp_as_sp+0x22>)
    d7b2:	7800      	ldrb	r0, [r0, #0]
    d7b4:	3002      	adds	r0, #2
    d7b6:	f380 8814 	msr	CONTROL, r0
    d7ba:	f3bf 8f6f 	isb	sy
    d7be:	4770      	bx	lr

0000d7c0 <os_arch_init_task_stack>:
    d7c0:	4603      	mov	r3, r0
    d7c2:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    d7c4:	4644      	mov	r4, r8
    d7c6:	464d      	mov	r5, r9
    d7c8:	4656      	mov	r6, sl
    d7ca:	465f      	mov	r7, fp
    d7cc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    d7ce:	cbf0      	ldmia	r3!, {r4, r5, r6, r7}
    d7d0:	4770      	bx	lr

0000d7d2 <SVC_Handler>:
    d7d2:	f3ef 8009 	mrs	r0, PSP
    d7d6:	6981      	ldr	r1, [r0, #24]
    d7d8:	3902      	subs	r1, #2
    d7da:	7809      	ldrb	r1, [r1, #0]
    d7dc:	2900      	cmp	r1, #0
    d7de:	d108      	bne.n	d7f2 <SVC_User>
    d7e0:	6901      	ldr	r1, [r0, #16]
    d7e2:	468c      	mov	ip, r1
    d7e4:	c80f      	ldmia	r0, {r0, r1, r2, r3}
    d7e6:	b500      	push	{lr}
    d7e8:	47e0      	blx	ip
    d7ea:	f3ef 8309 	mrs	r3, PSP
    d7ee:	c307      	stmia	r3!, {r0, r1, r2}
    d7f0:	bd00      	pop	{pc}

0000d7f2 <SVC_User>:
    d7f2:	b510      	push	{r4, lr}
    d7f4:	4a28      	ldr	r2, [pc, #160]	; (d898 <using_msp_as_sp+0x26>)
    d7f6:	6812      	ldr	r2, [r2, #0]
    d7f8:	4291      	cmp	r1, r2
    d7fa:	d809      	bhi.n	d810 <SVC_Done>
    d7fc:	4c27      	ldr	r4, [pc, #156]	; (d89c <using_msp_as_sp+0x2a>)
    d7fe:	0089      	lsls	r1, r1, #2
    d800:	5864      	ldr	r4, [r4, r1]
    d802:	46a6      	mov	lr, r4
    d804:	c81f      	ldmia	r0, {r0, r1, r2, r3, r4}
    d806:	46a4      	mov	ip, r4
    d808:	47f0      	blx	lr
    d80a:	f3ef 8409 	mrs	r4, PSP
    d80e:	c40f      	stmia	r4!, {r0, r1, r2, r3}

0000d810 <SVC_Done>:
    d810:	bd10      	pop	{r4, pc}

0000d812 <PendSV_Handler>:
    d812:	4b23      	ldr	r3, [pc, #140]	; (d8a0 <using_msp_as_sp+0x2e>)
    d814:	681a      	ldr	r2, [r3, #0]
    d816:	4b23      	ldr	r3, [pc, #140]	; (d8a4 <using_msp_as_sp+0x32>)
    d818:	6819      	ldr	r1, [r3, #0]
    d81a:	4291      	cmp	r1, r2
    d81c:	d100      	bne.n	d820 <context_switch>
    d81e:	4770      	bx	lr

0000d820 <context_switch>:
    d820:	f3ef 8009 	mrs	r0, PSP
    d824:	3820      	subs	r0, #32
    d826:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    d828:	4644      	mov	r4, r8
    d82a:	464d      	mov	r5, r9
    d82c:	4656      	mov	r6, sl
    d82e:	465f      	mov	r7, fp
    d830:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
    d832:	3820      	subs	r0, #32
    d834:	6008      	str	r0, [r1, #0]
    d836:	601a      	str	r2, [r3, #0]
    d838:	6810      	ldr	r0, [r2, #0]
    d83a:	3010      	adds	r0, #16
    d83c:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    d83e:	46a0      	mov	r8, r4
    d840:	46a9      	mov	r9, r5
    d842:	46b2      	mov	sl, r6
    d844:	46bb      	mov	fp, r7
    d846:	f380 8809 	msr	PSP, r0
    d84a:	3820      	subs	r0, #32
    d84c:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
    d84e:	4770      	bx	lr

0000d850 <SysTick_Handler>:
    d850:	b510      	push	{r4, lr}
    d852:	f7ff fd8d 	bl	d370 <timer_handler>
    d856:	bd10      	pop	{r4, pc}

0000d858 <__aeabi_idiv0>:
    d858:	b423      	push	{r0, r1, r5}
    d85a:	4813      	ldr	r0, [pc, #76]	; (d8a8 <using_msp_as_sp+0x36>)
    d85c:	21d5      	movs	r1, #213	; 0xd5
    d85e:	4d13      	ldr	r5, [pc, #76]	; (d8ac <using_msp_as_sp+0x3a>)
    d860:	4728      	bx	r5

0000d862 <os_default_irq_asm>:
    d862:	4670      	mov	r0, lr
    d864:	2104      	movs	r1, #4
    d866:	4208      	tst	r0, r1
    d868:	f3ef 8c08 	mrs	ip, MSP
    d86c:	d001      	beq.n	d872 <using_msp_as_sp>
    d86e:	f3ef 8c09 	mrs	ip, PSP

0000d872 <using_msp_as_sp>:
    d872:	4640      	mov	r0, r8
    d874:	4649      	mov	r1, r9
    d876:	4652      	mov	r2, sl
    d878:	465b      	mov	r3, fp
    d87a:	b50f      	push	{r0, r1, r2, r3, lr}
    d87c:	4663      	mov	r3, ip
    d87e:	b4f8      	push	{r3, r4, r5, r6, r7}
    d880:	4668      	mov	r0, sp
    d882:	f7ff f873 	bl	c96c <os_default_irq>
    d886:	bcf8      	pop	{r3, r4, r5, r6, r7}
    d888:	bc0f      	pop	{r0, r1, r2, r3}
    d88a:	4680      	mov	r8, r0
    d88c:	4689      	mov	r9, r1
    d88e:	4692      	mov	sl, r2
    d890:	469b      	mov	fp, r3
    d892:	bd00      	pop	{pc}
    d894:	20001fc8 	.word	0x20001fc8
    d898:	00000000 	.word	0x00000000
    d89c:	fffffffc 	.word	0xfffffffc
    d8a0:	200000b8 	.word	0x200000b8
    d8a4:	200024b4 	.word	0x200024b4
    d8a8:	00010907 	.word	0x00010907
    d8ac:	0000c939 	.word	0x0000c939

0000d8b0 <memset>:

#include <string.h>
#include <stdint.h>

void *memset(void *dst, int c, size_t n)
{
    d8b0:	0003      	movs	r3, r0
    d8b2:	1812      	adds	r2, r2, r0
	asm volatile ("cld ; rep ; stosq ; movl %3,%%ecx ; rep ; stosb"
		      :"+c" (nq), "+D" (q)
		      : "a" ((unsigned char)c * 0x0101010101010101U),
			"r" ((uint32_t) n & 7));
#else
	while (n--) {
    d8b4:	4293      	cmp	r3, r2
    d8b6:	d100      	bne.n	d8ba <memset+0xa>
		*q++ = c;
	}
#endif

	return dst;
}
    d8b8:	4770      	bx	lr
		*q++ = c;
    d8ba:	7019      	strb	r1, [r3, #0]
    d8bc:	3301      	adds	r3, #1
    d8be:	e7f9      	b.n	d8b4 <memset+0x4>

0000d8c0 <strcmp>:
 */

#include <string.h>

int strcmp(const char *s1, const char *s2)
{
    d8c0:	2200      	movs	r2, #0
    d8c2:	b510      	push	{r4, lr}
	const unsigned char *c2 = (const unsigned char *)s2;
	unsigned char ch;
	int d = 0;

	while (1) {
		d = (int)(ch = *c1++) - (int)*c2++;
    d8c4:	5c84      	ldrb	r4, [r0, r2]
    d8c6:	5c8b      	ldrb	r3, [r1, r2]
    d8c8:	1ae3      	subs	r3, r4, r3
		if (d || !ch)
    d8ca:	d102      	bne.n	d8d2 <strcmp+0x12>
    d8cc:	3201      	adds	r2, #1
    d8ce:	2c00      	cmp	r4, #0
    d8d0:	d1f8      	bne.n	d8c4 <strcmp+0x4>
			break;
	}

	return d;
}
    d8d2:	0018      	movs	r0, r3
    d8d4:	bd10      	pop	{r4, pc}

0000d8d6 <cursor_save>:
    console_printf("\x1b[%uD", count);
}

static inline void
cursor_save(void)
{
    d8d6:	b510      	push	{r4, lr}
    console_out(ESC);
    d8d8:	201b      	movs	r0, #27
    d8da:	f000 fb2b 	bl	df34 <console_out>
    console_out('[');
    d8de:	205b      	movs	r0, #91	; 0x5b
    d8e0:	f000 fb28 	bl	df34 <console_out>
    console_out('s');
    d8e4:	2073      	movs	r0, #115	; 0x73
    d8e6:	f000 fb25 	bl	df34 <console_out>
}
    d8ea:	bd10      	pop	{r4, pc}

0000d8ec <cursor_restore>:

static inline void
cursor_restore(void)
{
    d8ec:	b510      	push	{r4, lr}
    console_out(ESC);
    d8ee:	201b      	movs	r0, #27
    d8f0:	f000 fb20 	bl	df34 <console_out>
    console_out('[');
    d8f4:	205b      	movs	r0, #91	; 0x5b
    d8f6:	f000 fb1d 	bl	df34 <console_out>
    console_out('u');
    d8fa:	2075      	movs	r0, #117	; 0x75
    d8fc:	f000 fb1a 	bl	df34 <console_out>
}
    d900:	bd10      	pop	{r4, pc}
	...

0000d904 <console_append_char>:
    }
}

static int
console_append_char(char *line, uint8_t byte)
{
    d904:	b510      	push	{r4, lr}
    if (cur + end >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    d906:	4a0c      	ldr	r2, [pc, #48]	; (d938 <console_append_char+0x34>)
    d908:	4c0c      	ldr	r4, [pc, #48]	; (d93c <console_append_char+0x38>)
    d90a:	7812      	ldrb	r2, [r2, #0]
    d90c:	7823      	ldrb	r3, [r4, #0]
    d90e:	189b      	adds	r3, r3, r2
        return 0;
    d910:	2200      	movs	r2, #0
    if (cur + end >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    d912:	2bfe      	cmp	r3, #254	; 0xfe
    d914:	dc0e      	bgt.n	d934 <console_append_char+0x30>
    }

    line[cur + end] = byte;
    d916:	54c1      	strb	r1, [r0, r3]

    if (byte == '\0') {
        return 1;
    d918:	3201      	adds	r2, #1
    if (byte == '\0') {
    d91a:	2900      	cmp	r1, #0
    d91c:	d00a      	beq.n	d934 <console_append_char+0x30>
    }

    if (echo) {
    d91e:	4b08      	ldr	r3, [pc, #32]	; (d940 <console_append_char+0x3c>)
    d920:	681b      	ldr	r3, [r3, #0]
    d922:	2b00      	cmp	r3, #0
    d924:	d002      	beq.n	d92c <console_append_char+0x28>
        /* Echo back to console */
        console_out(byte);
    d926:	0008      	movs	r0, r1
    d928:	f000 fb04 	bl	df34 <console_out>
    }
    ++cur;
    d92c:	2201      	movs	r2, #1
    d92e:	7823      	ldrb	r3, [r4, #0]
    d930:	3301      	adds	r3, #1
    d932:	7023      	strb	r3, [r4, #0]
    return 1;
}
    d934:	0010      	movs	r0, r2
    d936:	bd10      	pop	{r4, pc}
    d938:	20001fe1 	.word	0x20001fe1
    d93c:	20001fe0 	.word	0x20001fe0
    d940:	200000d8 	.word	0x200000d8

0000d944 <del_char>:
{
    d944:	b570      	push	{r4, r5, r6, lr}
    d946:	0004      	movs	r4, r0
    console_out('\b');
    d948:	2008      	movs	r0, #8
{
    d94a:	000d      	movs	r5, r1
    console_out('\b');
    d94c:	f000 faf2 	bl	df34 <console_out>
    if (end == 0) {
    d950:	2d00      	cmp	r5, #0
    d952:	d106      	bne.n	d962 <del_char+0x1e>
        console_out(' ');
    d954:	2020      	movs	r0, #32
    d956:	f000 faed 	bl	df34 <console_out>
        console_out('\b');
    d95a:	2008      	movs	r0, #8
    d95c:	f000 faea 	bl	df34 <console_out>
}
    d960:	bd70      	pop	{r4, r5, r6, pc}
    cursor_save();
    d962:	f7ff ffb8 	bl	d8d6 <cursor_save>
    d966:	1965      	adds	r5, r4, r5
    while (end-- > 0) {
    d968:	42ac      	cmp	r4, r5
    d96a:	d105      	bne.n	d978 <del_char+0x34>
    console_out(' ');
    d96c:	2020      	movs	r0, #32
    d96e:	f000 fae1 	bl	df34 <console_out>
    cursor_restore();
    d972:	f7ff ffbb 	bl	d8ec <cursor_restore>
    d976:	e7f3      	b.n	d960 <del_char+0x1c>
        *pos = *(pos + 1);
    d978:	7860      	ldrb	r0, [r4, #1]
    d97a:	7020      	strb	r0, [r4, #0]
        console_out(*(pos++));
    d97c:	3401      	adds	r4, #1
    d97e:	f000 fad9 	bl	df34 <console_out>
    d982:	e7f1      	b.n	d968 <del_char+0x24>

0000d984 <insert_char>:
{
    d984:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (cur + end >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    d986:	4e15      	ldr	r6, [pc, #84]	; (d9dc <insert_char+0x58>)
{
    d988:	0004      	movs	r4, r0
    if (cur + end >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    d98a:	7833      	ldrb	r3, [r6, #0]
{
    d98c:	000f      	movs	r7, r1
    if (cur + end >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    d98e:	189b      	adds	r3, r3, r2
{
    d990:	0015      	movs	r5, r2
    if (cur + end >= MYNEWT_VAL(CONSOLE_MAX_INPUT_LEN) - 1) {
    d992:	2bfe      	cmp	r3, #254	; 0xfe
    d994:	dc0c      	bgt.n	d9b0 <insert_char+0x2c>
    if (echo) {
    d996:	4b12      	ldr	r3, [pc, #72]	; (d9e0 <insert_char+0x5c>)
    d998:	681b      	ldr	r3, [r3, #0]
    d99a:	2b00      	cmp	r3, #0
    d99c:	d002      	beq.n	d9a4 <insert_char+0x20>
        console_out(c);
    d99e:	0008      	movs	r0, r1
    d9a0:	f000 fac8 	bl	df34 <console_out>
    ++cur;
    d9a4:	7833      	ldrb	r3, [r6, #0]
    d9a6:	3301      	adds	r3, #1
    d9a8:	7033      	strb	r3, [r6, #0]
    if (end == 0) {
    d9aa:	2d00      	cmp	r5, #0
    d9ac:	d101      	bne.n	d9b2 <insert_char+0x2e>
        *pos = c;
    d9ae:	7027      	strb	r7, [r4, #0]
}
    d9b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    tmp = *pos;
    d9b2:	7826      	ldrb	r6, [r4, #0]
    *(pos++) = c;
    d9b4:	7027      	strb	r7, [r4, #0]
    cursor_save();
    d9b6:	f7ff ff8e 	bl	d8d6 <cursor_save>
    *(pos++) = c;
    d9ba:	3401      	adds	r4, #1
    while (end-- > 0) {
    d9bc:	3d01      	subs	r5, #1
    d9be:	b2ed      	uxtb	r5, r5
    d9c0:	2dff      	cmp	r5, #255	; 0xff
    d9c2:	d102      	bne.n	d9ca <insert_char+0x46>
    cursor_restore();
    d9c4:	f7ff ff92 	bl	d8ec <cursor_restore>
    d9c8:	e7f2      	b.n	d9b0 <insert_char+0x2c>
        console_out(tmp);
    d9ca:	0030      	movs	r0, r6
    d9cc:	f000 fab2 	bl	df34 <console_out>
        c = *pos;
    d9d0:	7823      	ldrb	r3, [r4, #0]
        *(pos++) = tmp;
    d9d2:	7026      	strb	r6, [r4, #0]
    d9d4:	3401      	adds	r4, #1
        tmp = c;
    d9d6:	001e      	movs	r6, r3
    d9d8:	e7f0      	b.n	d9bc <insert_char+0x38>
    d9da:	46c0      	nop			; (mov r8, r8)
    d9dc:	20001fe0 	.word	0x20001fe0
    d9e0:	200000d8 	.word	0x200000d8

0000d9e4 <handle_ansi>:
    if (esc_state & ESC_ANSI_FIRST) {
    d9e4:	2204      	movs	r2, #4
{
    d9e6:	b570      	push	{r4, r5, r6, lr}
    if (esc_state & ESC_ANSI_FIRST) {
    d9e8:	4c47      	ldr	r4, [pc, #284]	; (db08 <handle_ansi+0x124>)
{
    d9ea:	000d      	movs	r5, r1
    if (esc_state & ESC_ANSI_FIRST) {
    d9ec:	6823      	ldr	r3, [r4, #0]
    d9ee:	4213      	tst	r3, r2
    d9f0:	d01d      	beq.n	da2e <handle_ansi+0x4a>
        if (!isdigit(byte)) {
    d9f2:	0006      	movs	r6, r0
        esc_state &= ~ESC_ANSI_FIRST;
    d9f4:	4393      	bics	r3, r2
        if (!isdigit(byte)) {
    d9f6:	3e30      	subs	r6, #48	; 0x30
        esc_state &= ~ESC_ANSI_FIRST;
    d9f8:	6023      	str	r3, [r4, #0]
    d9fa:	4944      	ldr	r1, [pc, #272]	; (db0c <handle_ansi+0x128>)
        if (!isdigit(byte)) {
    d9fc:	2e09      	cmp	r6, #9
    d9fe:	d90e      	bls.n	da1e <handle_ansi+0x3a>
            ansi_val = 1;
    da00:	2301      	movs	r3, #1
    da02:	600b      	str	r3, [r1, #0]
    switch (byte) {
    da04:	2846      	cmp	r0, #70	; 0x46
    da06:	d100      	bne.n	da0a <handle_ansi+0x26>
    da08:	e074      	b.n	daf4 <handle_ansi+0x110>
    da0a:	d82e      	bhi.n	da6a <handle_ansi+0x86>
    da0c:	2843      	cmp	r0, #67	; 0x43
    da0e:	d053      	beq.n	dab8 <handle_ansi+0xd4>
    da10:	2844      	cmp	r0, #68	; 0x44
    da12:	d040      	beq.n	da96 <handle_ansi+0xb2>
    esc_state &= ~ESC_ANSI;
    da14:	2302      	movs	r3, #2
    da16:	6822      	ldr	r2, [r4, #0]
    da18:	439a      	bics	r2, r3
    da1a:	0013      	movs	r3, r2
    da1c:	e01f      	b.n	da5e <handle_ansi+0x7a>
        esc_state |= ESC_ANSI_VAL;
    da1e:	2208      	movs	r2, #8
    da20:	4313      	orrs	r3, r2
        ansi_val_2 = 0;
    da22:	2200      	movs	r2, #0
        esc_state |= ESC_ANSI_VAL;
    da24:	6023      	str	r3, [r4, #0]
        ansi_val_2 = 0;
    da26:	4b3a      	ldr	r3, [pc, #232]	; (db10 <handle_ansi+0x12c>)
        ansi_val = byte - '0';
    da28:	600e      	str	r6, [r1, #0]
        ansi_val_2 = 0;
    da2a:	601a      	str	r2, [r3, #0]
}
    da2c:	bd70      	pop	{r4, r5, r6, pc}
    if (esc_state & ESC_ANSI_VAL) {
    da2e:	071a      	lsls	r2, r3, #28
    da30:	d5e8      	bpl.n	da04 <handle_ansi+0x20>
        if (isdigit(byte)) {
    da32:	0002      	movs	r2, r0
    da34:	3a30      	subs	r2, #48	; 0x30
    da36:	2a09      	cmp	r2, #9
    da38:	d80b      	bhi.n	da52 <handle_ansi+0x6e>
    da3a:	210a      	movs	r1, #10
                ansi_val_2 += byte - '0';
    da3c:	4a34      	ldr	r2, [pc, #208]	; (db10 <handle_ansi+0x12c>)
            if (esc_state & ESC_ANSI_VAL_2) {
    da3e:	06db      	lsls	r3, r3, #27
    da40:	d400      	bmi.n	da44 <handle_ansi+0x60>
                ansi_val += byte - '0';
    da42:	4a32      	ldr	r2, [pc, #200]	; (db0c <handle_ansi+0x128>)
                ansi_val *= 10;
    da44:	6813      	ldr	r3, [r2, #0]
    da46:	4359      	muls	r1, r3
                ansi_val += byte - '0';
    da48:	000b      	movs	r3, r1
    da4a:	3b30      	subs	r3, #48	; 0x30
    da4c:	1818      	adds	r0, r3, r0
    da4e:	6010      	str	r0, [r2, #0]
    da50:	e7ec      	b.n	da2c <handle_ansi+0x48>
        if (byte == ';' && !(esc_state & ESC_ANSI_VAL_2)) {
    da52:	283b      	cmp	r0, #59	; 0x3b
    da54:	d105      	bne.n	da62 <handle_ansi+0x7e>
    da56:	2210      	movs	r2, #16
    da58:	4213      	tst	r3, r2
    da5a:	d102      	bne.n	da62 <handle_ansi+0x7e>
            esc_state |= ESC_ANSI_VAL_2;
    da5c:	4313      	orrs	r3, r2
    esc_state &= ~ESC_ANSI;
    da5e:	6023      	str	r3, [r4, #0]
    da60:	e7e4      	b.n	da2c <handle_ansi+0x48>
        esc_state &= ~ESC_ANSI_VAL_2;
    da62:	2218      	movs	r2, #24
    da64:	4393      	bics	r3, r2
    da66:	6023      	str	r3, [r4, #0]
    da68:	e7cc      	b.n	da04 <handle_ansi+0x20>
    switch (byte) {
    da6a:	2848      	cmp	r0, #72	; 0x48
    da6c:	d033      	beq.n	dad6 <handle_ansi+0xf2>
    da6e:	287e      	cmp	r0, #126	; 0x7e
    da70:	d1d0      	bne.n	da14 <handle_ansi+0x30>
        if (!end) {
    da72:	4e28      	ldr	r6, [pc, #160]	; (db14 <handle_ansi+0x130>)
    da74:	7833      	ldrb	r3, [r6, #0]
    da76:	2b00      	cmp	r3, #0
    da78:	d0cc      	beq.n	da14 <handle_ansi+0x30>
    console_printf("\x1b[%uC", count);
    da7a:	2101      	movs	r1, #1
    da7c:	4826      	ldr	r0, [pc, #152]	; (db18 <handle_ansi+0x134>)
    da7e:	f000 f9b1 	bl	dde4 <console_printf>
        del_char(&line[cur], --end);
    da82:	4b26      	ldr	r3, [pc, #152]	; (db1c <handle_ansi+0x138>)
    da84:	7831      	ldrb	r1, [r6, #0]
    da86:	7818      	ldrb	r0, [r3, #0]
    da88:	3901      	subs	r1, #1
    da8a:	b2c9      	uxtb	r1, r1
    da8c:	1828      	adds	r0, r5, r0
    da8e:	7031      	strb	r1, [r6, #0]
    da90:	f7ff ff58 	bl	d944 <del_char>
        break;
    da94:	e7be      	b.n	da14 <handle_ansi+0x30>
        if (ansi_val > cur) {
    da96:	4821      	ldr	r0, [pc, #132]	; (db1c <handle_ansi+0x138>)
    da98:	4a1c      	ldr	r2, [pc, #112]	; (db0c <handle_ansi+0x128>)
    da9a:	7803      	ldrb	r3, [r0, #0]
    da9c:	6811      	ldr	r1, [r2, #0]
    da9e:	428b      	cmp	r3, r1
    daa0:	d3b8      	bcc.n	da14 <handle_ansi+0x30>
        end += ansi_val;
    daa2:	4e1c      	ldr	r6, [pc, #112]	; (db14 <handle_ansi+0x130>)
    daa4:	b2cd      	uxtb	r5, r1
    daa6:	7832      	ldrb	r2, [r6, #0]
        cur -= ansi_val;
    daa8:	1b5b      	subs	r3, r3, r5
        end += ansi_val;
    daaa:	18aa      	adds	r2, r5, r2
        cur -= ansi_val;
    daac:	7003      	strb	r3, [r0, #0]
    console_printf("\x1b[%uD", count);
    daae:	481c      	ldr	r0, [pc, #112]	; (db20 <handle_ansi+0x13c>)
        end += ansi_val;
    dab0:	7032      	strb	r2, [r6, #0]
    console_printf("\x1b[%uC", count);
    dab2:	f000 f997 	bl	dde4 <console_printf>
    dab6:	e7ad      	b.n	da14 <handle_ansi+0x30>
        if (ansi_val > end) {
    dab8:	4816      	ldr	r0, [pc, #88]	; (db14 <handle_ansi+0x130>)
    daba:	4b14      	ldr	r3, [pc, #80]	; (db0c <handle_ansi+0x128>)
    dabc:	7802      	ldrb	r2, [r0, #0]
    dabe:	6819      	ldr	r1, [r3, #0]
    dac0:	428a      	cmp	r2, r1
    dac2:	d3a7      	bcc.n	da14 <handle_ansi+0x30>
        end -= ansi_val;
    dac4:	b2cb      	uxtb	r3, r1
    dac6:	1ad2      	subs	r2, r2, r3
    dac8:	7002      	strb	r2, [r0, #0]
        cur += ansi_val;
    daca:	4a14      	ldr	r2, [pc, #80]	; (db1c <handle_ansi+0x138>)
    dacc:	7810      	ldrb	r0, [r2, #0]
    dace:	181b      	adds	r3, r3, r0
    dad0:	7013      	strb	r3, [r2, #0]
    console_printf("\x1b[%uC", count);
    dad2:	4811      	ldr	r0, [pc, #68]	; (db18 <handle_ansi+0x134>)
    dad4:	e7ed      	b.n	dab2 <handle_ansi+0xce>
        if (!cur) {
    dad6:	4d11      	ldr	r5, [pc, #68]	; (db1c <handle_ansi+0x138>)
    dad8:	7829      	ldrb	r1, [r5, #0]
    dada:	2900      	cmp	r1, #0
    dadc:	d09a      	beq.n	da14 <handle_ansi+0x30>
    console_printf("\x1b[%uD", count);
    dade:	4810      	ldr	r0, [pc, #64]	; (db20 <handle_ansi+0x13c>)
    dae0:	f000 f980 	bl	dde4 <console_printf>
        end += cur;
    dae4:	4a0b      	ldr	r2, [pc, #44]	; (db14 <handle_ansi+0x130>)
        cur += end;
    dae6:	7813      	ldrb	r3, [r2, #0]
    dae8:	7829      	ldrb	r1, [r5, #0]
    daea:	185b      	adds	r3, r3, r1
    daec:	7013      	strb	r3, [r2, #0]
        end = 0;
    daee:	2300      	movs	r3, #0
    daf0:	702b      	strb	r3, [r5, #0]
        break;
    daf2:	e78f      	b.n	da14 <handle_ansi+0x30>
        if (!end) {
    daf4:	4d07      	ldr	r5, [pc, #28]	; (db14 <handle_ansi+0x130>)
    daf6:	7829      	ldrb	r1, [r5, #0]
    daf8:	2900      	cmp	r1, #0
    dafa:	d100      	bne.n	dafe <handle_ansi+0x11a>
    dafc:	e78a      	b.n	da14 <handle_ansi+0x30>
    console_printf("\x1b[%uC", count);
    dafe:	4806      	ldr	r0, [pc, #24]	; (db18 <handle_ansi+0x134>)
    db00:	f000 f970 	bl	dde4 <console_printf>
        cur += end;
    db04:	4a05      	ldr	r2, [pc, #20]	; (db1c <handle_ansi+0x138>)
    db06:	e7ee      	b.n	dae6 <handle_ansi+0x102>
    db08:	20001fe4 	.word	0x20001fe4
    db0c:	20001fcc 	.word	0x20001fcc
    db10:	20001fd0 	.word	0x20001fd0
    db14:	20001fe1 	.word	0x20001fe1
    db18:	00010950 	.word	0x00010950
    db1c:	20001fe0 	.word	0x20001fe0
    db20:	0001094a 	.word	0x0001094a

0000db24 <console_write>:
{
    db24:	b570      	push	{r4, r5, r6, lr}
    db26:	0005      	movs	r5, r0
    db28:	000e      	movs	r6, r1
    for (i = 0; i < cnt; i++) {
    db2a:	0004      	movs	r4, r0
    db2c:	1b63      	subs	r3, r4, r5
    db2e:	429e      	cmp	r6, r3
    db30:	dd05      	ble.n	db3e <console_write+0x1a>
        if (console_out((int)str[i]) == EOF) {
    db32:	7820      	ldrb	r0, [r4, #0]
    db34:	f000 f9fe 	bl	df34 <console_out>
    db38:	3401      	adds	r4, #1
    db3a:	1c43      	adds	r3, r0, #1
    db3c:	d1f6      	bne.n	db2c <console_write+0x8>
}
    db3e:	bd70      	pop	{r4, r5, r6, pc}

0000db40 <console_blocking_mode>:
{
    db40:	b510      	push	{r4, lr}
    uart_console_blocking_mode();
    db42:	f000 f9bd 	bl	dec0 <uart_console_blocking_mode>
}
    db46:	bd10      	pop	{r4, pc}

0000db48 <console_handle_char>:

    static struct os_event *ev;
    static struct console_input *input;
    static char prev_endl = '\0';

    if (!avail_queue || !lines_queue) {
    db48:	4b8b      	ldr	r3, [pc, #556]	; (dd78 <console_handle_char+0x230>)
{
    db4a:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    db4c:	0004      	movs	r4, r0
    if (!avail_queue || !lines_queue) {
    db4e:	6818      	ldr	r0, [r3, #0]
    db50:	2800      	cmp	r0, #0
    db52:	d072      	beq.n	dc3a <console_handle_char+0xf2>
    db54:	4b89      	ldr	r3, [pc, #548]	; (dd7c <console_handle_char+0x234>)
    db56:	681b      	ldr	r3, [r3, #0]
    db58:	9301      	str	r3, [sp, #4]
    db5a:	2b00      	cmp	r3, #0
    db5c:	d06d      	beq.n	dc3a <console_handle_char+0xf2>
        return 0;
    }

    if (!ev) {
    db5e:	4b88      	ldr	r3, [pc, #544]	; (dd80 <console_handle_char+0x238>)
    db60:	681b      	ldr	r3, [r3, #0]
    db62:	9301      	str	r3, [sp, #4]
    db64:	2b00      	cmp	r3, #0
    db66:	d108      	bne.n	db7a <console_handle_char+0x32>
        ev = os_eventq_get_no_wait(avail_queue);
    db68:	f7ff f94b 	bl	ce02 <os_eventq_get_no_wait>
    db6c:	4b84      	ldr	r3, [pc, #528]	; (dd80 <console_handle_char+0x238>)
    db6e:	6018      	str	r0, [r3, #0]
        if (!ev)
    db70:	2800      	cmp	r0, #0
    db72:	d062      	beq.n	dc3a <console_handle_char+0xf2>
            return 0;
        input = ev->ev_arg;
    db74:	6882      	ldr	r2, [r0, #8]
    db76:	4b83      	ldr	r3, [pc, #524]	; (dd84 <console_handle_char+0x23c>)
    db78:	601a      	str	r2, [r3, #0]
    if (((nlip_state & NLIP_PKT_START1) &&
    db7a:	4d83      	ldr	r5, [pc, #524]	; (dd88 <console_handle_char+0x240>)
    db7c:	4e81      	ldr	r6, [pc, #516]	; (dd84 <console_handle_char+0x23c>)
    db7e:	682b      	ldr	r3, [r5, #0]
    db80:	43da      	mvns	r2, r3
    db82:	0792      	lsls	r2, r2, #30
    db84:	d035      	beq.n	dbf2 <console_handle_char+0xaa>
        ((nlip_state & NLIP_DATA_START1) &&
    db86:	220c      	movs	r2, #12
    db88:	401a      	ands	r2, r3
         (nlip_state & NLIP_PKT_START2)) ||
    db8a:	2a0c      	cmp	r2, #12
    db8c:	d031      	beq.n	dbf2 <console_handle_char+0xaa>
    if ((nlip_state & NLIP_PKT_START1) &&
    db8e:	07da      	lsls	r2, r3, #31
    db90:	d511      	bpl.n	dbb6 <console_handle_char+0x6e>
    db92:	2c09      	cmp	r4, #9
    db94:	d10f      	bne.n	dbb6 <console_handle_char+0x6e>
        nlip_state |= NLIP_PKT_START2;
    db96:	2202      	movs	r2, #2
    db98:	4313      	orrs	r3, r2
    db9a:	602b      	str	r3, [r5, #0]
    echo = on;
    db9c:	2200      	movs	r2, #0
            return 0;
        /* Ignore characters if there's no more buffer space */
        } else if (byte == CONSOLE_NLIP_PKT_START2) {
            /* Disable echo to not flood the UART */
            console_echo(0);
            insert_char(&input->line[cur], CONSOLE_NLIP_PKT_START1, end);
    db9e:	2106      	movs	r1, #6
    echo = on;
    dba0:	4b7a      	ldr	r3, [pc, #488]	; (dd8c <console_handle_char+0x244>)
    dba2:	601a      	str	r2, [r3, #0]
            insert_char(&input->line[cur], CONSOLE_NLIP_PKT_START1, end);
    dba4:	4b7a      	ldr	r3, [pc, #488]	; (dd90 <console_handle_char+0x248>)
    dba6:	781a      	ldrb	r2, [r3, #0]
    dba8:	4b7a      	ldr	r3, [pc, #488]	; (dd94 <console_handle_char+0x24c>)
    dbaa:	7818      	ldrb	r0, [r3, #0]
    dbac:	6833      	ldr	r3, [r6, #0]
    dbae:	1818      	adds	r0, r3, r0
        } else if (byte == CONSOLE_NLIP_DATA_START2) {
            /* Disable echo to not flood the UART */
            console_echo(0);
            insert_char(&input->line[cur], CONSOLE_NLIP_DATA_START1, end);
    dbb0:	f7ff fee8 	bl	d984 <insert_char>
    dbb4:	e047      	b.n	dc46 <console_handle_char+0xfe>
    } else if ((nlip_state & NLIP_DATA_START1) &&
    dbb6:	075a      	lsls	r2, r3, #29
    dbb8:	d50f      	bpl.n	dbda <console_handle_char+0x92>
    dbba:	2c14      	cmp	r4, #20
    dbbc:	d10d      	bne.n	dbda <console_handle_char+0x92>
        nlip_state |= NLIP_DATA_START2;
    dbbe:	2208      	movs	r2, #8
    dbc0:	4313      	orrs	r3, r2
    dbc2:	602b      	str	r3, [r5, #0]
    echo = on;
    dbc4:	2200      	movs	r2, #0
    dbc6:	4b71      	ldr	r3, [pc, #452]	; (dd8c <console_handle_char+0x244>)
            insert_char(&input->line[cur], CONSOLE_NLIP_DATA_START1, end);
    dbc8:	2104      	movs	r1, #4
    echo = on;
    dbca:	601a      	str	r2, [r3, #0]
            insert_char(&input->line[cur], CONSOLE_NLIP_DATA_START1, end);
    dbcc:	4b70      	ldr	r3, [pc, #448]	; (dd90 <console_handle_char+0x248>)
    dbce:	781a      	ldrb	r2, [r3, #0]
    dbd0:	4b70      	ldr	r3, [pc, #448]	; (dd94 <console_handle_char+0x24c>)
    dbd2:	7818      	ldrb	r0, [r3, #0]
    dbd4:	6833      	ldr	r3, [r6, #0]
    dbd6:	1818      	adds	r0, r3, r0
    dbd8:	e7ea      	b.n	dbb0 <console_handle_char+0x68>
        nlip_state = 0;
    dbda:	2300      	movs	r3, #0

        return 0;
    }

    /* Handle ANSI escape mode */
    if (esc_state & ESC_ANSI) {
    dbdc:	4f6e      	ldr	r7, [pc, #440]	; (dd98 <console_handle_char+0x250>)
        nlip_state = 0;
    dbde:	602b      	str	r3, [r5, #0]
    dbe0:	4a68      	ldr	r2, [pc, #416]	; (dd84 <console_handle_char+0x23c>)
    if (esc_state & ESC_ANSI) {
    dbe2:	683b      	ldr	r3, [r7, #0]
    dbe4:	6811      	ldr	r1, [r2, #0]
    dbe6:	079a      	lsls	r2, r3, #30
    dbe8:	d537      	bpl.n	dc5a <console_handle_char+0x112>
        handle_ansi(byte, input->line);
    dbea:	0020      	movs	r0, r4
    dbec:	f7ff fefa 	bl	d9e4 <handle_ansi>
        return 0;
    dbf0:	e023      	b.n	dc3a <console_handle_char+0xf2>
        if (byte == '\n') {
    dbf2:	2c0a      	cmp	r4, #10
    dbf4:	d123      	bne.n	dc3e <console_handle_char+0xf6>
            insert_char(&input->line[cur], byte, end);
    dbf6:	0021      	movs	r1, r4
            input->line[cur] = '\0';
    dbf8:	2400      	movs	r4, #0
            insert_char(&input->line[cur], byte, end);
    dbfa:	4d66      	ldr	r5, [pc, #408]	; (dd94 <console_handle_char+0x24c>)
    dbfc:	4f64      	ldr	r7, [pc, #400]	; (dd90 <console_handle_char+0x248>)
    dbfe:	6833      	ldr	r3, [r6, #0]
    dc00:	7828      	ldrb	r0, [r5, #0]
    dc02:	783a      	ldrb	r2, [r7, #0]
    dc04:	1818      	adds	r0, r3, r0
    dc06:	f7ff febd 	bl	d984 <insert_char>
            input->line[cur] = '\0';
    dc0a:	782b      	ldrb	r3, [r5, #0]
    dc0c:	6832      	ldr	r2, [r6, #0]
            cur = 0;
    dc0e:	702c      	strb	r4, [r5, #0]
            input->line[cur] = '\0';
    dc10:	54d4      	strb	r4, [r2, r3]
            os_eventq_put(lines_queue, ev);
    dc12:	4b5b      	ldr	r3, [pc, #364]	; (dd80 <console_handle_char+0x238>)
            end = 0;
    dc14:	703c      	strb	r4, [r7, #0]
            os_eventq_put(lines_queue, ev);
    dc16:	6819      	ldr	r1, [r3, #0]
    dc18:	4b58      	ldr	r3, [pc, #352]	; (dd7c <console_handle_char+0x234>)
    dc1a:	6818      	ldr	r0, [r3, #0]
    dc1c:	f7ff f8c8 	bl	cdb0 <os_eventq_put>
            nlip_state = 0;
    dc20:	4b59      	ldr	r3, [pc, #356]	; (dd88 <console_handle_char+0x240>)
    dc22:	601c      	str	r4, [r3, #0]
            if (console_compat_rx_cb) {
    dc24:	4b5d      	ldr	r3, [pc, #372]	; (dd9c <console_handle_char+0x254>)
    dc26:	681b      	ldr	r3, [r3, #0]
    dc28:	42a3      	cmp	r3, r4
    dc2a:	d000      	beq.n	dc2e <console_handle_char+0xe6>
                console_compat_rx_cb();
    dc2c:	4798      	blx	r3
    echo = on;
    dc2e:	2201      	movs	r2, #1
            ev = NULL;
    dc30:	4b53      	ldr	r3, [pc, #332]	; (dd80 <console_handle_char+0x238>)
            input = NULL;
    dc32:	6034      	str	r4, [r6, #0]
            ev = NULL;
    dc34:	601c      	str	r4, [r3, #0]
    echo = on;
    dc36:	4b55      	ldr	r3, [pc, #340]	; (dd8c <console_handle_char+0x244>)
    dc38:	601a      	str	r2, [r3, #0]
        return 0;
    }

    insert_char(&input->line[cur], byte, end);
    return 0;
}
    dc3a:	2000      	movs	r0, #0
    dc3c:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        } else if (byte == CONSOLE_NLIP_PKT_START2) {
    dc3e:	2c09      	cmp	r4, #9
    dc40:	d0ac      	beq.n	db9c <console_handle_char+0x54>
        } else if (byte == CONSOLE_NLIP_DATA_START2) {
    dc42:	2c14      	cmp	r4, #20
    dc44:	d0be      	beq.n	dbc4 <console_handle_char+0x7c>
        insert_char(&input->line[cur], byte, end);
    dc46:	4b52      	ldr	r3, [pc, #328]	; (dd90 <console_handle_char+0x248>)
    dc48:	6830      	ldr	r0, [r6, #0]
    dc4a:	781a      	ldrb	r2, [r3, #0]
    dc4c:	4b51      	ldr	r3, [pc, #324]	; (dd94 <console_handle_char+0x24c>)
    dc4e:	781b      	ldrb	r3, [r3, #0]
    dc50:	18c0      	adds	r0, r0, r3
    insert_char(&input->line[cur], byte, end);
    dc52:	0021      	movs	r1, r4
    dc54:	f7ff fe96 	bl	d984 <insert_char>
    return 0;
    dc58:	e7ef      	b.n	dc3a <console_handle_char+0xf2>
    if (esc_state & ESC_ESC) {
    dc5a:	2201      	movs	r2, #1
    dc5c:	4213      	tst	r3, r2
    dc5e:	d00b      	beq.n	dc78 <console_handle_char+0x130>
        esc_state &= ~ESC_ESC;
    dc60:	4393      	bics	r3, r2
        handle_ansi(byte, input->line);
    dc62:	0020      	movs	r0, r4
        esc_state &= ~ESC_ESC;
    dc64:	603b      	str	r3, [r7, #0]
        handle_ansi(byte, input->line);
    dc66:	f7ff febd 	bl	d9e4 <handle_ansi>
            esc_state |= ESC_ANSI_FIRST;
    dc6a:	2306      	movs	r3, #6
        switch (byte) {
    dc6c:	2c5b      	cmp	r4, #91	; 0x5b
    dc6e:	d1e4      	bne.n	dc3a <console_handle_char+0xf2>
            esc_state |= ESC_ESC;
    dc70:	683a      	ldr	r2, [r7, #0]
    dc72:	4313      	orrs	r3, r2
    dc74:	603b      	str	r3, [r7, #0]
            break;
    dc76:	e7e0      	b.n	dc3a <console_handle_char+0xf2>
	    (__c >= '{' && __c <= '~');
}

__extern_inline int isprint(int __c)
{
	return (__c >= 0x20 && __c <= 0x7e);
    dc78:	0023      	movs	r3, r4
    dc7a:	3b20      	subs	r3, #32
    if (!isprint(byte)) {
    dc7c:	2b5e      	cmp	r3, #94	; 0x5e
    dc7e:	d974      	bls.n	dd6a <console_handle_char+0x222>
        handle_ansi(byte, input->line);
    dc80:	0020      	movs	r0, r4
    dc82:	f7ff feaf 	bl	d9e4 <handle_ansi>
        switch (byte) {
    dc86:	2c09      	cmp	r4, #9
    dc88:	d05b      	beq.n	dd42 <console_handle_char+0x1fa>
    dc8a:	d831      	bhi.n	dcf0 <console_handle_char+0x1a8>
    dc8c:	2c06      	cmp	r4, #6
    dc8e:	d04f      	beq.n	dd30 <console_handle_char+0x1e8>
    dc90:	2c08      	cmp	r4, #8
    dc92:	d03d      	beq.n	dd10 <console_handle_char+0x1c8>
    dc94:	2c04      	cmp	r4, #4
    dc96:	d050      	beq.n	dd3a <console_handle_char+0x1f2>
            insert_char(&input->line[cur], byte, end);
    dc98:	4b3d      	ldr	r3, [pc, #244]	; (dd90 <console_handle_char+0x248>)
    dc9a:	493a      	ldr	r1, [pc, #232]	; (dd84 <console_handle_char+0x23c>)
    dc9c:	781a      	ldrb	r2, [r3, #0]
    dc9e:	4b3d      	ldr	r3, [pc, #244]	; (dd94 <console_handle_char+0x24c>)
    dca0:	6808      	ldr	r0, [r1, #0]
    dca2:	781b      	ldrb	r3, [r3, #0]
    dca4:	0021      	movs	r1, r4
    dca6:	18c0      	adds	r0, r0, r3
    dca8:	f7ff fe6c 	bl	d984 <insert_char>
            prev_endl = byte;
    dcac:	4b3c      	ldr	r3, [pc, #240]	; (dda0 <console_handle_char+0x258>)
            input->line[cur + end] = '\0';
    dcae:	4d38      	ldr	r5, [pc, #224]	; (dd90 <console_handle_char+0x248>)
            prev_endl = byte;
    dcb0:	701c      	strb	r4, [r3, #0]
            input->line[cur + end] = '\0';
    dcb2:	2400      	movs	r4, #0
    dcb4:	6833      	ldr	r3, [r6, #0]
    dcb6:	4e37      	ldr	r6, [pc, #220]	; (dd94 <console_handle_char+0x24c>)
    dcb8:	782a      	ldrb	r2, [r5, #0]
    dcba:	7831      	ldrb	r1, [r6, #0]
            console_out('\r');
    dcbc:	200d      	movs	r0, #13
            input->line[cur + end] = '\0';
    dcbe:	185b      	adds	r3, r3, r1
    dcc0:	549c      	strb	r4, [r3, r2]
            console_out('\r');
    dcc2:	f000 f937 	bl	df34 <console_out>
            console_out('\n');
    dcc6:	200a      	movs	r0, #10
    dcc8:	f000 f934 	bl	df34 <console_out>
            os_eventq_put(lines_queue, ev);
    dccc:	4b2c      	ldr	r3, [pc, #176]	; (dd80 <console_handle_char+0x238>)
            cur = 0;
    dcce:	7034      	strb	r4, [r6, #0]
            os_eventq_put(lines_queue, ev);
    dcd0:	6819      	ldr	r1, [r3, #0]
    dcd2:	4b2a      	ldr	r3, [pc, #168]	; (dd7c <console_handle_char+0x234>)
            end = 0;
    dcd4:	702c      	strb	r4, [r5, #0]
            os_eventq_put(lines_queue, ev);
    dcd6:	6818      	ldr	r0, [r3, #0]
    dcd8:	f7ff f86a 	bl	cdb0 <os_eventq_put>
            if (console_compat_rx_cb) {
    dcdc:	4b2f      	ldr	r3, [pc, #188]	; (dd9c <console_handle_char+0x254>)
    dcde:	681b      	ldr	r3, [r3, #0]
    dce0:	42a3      	cmp	r3, r4
    dce2:	d000      	beq.n	dce6 <console_handle_char+0x19e>
                console_compat_rx_cb();
    dce4:	4798      	blx	r3
            input = NULL;
    dce6:	4b27      	ldr	r3, [pc, #156]	; (dd84 <console_handle_char+0x23c>)
    dce8:	601c      	str	r4, [r3, #0]
            ev = NULL;
    dcea:	4b25      	ldr	r3, [pc, #148]	; (dd80 <console_handle_char+0x238>)
    dcec:	601c      	str	r4, [r3, #0]
            break;
    dcee:	e7a4      	b.n	dc3a <console_handle_char+0xf2>
        switch (byte) {
    dcf0:	2c0d      	cmp	r4, #13
    dcf2:	d0db      	beq.n	dcac <console_handle_char+0x164>
    dcf4:	d807      	bhi.n	dd06 <console_handle_char+0x1be>
    dcf6:	2c0a      	cmp	r4, #10
    dcf8:	d1ce      	bne.n	dc98 <console_handle_char+0x150>
            if (byte == '\n' && prev_endl == '\r') {
    dcfa:	4b29      	ldr	r3, [pc, #164]	; (dda0 <console_handle_char+0x258>)
    dcfc:	781a      	ldrb	r2, [r3, #0]
    dcfe:	2a0d      	cmp	r2, #13
    dd00:	d1d4      	bne.n	dcac <console_handle_char+0x164>
                prev_endl = byte;
    dd02:	701c      	strb	r4, [r3, #0]
                break;
    dd04:	e799      	b.n	dc3a <console_handle_char+0xf2>
            esc_state |= ESC_ESC;
    dd06:	2301      	movs	r3, #1
        switch (byte) {
    dd08:	2c1b      	cmp	r4, #27
    dd0a:	d0b1      	beq.n	dc70 <console_handle_char+0x128>
    dd0c:	2c7f      	cmp	r4, #127	; 0x7f
    dd0e:	d1c3      	bne.n	dc98 <console_handle_char+0x150>
            if (cur > 0) {
    dd10:	4920      	ldr	r1, [pc, #128]	; (dd94 <console_handle_char+0x24c>)
    dd12:	780b      	ldrb	r3, [r1, #0]
    dd14:	2b00      	cmp	r3, #0
    dd16:	d100      	bne.n	dd1a <console_handle_char+0x1d2>
    dd18:	e78f      	b.n	dc3a <console_handle_char+0xf2>
                del_char(&input->line[--cur], end);
    dd1a:	4a1a      	ldr	r2, [pc, #104]	; (dd84 <console_handle_char+0x23c>)
    dd1c:	3b01      	subs	r3, #1
    dd1e:	b2d8      	uxtb	r0, r3
    dd20:	6812      	ldr	r2, [r2, #0]
    dd22:	4b1b      	ldr	r3, [pc, #108]	; (dd90 <console_handle_char+0x248>)
    dd24:	7008      	strb	r0, [r1, #0]
    dd26:	7819      	ldrb	r1, [r3, #0]
    dd28:	1810      	adds	r0, r2, r0
    dd2a:	f7ff fe0b 	bl	d944 <del_char>
    dd2e:	e784      	b.n	dc3a <console_handle_char+0xf2>
            nlip_state |= NLIP_PKT_START1;
    dd30:	2301      	movs	r3, #1
    dd32:	682a      	ldr	r2, [r5, #0]
    dd34:	4313      	orrs	r3, r2
    dd36:	602b      	str	r3, [r5, #0]
            break;
    dd38:	e77f      	b.n	dc3a <console_handle_char+0xf2>
            nlip_state |= NLIP_DATA_START1;
    dd3a:	682b      	ldr	r3, [r5, #0]
    dd3c:	431c      	orrs	r4, r3
    dd3e:	602c      	str	r4, [r5, #0]
            break;
    dd40:	e77b      	b.n	dc3a <console_handle_char+0xf2>
            if (completion && !end) {
    dd42:	4c18      	ldr	r4, [pc, #96]	; (dda4 <console_handle_char+0x25c>)
    dd44:	6823      	ldr	r3, [r4, #0]
    dd46:	2b00      	cmp	r3, #0
    dd48:	d100      	bne.n	dd4c <console_handle_char+0x204>
    dd4a:	e776      	b.n	dc3a <console_handle_char+0xf2>
    dd4c:	4b10      	ldr	r3, [pc, #64]	; (dd90 <console_handle_char+0x248>)
    dd4e:	781b      	ldrb	r3, [r3, #0]
    dd50:	2b00      	cmp	r3, #0
    dd52:	d000      	beq.n	dd56 <console_handle_char+0x20e>
    dd54:	e771      	b.n	dc3a <console_handle_char+0xf2>
    uart_console_blocking_mode();
    dd56:	f000 f8b3 	bl	dec0 <uart_console_blocking_mode>
                completion(input->line, console_append_char);
    dd5a:	4a0a      	ldr	r2, [pc, #40]	; (dd84 <console_handle_char+0x23c>)
    dd5c:	6823      	ldr	r3, [r4, #0]
    dd5e:	4912      	ldr	r1, [pc, #72]	; (dda8 <console_handle_char+0x260>)
    dd60:	6810      	ldr	r0, [r2, #0]
    dd62:	4798      	blx	r3
    uart_console_non_blocking_mode();
    dd64:	f000 f8d6 	bl	df14 <uart_console_non_blocking_mode>
    dd68:	e767      	b.n	dc3a <console_handle_char+0xf2>
    insert_char(&input->line[cur], byte, end);
    dd6a:	4b09      	ldr	r3, [pc, #36]	; (dd90 <console_handle_char+0x248>)
    dd6c:	781a      	ldrb	r2, [r3, #0]
    dd6e:	4b09      	ldr	r3, [pc, #36]	; (dd94 <console_handle_char+0x24c>)
    dd70:	7818      	ldrb	r0, [r3, #0]
    dd72:	1808      	adds	r0, r1, r0
    dd74:	e76d      	b.n	dc52 <console_handle_char+0x10a>
    dd76:	46c0      	nop			; (mov r8, r8)
    dd78:	20001fd4 	.word	0x20001fd4
    dd7c:	20001ff0 	.word	0x20001ff0
    dd80:	20001fe8 	.word	0x20001fe8
    dd84:	20001fec 	.word	0x20001fec
    dd88:	20001ff4 	.word	0x20001ff4
    dd8c:	200000d8 	.word	0x200000d8
    dd90:	20001fe1 	.word	0x20001fe1
    dd94:	20001fe0 	.word	0x20001fe0
    dd98:	20001fe4 	.word	0x20001fe4
    dd9c:	20001fdc 	.word	0x20001fdc
    dda0:	20001ff8 	.word	0x20001ff8
    dda4:	20001fd8 	.word	0x20001fd8
    dda8:	0000d905 	.word	0x0000d905

0000ddac <console_pkg_init>:
}
#endif

void
console_pkg_init(void)
{
    ddac:	b513      	push	{r0, r1, r4, lr}
    int rc = 0;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
    ddae:	4b0b      	ldr	r3, [pc, #44]	; (dddc <console_pkg_init+0x30>)
    ddb0:	7818      	ldrb	r0, [r3, #0]
    ddb2:	2800      	cmp	r0, #0
    ddb4:	d104      	bne.n	ddc0 <console_pkg_init+0x14>
    ddb6:	0003      	movs	r3, r0
    ddb8:	0002      	movs	r2, r0
    ddba:	0001      	movs	r1, r0
    ddbc:	f7fe fdbc 	bl	c938 <__assert_func>

#if MYNEWT_VAL(CONSOLE_UART)
    rc = uart_console_init();
    ddc0:	f000 f8d6 	bl	df70 <uart_console_init>
#endif
#if MYNEWT_VAL(CONSOLE_RTT)
    rc = rtt_console_init();
#endif
    SYSINIT_PANIC_ASSERT(rc == 0);
    ddc4:	2800      	cmp	r0, #0
    ddc6:	d007      	beq.n	ddd8 <console_pkg_init+0x2c>
    ddc8:	2000      	movs	r0, #0
    ddca:	4b05      	ldr	r3, [pc, #20]	; (dde0 <console_pkg_init+0x34>)
    ddcc:	9000      	str	r0, [sp, #0]
    ddce:	681c      	ldr	r4, [r3, #0]
    ddd0:	0002      	movs	r2, r0
    ddd2:	0003      	movs	r3, r0
    ddd4:	0001      	movs	r1, r0
    ddd6:	47a0      	blx	r4
}
    ddd8:	bd13      	pop	{r0, r1, r4, pc}
    ddda:	46c0      	nop			; (mov r8, r8)
    dddc:	200024d0 	.word	0x200024d0
    dde0:	200000e0 	.word	0x200000e0

0000dde4 <console_printf>:
 *                                  unlimited.  This return value is analogous
 *                                  to that of snprintf.
 */
int
console_printf(const char *fmt, ...)
{
    dde4:	b40f      	push	{r0, r1, r2, r3}
    dde6:	b513      	push	{r0, r1, r4, lr}
    va_list args;
    int num_chars;

    num_chars = 0;

    if (console_get_ticks()) {
    dde8:	f000 f81c 	bl	de24 <console_get_ticks>
    num_chars = 0;
    ddec:	2400      	movs	r4, #0
    if (console_get_ticks()) {
    ddee:	42a0      	cmp	r0, r4
    ddf0:	d00a      	beq.n	de08 <console_printf+0x24>
        /* Prefix each line with a timestamp. */
        if (!console_is_midline) {
    ddf2:	4b0a      	ldr	r3, [pc, #40]	; (de1c <console_printf+0x38>)
    ddf4:	681b      	ldr	r3, [r3, #0]
    ddf6:	42a3      	cmp	r3, r4
    ddf8:	d106      	bne.n	de08 <console_printf+0x24>
            num_chars += printf("%06lu ", (unsigned long)os_time_get());
    ddfa:	f7ff fa65 	bl	d2c8 <os_time_get>
    ddfe:	0001      	movs	r1, r0
    de00:	4807      	ldr	r0, [pc, #28]	; (de20 <console_printf+0x3c>)
    de02:	f002 f96d 	bl	100e0 <printf>
    de06:	0004      	movs	r4, r0
        }
    }

    va_start(args, fmt);
    de08:	a905      	add	r1, sp, #20
    num_chars += vprintf(fmt, args);
    de0a:	9804      	ldr	r0, [sp, #16]
    va_start(args, fmt);
    de0c:	9101      	str	r1, [sp, #4]
    num_chars += vprintf(fmt, args);
    de0e:	f002 f977 	bl	10100 <vprintf>
    de12:	1820      	adds	r0, r4, r0
    va_end(args);

    return num_chars;
}
    de14:	bc16      	pop	{r1, r2, r4}
    de16:	bc08      	pop	{r3}
    de18:	b004      	add	sp, #16
    de1a:	4718      	bx	r3
    de1c:	200024cc 	.word	0x200024cc
    de20:	00010956 	.word	0x00010956

0000de24 <console_get_ticks>:
}

/* return value of CONSOLE_TICKS */
char console_get_ticks(void)
{
    return do_ticks;
    de24:	4b01      	ldr	r3, [pc, #4]	; (de2c <console_get_ticks+0x8>)
    de26:	7818      	ldrb	r0, [r3, #0]
}
    de28:	4770      	bx	lr
    de2a:	46c0      	nop			; (mov r8, r8)
    de2c:	200000dc 	.word	0x200000dc

0000de30 <uart_blocking_tx>:
 *
 * @param dev		Uart device in question
 */
static inline void
uart_blocking_tx(struct uart_dev *dev, uint8_t byte)
{
    de30:	b510      	push	{r4, lr}
    dev->ud_funcs.uf_blocking_tx(dev, byte);
    de32:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
    de34:	4798      	blx	r3
}
    de36:	bd10      	pop	{r4, pc}

0000de38 <console_rx_char>:
/*
 * Interrupts disabled when console_tx_char/console_rx_char are called.
 */
static int
console_rx_char(void *arg, uint8_t byte)
{
    de38:	b510      	push	{r4, lr}
    return console_handle_char(byte);
    de3a:	0008      	movs	r0, r1
    de3c:	f7ff fe84 	bl	db48 <console_handle_char>
}
    de40:	bd10      	pop	{r4, pc}
	...

0000de44 <console_tx_char>:
    if (cr_tx.cr_head == cr_tx.cr_tail) {
    de44:	4a07      	ldr	r2, [pc, #28]	; (de64 <console_tx_char+0x20>)
    de46:	7853      	ldrb	r3, [r2, #1]
    de48:	7811      	ldrb	r1, [r2, #0]
    de4a:	4299      	cmp	r1, r3
    de4c:	d007      	beq.n	de5e <console_tx_char+0x1a>
    ch = cr->cr_buf[cr->cr_tail];
    de4e:	6851      	ldr	r1, [r2, #4]
    de50:	5cc8      	ldrb	r0, [r1, r3]
    cr->cr_tail = CONSOLE_TAIL_INC(cr);
    de52:	8851      	ldrh	r1, [r2, #2]
    de54:	3301      	adds	r3, #1
    de56:	3901      	subs	r1, #1
    de58:	400b      	ands	r3, r1
    de5a:	7053      	strb	r3, [r2, #1]
}
    de5c:	4770      	bx	lr
        return -1;
    de5e:	2001      	movs	r0, #1
    de60:	4240      	negs	r0, r0
    de62:	e7fb      	b.n	de5c <console_tx_char+0x18>
    de64:	20001ffc 	.word	0x20001ffc

0000de68 <console_queue_char>:
{
    de68:	b570      	push	{r4, r5, r6, lr}
    de6a:	0005      	movs	r5, r0
    de6c:	000e      	movs	r6, r1
        OS_ENTER_CRITICAL(sr);
    de6e:	f7ff fa8f 	bl	d390 <os_arch_save_sr>
    while (CONSOLE_HEAD_INC(&cr_tx) == cr_tx.cr_tail) {
    de72:	4b12      	ldr	r3, [pc, #72]	; (debc <console_queue_char+0x54>)
        OS_ENTER_CRITICAL(sr);
    de74:	0004      	movs	r4, r0
    while (CONSOLE_HEAD_INC(&cr_tx) == cr_tx.cr_tail) {
    de76:	8859      	ldrh	r1, [r3, #2]
    de78:	7818      	ldrb	r0, [r3, #0]
    de7a:	3901      	subs	r1, #1
    de7c:	1c42      	adds	r2, r0, #1
    de7e:	400a      	ands	r2, r1
    de80:	7859      	ldrb	r1, [r3, #1]
    de82:	428a      	cmp	r2, r1
    de84:	d00b      	beq.n	de9e <console_queue_char+0x36>
    cr->cr_buf[cr->cr_head] = ch;
    de86:	685a      	ldr	r2, [r3, #4]
    de88:	5416      	strb	r6, [r2, r0]
    cr->cr_head = CONSOLE_HEAD_INC(cr);
    de8a:	7819      	ldrb	r1, [r3, #0]
    de8c:	885a      	ldrh	r2, [r3, #2]
    de8e:	3101      	adds	r1, #1
    de90:	3a01      	subs	r2, #1
    de92:	400a      	ands	r2, r1
    OS_EXIT_CRITICAL(sr);
    de94:	0020      	movs	r0, r4
    cr->cr_head = CONSOLE_HEAD_INC(cr);
    de96:	701a      	strb	r2, [r3, #0]
    OS_EXIT_CRITICAL(sr);
    de98:	f7ff fa80 	bl	d39c <os_arch_restore_sr>
}
    de9c:	bd70      	pop	{r4, r5, r6, pc}
    dev->ud_funcs.uf_start_tx(dev);
    de9e:	0028      	movs	r0, r5
    dea0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    dea2:	4798      	blx	r3
        OS_EXIT_CRITICAL(sr);
    dea4:	0020      	movs	r0, r4
    dea6:	f7ff fa79 	bl	d39c <os_arch_restore_sr>
        if (os_started()) {
    deaa:	f7fe fded 	bl	ca88 <os_started>
    deae:	2800      	cmp	r0, #0
    deb0:	d0dd      	beq.n	de6e <console_queue_char+0x6>
            os_time_delay(1);
    deb2:	2001      	movs	r0, #1
    deb4:	f7ff fa4a 	bl	d34c <os_time_delay>
    deb8:	e7d9      	b.n	de6e <console_queue_char+0x6>
    deba:	46c0      	nop			; (mov r8, r8)
    debc:	20001ffc 	.word	0x20001ffc

0000dec0 <uart_console_blocking_mode>:
{
    dec0:	b570      	push	{r4, r5, r6, lr}
    OS_ENTER_CRITICAL(sr);
    dec2:	f7ff fa65 	bl	d390 <os_arch_save_sr>
    if (write_char_cb) {
    dec6:	4b0f      	ldr	r3, [pc, #60]	; (df04 <uart_console_blocking_mode+0x44>)
    OS_ENTER_CRITICAL(sr);
    dec8:	0005      	movs	r5, r0
    if (write_char_cb) {
    deca:	681a      	ldr	r2, [r3, #0]
    decc:	2a00      	cmp	r2, #0
    dece:	d015      	beq.n	defc <uart_console_blocking_mode+0x3c>
        write_char_cb = uart_blocking_tx;
    ded0:	2420      	movs	r4, #32
    ded2:	4a0d      	ldr	r2, [pc, #52]	; (df08 <uart_console_blocking_mode+0x48>)
    ded4:	601a      	str	r2, [r3, #0]
        if (cr_tx.cr_head == cr_tx.cr_tail) {
    ded6:	4a0d      	ldr	r2, [pc, #52]	; (df0c <uart_console_blocking_mode+0x4c>)
    ded8:	7853      	ldrb	r3, [r2, #1]
    deda:	7811      	ldrb	r1, [r2, #0]
    dedc:	4299      	cmp	r1, r3
    dede:	d00d      	beq.n	defc <uart_console_blocking_mode+0x3c>
    ch = cr->cr_buf[cr->cr_tail];
    dee0:	6851      	ldr	r1, [r2, #4]
    cr->cr_tail = CONSOLE_TAIL_INC(cr);
    dee2:	8850      	ldrh	r0, [r2, #2]
    ch = cr->cr_buf[cr->cr_tail];
    dee4:	5cc9      	ldrb	r1, [r1, r3]
    cr->cr_tail = CONSOLE_TAIL_INC(cr);
    dee6:	3801      	subs	r0, #1
    dee8:	3301      	adds	r3, #1
    deea:	4003      	ands	r3, r0
    deec:	7053      	strb	r3, [r2, #1]
        uart_blocking_tx(uart_dev, byte);
    deee:	4b08      	ldr	r3, [pc, #32]	; (df10 <uart_console_blocking_mode+0x50>)
    def0:	3c01      	subs	r4, #1
    def2:	6818      	ldr	r0, [r3, #0]
    def4:	f7ff ff9c 	bl	de30 <uart_blocking_tx>
    for (i = 0; i < cnt; i++) {
    def8:	2c00      	cmp	r4, #0
    defa:	d1ec      	bne.n	ded6 <uart_console_blocking_mode+0x16>
    OS_EXIT_CRITICAL(sr);
    defc:	0028      	movs	r0, r5
    defe:	f7ff fa4d 	bl	d39c <os_arch_restore_sr>
}
    df02:	bd70      	pop	{r4, r5, r6, pc}
    df04:	20002028 	.word	0x20002028
    df08:	0000de31 	.word	0x0000de31
    df0c:	20001ffc 	.word	0x20001ffc
    df10:	20002024 	.word	0x20002024

0000df14 <uart_console_non_blocking_mode>:
{
    df14:	b510      	push	{r4, lr}
    OS_ENTER_CRITICAL(sr);
    df16:	f7ff fa3b 	bl	d390 <os_arch_save_sr>
    if (write_char_cb) {
    df1a:	4b04      	ldr	r3, [pc, #16]	; (df2c <uart_console_non_blocking_mode+0x18>)
    df1c:	681a      	ldr	r2, [r3, #0]
    df1e:	2a00      	cmp	r2, #0
    df20:	d001      	beq.n	df26 <uart_console_non_blocking_mode+0x12>
        write_char_cb = console_queue_char;
    df22:	4a03      	ldr	r2, [pc, #12]	; (df30 <uart_console_non_blocking_mode+0x1c>)
    df24:	601a      	str	r2, [r3, #0]
    OS_EXIT_CRITICAL(sr);
    df26:	f7ff fa39 	bl	d39c <os_arch_restore_sr>
}
    df2a:	bd10      	pop	{r4, pc}
    df2c:	20002028 	.word	0x20002028
    df30:	0000de69 	.word	0x0000de69

0000df34 <console_out>:
{
    df34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    df36:	0004      	movs	r4, r0
    df38:	4d0a      	ldr	r5, [pc, #40]	; (df64 <console_out+0x30>)
    df3a:	4e0b      	ldr	r6, [pc, #44]	; (df68 <console_out+0x34>)
    df3c:	4f0b      	ldr	r7, [pc, #44]	; (df6c <console_out+0x38>)
        console_is_midline = 1;
    df3e:	2301      	movs	r3, #1
    if ('\n' == c) {
    df40:	280a      	cmp	r0, #10
    df42:	d104      	bne.n	df4e <console_out+0x1a>
        write_char_cb(uart_dev, '\r');
    df44:	6833      	ldr	r3, [r6, #0]
    df46:	210d      	movs	r1, #13
    df48:	6828      	ldr	r0, [r5, #0]
    df4a:	4798      	blx	r3
        console_is_midline = 0;
    df4c:	2300      	movs	r3, #0
        console_is_midline = 1;
    df4e:	603b      	str	r3, [r7, #0]
    write_char_cb(uart_dev, c);
    df50:	6828      	ldr	r0, [r5, #0]
    df52:	6833      	ldr	r3, [r6, #0]
    df54:	b2e1      	uxtb	r1, r4
    df56:	4798      	blx	r3
    uart_start_tx(uart_dev);
    df58:	6828      	ldr	r0, [r5, #0]
    df5a:	6a43      	ldr	r3, [r0, #36]	; 0x24
    df5c:	4798      	blx	r3
}
    df5e:	0020      	movs	r0, r4
    df60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    df62:	46c0      	nop			; (mov r8, r8)
    df64:	20002024 	.word	0x20002024
    df68:	20002028 	.word	0x20002028
    df6c:	200024cc 	.word	0x200024cc

0000df70 <uart_console_init>:
    return uart_dev != NULL;
}

int
uart_console_init(void)
{
    df70:	b510      	push	{r4, lr}
    df72:	b086      	sub	sp, #24
    struct uart_conf uc = {
    df74:	466b      	mov	r3, sp
    df76:	2212      	movs	r2, #18
    df78:	1d98      	adds	r0, r3, #6
    df7a:	2100      	movs	r1, #0
    df7c:	f7ff fc98 	bl	d8b0 <memset>
    df80:	23e1      	movs	r3, #225	; 0xe1
    df82:	025b      	lsls	r3, r3, #9
    df84:	9300      	str	r3, [sp, #0]
    df86:	2384      	movs	r3, #132	; 0x84
    df88:	466a      	mov	r2, sp
    df8a:	005b      	lsls	r3, r3, #1
    df8c:	8093      	strh	r3, [r2, #4]
        .uc_flow_ctl = MYNEWT_VAL(CONSOLE_UART_FLOW_CONTROL),
        .uc_tx_char = console_tx_char,
        .uc_rx_char = console_rx_char,
    };

    cr_tx.cr_size = MYNEWT_VAL(CONSOLE_UART_TX_BUF_SIZE);
    df8e:	2220      	movs	r2, #32
          OS_TIMEOUT_NEVER, &uc);
        if (!uart_dev) {
            return -1;
        }
    }
    return 0;
    df90:	2000      	movs	r0, #0
    struct uart_conf uc = {
    df92:	4b0d      	ldr	r3, [pc, #52]	; (dfc8 <uart_console_init+0x58>)
    if (!uart_dev) {
    df94:	4c0d      	ldr	r4, [pc, #52]	; (dfcc <uart_console_init+0x5c>)
    struct uart_conf uc = {
    df96:	9302      	str	r3, [sp, #8]
    df98:	4b0d      	ldr	r3, [pc, #52]	; (dfd0 <uart_console_init+0x60>)
    df9a:	9303      	str	r3, [sp, #12]
    cr_tx.cr_size = MYNEWT_VAL(CONSOLE_UART_TX_BUF_SIZE);
    df9c:	4b0d      	ldr	r3, [pc, #52]	; (dfd4 <uart_console_init+0x64>)
    df9e:	805a      	strh	r2, [r3, #2]
    cr_tx.cr_buf = cr_tx_buf;
    dfa0:	4a0d      	ldr	r2, [pc, #52]	; (dfd8 <uart_console_init+0x68>)
    dfa2:	605a      	str	r2, [r3, #4]
    write_char_cb = console_queue_char;
    dfa4:	4b0d      	ldr	r3, [pc, #52]	; (dfdc <uart_console_init+0x6c>)
    dfa6:	4a0e      	ldr	r2, [pc, #56]	; (dfe0 <uart_console_init+0x70>)
    dfa8:	601a      	str	r2, [r3, #0]
    if (!uart_dev) {
    dfaa:	6823      	ldr	r3, [r4, #0]
    dfac:	4283      	cmp	r3, r0
    dfae:	d109      	bne.n	dfc4 <uart_console_init+0x54>
        uart_dev = (struct uart_dev *)os_dev_open(MYNEWT_VAL(CONSOLE_UART_DEV),
    dfb0:	2101      	movs	r1, #1
    dfb2:	466a      	mov	r2, sp
    dfb4:	4249      	negs	r1, r1
    dfb6:	480b      	ldr	r0, [pc, #44]	; (dfe4 <uart_console_init+0x74>)
    dfb8:	f7fe fec4 	bl	cd44 <os_dev_open>
    dfbc:	6020      	str	r0, [r4, #0]
        if (!uart_dev) {
    dfbe:	4243      	negs	r3, r0
    dfc0:	4158      	adcs	r0, r3
    dfc2:	4240      	negs	r0, r0
}
    dfc4:	b006      	add	sp, #24
    dfc6:	bd10      	pop	{r4, pc}
    dfc8:	0000de45 	.word	0x0000de45
    dfcc:	20002024 	.word	0x20002024
    dfd0:	0000de39 	.word	0x0000de39
    dfd4:	20001ffc 	.word	0x20001ffc
    dfd8:	20002004 	.word	0x20002004
    dfdc:	20002028 	.word	0x20002028
    dfe0:	0000de69 	.word	0x0000de69
    dfe4:	0001095d 	.word	0x0001095d

0000dfe8 <sysinit_dflt_panic_cb>:
#include "sysinit/sysinit.h"

static void
sysinit_dflt_panic_cb(const char *file, int line, const char *func,
                      const char *expr, const char *msg)
{
    dfe8:	b510      	push	{r4, lr}
    if (msg != NULL) {
        fprintf(stderr, "sysinit failure: %s\n", msg);
    }
#endif

    __assert_func(file, line, func, expr);
    dfea:	f7fe fca5 	bl	c938 <__assert_func>
	...

0000dff0 <sysinit_start>:
}

void
sysinit_start(void)
{
    sysinit_active = 1;
    dff0:	2201      	movs	r2, #1
    dff2:	4b01      	ldr	r3, [pc, #4]	; (dff8 <sysinit_start+0x8>)
    dff4:	701a      	strb	r2, [r3, #0]
}
    dff6:	4770      	bx	lr
    dff8:	200024d0 	.word	0x200024d0

0000dffc <sysinit_end>:

void
sysinit_end(void)
{
    sysinit_active = 0;
    dffc:	2200      	movs	r2, #0
    dffe:	4b01      	ldr	r3, [pc, #4]	; (e004 <sysinit_end+0x8>)
    e000:	701a      	strb	r2, [r3, #0]
}
    e002:	4770      	bx	lr
    e004:	200024d0 	.word	0x200024d0

0000e008 <mem_init_mbuf_pool>:

int
mem_init_mbuf_pool(void *mem, struct os_mempool *mempool,
                   struct os_mbuf_pool *mbuf_pool, int num_blocks,
                   int block_size, char *name)
{
    e008:	b573      	push	{r0, r1, r4, r5, r6, lr}
    e00a:	000d      	movs	r5, r1
    e00c:	001c      	movs	r4, r3
    int rc;

    rc = os_mempool_init(mempool, num_blocks, block_size, mem, name);
    e00e:	9b07      	ldr	r3, [sp, #28]
{
    e010:	0016      	movs	r6, r2
    rc = os_mempool_init(mempool, num_blocks, block_size, mem, name);
    e012:	9300      	str	r3, [sp, #0]
    e014:	9a06      	ldr	r2, [sp, #24]
    e016:	0003      	movs	r3, r0
    e018:	0021      	movs	r1, r4
    e01a:	0028      	movs	r0, r5
    e01c:	f7ff faba 	bl	d594 <os_mempool_init>
    if (rc != 0) {
    e020:	2800      	cmp	r0, #0
    e022:	d106      	bne.n	e032 <mem_init_mbuf_pool+0x2a>
        return rc;
    }

    rc = os_mbuf_pool_init(mbuf_pool, mempool, block_size, num_blocks);
    e024:	9a06      	ldr	r2, [sp, #24]
    e026:	b2a3      	uxth	r3, r4
    e028:	b292      	uxth	r2, r2
    e02a:	0029      	movs	r1, r5
    e02c:	0030      	movs	r0, r6
    e02e:	f7ff faab 	bl	d588 <os_mbuf_pool_init>
    if (rc != 0) {
        return rc;
    }

    return 0;
}
    e032:	bd76      	pop	{r1, r2, r4, r5, r6, pc}

0000e034 <sysinit_app>:
void console_pkg_init(void);
void mfg_init(void);

void
sysinit_app(void)
{
    e034:	b510      	push	{r4, lr}
    /*** Stage 0 */
    /* 0.0: os_pkg_init (kernel/os) */
    os_pkg_init();
    e036:	f7fe fdb3 	bl	cba0 <os_pkg_init>

    /*** Stage 2 */
    /* 2.0: flash_map_init (sys/flash_map) */
    flash_map_init();
    e03a:	f002 f8a7 	bl	1018c <flash_map_init>

    /*** Stage 20 */
    /* 20.0: console_pkg_init (sys/console/full) */
    console_pkg_init();
    e03e:	f7ff feb5 	bl	ddac <console_pkg_init>

    /*** Stage 100 */
    /* 100.0: mfg_init (sys/mfg) */
    mfg_init();
    e042:	f002 f95f 	bl	10304 <mfg_init>
}
    e046:	bd10      	pop	{r4, pc}

0000e048 <hal_bsp_flash_dev>:
{
    /*
     * Internal flash mapped to id 0.
     */
    if (id != 0) {
        return NULL;
    e048:	2300      	movs	r3, #0
    if (id != 0) {
    e04a:	4298      	cmp	r0, r3
    e04c:	d100      	bne.n	e050 <hal_bsp_flash_dev+0x8>
    }

    return &samd21_flash_dev;
    e04e:	4b01      	ldr	r3, [pc, #4]	; (e054 <hal_bsp_flash_dev+0xc>)
}
    e050:	0018      	movs	r0, r3
    e052:	4770      	bx	lr
    e054:	200000e4 	.word	0x200000e4

0000e058 <hal_bsp_init>:
    return pri;
}

void
hal_bsp_init(void)
{
    e058:	b510      	push	{r4, lr}
#if MYNEWT_VAL(TIMER_0) || MYNEWT_VAL(TIMER_1) || MYNEWT_VAL(TIMER_2)
    struct samd21_timer_cfg tmr_cfg;
#endif

#if MYNEWT_VAL(UART_0)
    rc = os_dev_create((struct os_dev *) &hal_uart0, "uart0",
    e05a:	4b18      	ldr	r3, [pc, #96]	; (e0bc <hal_bsp_init+0x64>)
{
    e05c:	b086      	sub	sp, #24
    rc = os_dev_create((struct os_dev *) &hal_uart0, "uart0",
    e05e:	9301      	str	r3, [sp, #4]
    e060:	4b17      	ldr	r3, [pc, #92]	; (e0c0 <hal_bsp_init+0x68>)
    e062:	2201      	movs	r2, #1
    e064:	9300      	str	r3, [sp, #0]
    e066:	4917      	ldr	r1, [pc, #92]	; (e0c4 <hal_bsp_init+0x6c>)
    e068:	2300      	movs	r3, #0
    e06a:	4817      	ldr	r0, [pc, #92]	; (e0c8 <hal_bsp_init+0x70>)
    e06c:	f7fe fe04 	bl	cc78 <os_dev_create>
      OS_DEV_INIT_PRIMARY, 0, uart_hal_init, (void *)&uart_cfgs[0]);
    SYSINIT_PANIC_ASSERT(rc == 0);
    e070:	2800      	cmp	r0, #0
    e072:	d007      	beq.n	e084 <hal_bsp_init+0x2c>
    e074:	2000      	movs	r0, #0
    e076:	4b15      	ldr	r3, [pc, #84]	; (e0cc <hal_bsp_init+0x74>)
    e078:	9000      	str	r0, [sp, #0]
    e07a:	681c      	ldr	r4, [r3, #0]
    e07c:	0002      	movs	r2, r0
    e07e:	0003      	movs	r3, r0
    e080:	0001      	movs	r1, r0
    e082:	47a0      	blx	r4
#endif

#if MYNEWT_VAL(TIMER_0)
    tmr_cfg.clkgen = GCLK_GENERATOR_2;
    e084:	2302      	movs	r3, #2
    e086:	a902      	add	r1, sp, #8
    e088:	720b      	strb	r3, [r1, #8]
    tmr_cfg.src_clock = GCLK_SOURCE_OSC8M;
    e08a:	3304      	adds	r3, #4
    e08c:	700b      	strb	r3, [r1, #0]
    tmr_cfg.hwtimer = TC3;
    e08e:	4b10      	ldr	r3, [pc, #64]	; (e0d0 <hal_bsp_init+0x78>)
    tmr_cfg.irq_num = TC3_IRQn;
    rc = hal_timer_init(0, &tmr_cfg);
    e090:	2000      	movs	r0, #0
    tmr_cfg.hwtimer = TC3;
    e092:	60cb      	str	r3, [r1, #12]
    tmr_cfg.irq_num = TC3_IRQn;
    e094:	2312      	movs	r3, #18
    e096:	604b      	str	r3, [r1, #4]
    rc = hal_timer_init(0, &tmr_cfg);
    e098:	f000 fa4c 	bl	e534 <hal_timer_init>
    assert(rc == 0);
    e09c:	2800      	cmp	r0, #0
    e09e:	d005      	beq.n	e0ac <hal_bsp_init+0x54>
    e0a0:	2300      	movs	r3, #0
    e0a2:	001a      	movs	r2, r3
    e0a4:	0019      	movs	r1, r3
    e0a6:	0018      	movs	r0, r3
    e0a8:	f7fe fc46 	bl	c938 <__assert_func>

#if (MYNEWT_VAL(OS_CPUTIME_TIMER_NUM) >= 0)
    /*
     * Set cputime to count at 1 usec increments.
     */
    rc = os_cputime_init(MYNEWT_VAL(OS_CPUTIME_FREQ));
    e0ac:	4809      	ldr	r0, [pc, #36]	; (e0d4 <hal_bsp_init+0x7c>)
    e0ae:	f001 fd05 	bl	fabc <os_cputime_init>
    assert(rc == 0);
    e0b2:	2800      	cmp	r0, #0
    e0b4:	d1f4      	bne.n	e0a0 <hal_bsp_init+0x48>

#if MYNEWT_VAL(I2C_5)
    rc = hal_i2c_init(5, &i2c_config);
    SYSINIT_PANIC_ASSERT(rc == 0);
#endif
}
    e0b6:	b006      	add	sp, #24
    e0b8:	bd10      	pop	{r4, pc}
    e0ba:	46c0      	nop			; (mov r8, r8)
    e0bc:	00010964 	.word	0x00010964
    e0c0:	0000e15d 	.word	0x0000e15d
    e0c4:	0001095d 	.word	0x0001095d
    e0c8:	2000202c 	.word	0x2000202c
    e0cc:	200000e0 	.word	0x200000e0
    e0d0:	42002c00 	.word	0x42002c00
    e0d4:	000f4240 	.word	0x000f4240

0000e0d8 <uart_hal_blocking_tx>:
    hal_uart_start_rx(priv->unit);
}

static void
uart_hal_blocking_tx(struct uart_dev *dev, uint8_t byte)
{
    e0d8:	b510      	push	{r4, lr}
    struct uart_hal_priv *priv;

    priv = dev->ud_priv;

    hal_uart_blocking_tx(priv->unit, byte);
    e0da:	6b03      	ldr	r3, [r0, #48]	; 0x30
    e0dc:	6818      	ldr	r0, [r3, #0]
    e0de:	f000 fbbf 	bl	e860 <hal_uart_blocking_tx>
}
    e0e2:	bd10      	pop	{r4, pc}

0000e0e4 <uart_hal_start_rx>:
{
    e0e4:	b510      	push	{r4, lr}
    hal_uart_start_rx(priv->unit);
    e0e6:	6b03      	ldr	r3, [r0, #48]	; 0x30
    e0e8:	6818      	ldr	r0, [r3, #0]
    e0ea:	f000 fb7f 	bl	e7ec <hal_uart_start_rx>
}
    e0ee:	bd10      	pop	{r4, pc}

0000e0f0 <uart_hal_close>:
    struct uart_hal_priv *priv;
    int rc;

    priv = ((struct uart_dev *)odev)->ud_priv;

    rc = hal_uart_close(priv->unit);
    e0f0:	6b03      	ldr	r3, [r0, #48]	; 0x30
{
    e0f2:	b510      	push	{r4, lr}
    rc = hal_uart_close(priv->unit);
    e0f4:	6818      	ldr	r0, [r3, #0]
    e0f6:	f000 fca3 	bl	ea40 <hal_uart_close>
    if (rc) {
    e0fa:	2800      	cmp	r0, #0
    e0fc:	d000      	beq.n	e100 <uart_hal_close+0x10>
        return OS_EINVAL;
    e0fe:	2002      	movs	r0, #2
    }
    return OS_OK;
}
    e100:	bd10      	pop	{r4, pc}

0000e102 <uart_hal_open>:
{
    e102:	b537      	push	{r0, r1, r2, r4, r5, lr}
    e104:	0003      	movs	r3, r0
    e106:	1e14      	subs	r4, r2, #0
    if (!uc) {
    e108:	d101      	bne.n	e10e <uart_hal_open+0xc>
        return OS_EINVAL;
    e10a:	2002      	movs	r0, #2
}
    e10c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
    if (odev->od_flags & OS_DEV_F_STATUS_OPEN) {
    e10e:	7ec2      	ldrb	r2, [r0, #27]
        return OS_EBUSY;
    e110:	200b      	movs	r0, #11
    if (odev->od_flags & OS_DEV_F_STATUS_OPEN) {
    e112:	0792      	lsls	r2, r2, #30
    e114:	d4fa      	bmi.n	e10c <uart_hal_open+0xa>
    priv = ((struct uart_dev *)odev)->ud_priv;
    e116:	6b1d      	ldr	r5, [r3, #48]	; 0x30
    hal_uart_init_cbs(priv->unit, uc->uc_tx_char, uc->uc_tx_done,
    e118:	6963      	ldr	r3, [r4, #20]
    e11a:	6922      	ldr	r2, [r4, #16]
    e11c:	9300      	str	r3, [sp, #0]
    e11e:	68a1      	ldr	r1, [r4, #8]
    e120:	68e3      	ldr	r3, [r4, #12]
    e122:	6828      	ldr	r0, [r5, #0]
    e124:	f000 fb4a 	bl	e7bc <hal_uart_init_cbs>
    rc = hal_uart_config(priv->unit, uc->uc_speed, uc->uc_databits,
    e128:	79e1      	ldrb	r1, [r4, #7]
    e12a:	7963      	ldrb	r3, [r4, #5]
    e12c:	9101      	str	r1, [sp, #4]
    e12e:	79a1      	ldrb	r1, [r4, #6]
    e130:	7922      	ldrb	r2, [r4, #4]
    e132:	9100      	str	r1, [sp, #0]
    e134:	6828      	ldr	r0, [r5, #0]
    e136:	6821      	ldr	r1, [r4, #0]
    e138:	f000 fbac 	bl	e894 <hal_uart_config>
    if (rc) {
    e13c:	2800      	cmp	r0, #0
    e13e:	d0e5      	beq.n	e10c <uart_hal_open+0xa>
    e140:	e7e3      	b.n	e10a <uart_hal_open+0x8>

0000e142 <uart_hal_start_tx>:
    priv = dev->ud_priv;
    e142:	6b00      	ldr	r0, [r0, #48]	; 0x30
{
    e144:	b510      	push	{r4, lr}
    assert(priv);
    e146:	2800      	cmp	r0, #0
    e148:	d104      	bne.n	e154 <uart_hal_start_tx+0x12>
    e14a:	0003      	movs	r3, r0
    e14c:	0002      	movs	r2, r0
    e14e:	0001      	movs	r1, r0
    e150:	f7fe fbf2 	bl	c938 <__assert_func>
    hal_uart_start_tx(priv->unit);
    e154:	6800      	ldr	r0, [r0, #0]
    e156:	f000 fb5d 	bl	e814 <hal_uart_start_tx>
}
    e15a:	bd10      	pop	{r4, pc}

0000e15c <uart_hal_init>:
/*
 * Arg points to BSP specific UART configuration.
 */
int
uart_hal_init(struct os_dev *odev, void *arg)
{
    e15c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e15e:	0004      	movs	r4, r0
    struct uart_dev *dev;
    struct uart_hal_priv *priv;
    char ch;

    priv = os_malloc(sizeof(struct uart_hal_priv));
    e160:	2004      	movs	r0, #4
{
    e162:	000f      	movs	r7, r1
    priv = os_malloc(sizeof(struct uart_hal_priv));
    e164:	f001 fcde 	bl	fb24 <os_malloc>
    e168:	0006      	movs	r6, r0
    if (!priv) {
        return OS_ENOMEM;
    e16a:	2001      	movs	r0, #1
    if (!priv) {
    e16c:	2e00      	cmp	r6, #0
    e16e:	d010      	beq.n	e192 <uart_hal_init+0x36>
    }
    priv->unit = -1;
    e170:	2301      	movs	r3, #1

    ch = odev->od_name[strlen(odev->od_name) - 1];
    e172:	69e5      	ldr	r5, [r4, #28]
    priv->unit = -1;
    e174:	425b      	negs	r3, r3
    ch = odev->od_name[strlen(odev->od_name) - 1];
    e176:	0028      	movs	r0, r5
    priv->unit = -1;
    e178:	6033      	str	r3, [r6, #0]
    ch = odev->od_name[strlen(odev->od_name) - 1];
    e17a:	f001 fda5 	bl	fcc8 <strlen>
    e17e:	182d      	adds	r5, r5, r0
    e180:	3d01      	subs	r5, #1
    e182:	7828      	ldrb	r0, [r5, #0]
    if (!isdigit((int) ch)) {
    e184:	3830      	subs	r0, #48	; 0x30
    e186:	2809      	cmp	r0, #9
    e188:	d904      	bls.n	e194 <uart_hal_init+0x38>
        os_free(priv);
    e18a:	0030      	movs	r0, r6
    e18c:	f001 fcd6 	bl	fb3c <os_free>
        return OS_EINVAL;
    e190:	2002      	movs	r0, #2
    dev->ud_priv = priv;

    hal_uart_init(priv->unit, arg);

    return OS_OK;
}
    e192:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    OS_DEV_SETHANDLERS(odev, uart_hal_open, uart_hal_close);
    e194:	4b08      	ldr	r3, [pc, #32]	; (e1b8 <uart_hal_init+0x5c>)
    priv->unit = ch - '0';
    e196:	6030      	str	r0, [r6, #0]
    OS_DEV_SETHANDLERS(odev, uart_hal_open, uart_hal_close);
    e198:	6023      	str	r3, [r4, #0]
    e19a:	4b08      	ldr	r3, [pc, #32]	; (e1bc <uart_hal_init+0x60>)
    dev->ud_priv = priv;
    e19c:	6326      	str	r6, [r4, #48]	; 0x30
    OS_DEV_SETHANDLERS(odev, uart_hal_open, uart_hal_close);
    e19e:	60e3      	str	r3, [r4, #12]
    dev->ud_funcs.uf_start_tx = uart_hal_start_tx;
    e1a0:	4b07      	ldr	r3, [pc, #28]	; (e1c0 <uart_hal_init+0x64>)
    hal_uart_init(priv->unit, arg);
    e1a2:	0039      	movs	r1, r7
    dev->ud_funcs.uf_start_tx = uart_hal_start_tx;
    e1a4:	6263      	str	r3, [r4, #36]	; 0x24
    dev->ud_funcs.uf_start_rx = uart_hal_start_rx;
    e1a6:	4b07      	ldr	r3, [pc, #28]	; (e1c4 <uart_hal_init+0x68>)
    e1a8:	62a3      	str	r3, [r4, #40]	; 0x28
    dev->ud_funcs.uf_blocking_tx = uart_hal_blocking_tx;
    e1aa:	4b07      	ldr	r3, [pc, #28]	; (e1c8 <uart_hal_init+0x6c>)
    e1ac:	62e3      	str	r3, [r4, #44]	; 0x2c
    hal_uart_init(priv->unit, arg);
    e1ae:	f000 fc69 	bl	ea84 <hal_uart_init>
    return OS_OK;
    e1b2:	2000      	movs	r0, #0
    e1b4:	e7ed      	b.n	e192 <uart_hal_init+0x36>
    e1b6:	46c0      	nop			; (mov r8, r8)
    e1b8:	0000e103 	.word	0x0000e103
    e1bc:	0000e0f1 	.word	0x0000e0f1
    e1c0:	0000e143 	.word	0x0000e143
    e1c4:	0000e0e5 	.word	0x0000e0e5
    e1c8:	0000e0d9 	.word	0x0000e0d9

0000e1cc <samd21_flash_init>:
{
	/* Sanity check the parameters */
	Assert(config);

	/* Write the default configuration for the NVM configuration */
	config->sleep_power_mode  = NVM_SLEEP_POWER_MODE_WAKEONACCESS;
    e1cc:	2200      	movs	r2, #0
    return 0;
}

static int
samd21_flash_init(const struct hal_flash *dev)
{
    e1ce:	b530      	push	{r4, r5, lr}
    e1d0:	b087      	sub	sp, #28
    e1d2:	a801      	add	r0, sp, #4
	config->manual_page_write = true;
	config->wait_states       = NVMCTRL->CTRLB.bit.RWS;
    e1d4:	4b11      	ldr	r3, [pc, #68]	; (e21c <samd21_flash_init+0x50>)
	config->sleep_power_mode  = NVM_SLEEP_POWER_MODE_WAKEONACCESS;
    e1d6:	7002      	strb	r2, [r0, #0]
	config->wait_states       = NVMCTRL->CTRLB.bit.RWS;
    e1d8:	685b      	ldr	r3, [r3, #4]
	config->disable_cache     = false;
    e1da:	70c2      	strb	r2, [r0, #3]
	config->wait_states       = NVMCTRL->CTRLB.bit.RWS;
    e1dc:	06db      	lsls	r3, r3, #27
    e1de:	0f1b      	lsrs	r3, r3, #28
    e1e0:	7083      	strb	r3, [r0, #2]
#if (SAMC20) || (SAMC21)
	config->disable_rww_cache = false;
#endif
	config->cache_readmode    = NVM_CACHE_READMODE_NO_MISS_PENALTY;
    e1e2:	7102      	strb	r2, [r0, #4]
    int rc;
    struct nvm_config cfg;
    struct nvm_parameters params;
    nvm_get_config_defaults(&cfg);

    cfg.manual_page_write = false;
    e1e4:	7042      	strb	r2, [r0, #1]
    rc = nvm_set_config(&cfg);
    e1e6:	f000 fca9 	bl	eb3c <nvm_set_config>
    e1ea:	1e04      	subs	r4, r0, #0
    if(rc != STATUS_OK) {
    e1ec:	d112      	bne.n	e214 <samd21_flash_init+0x48>
        return -1;
    }

    nvm_get_parameters(&params);
    e1ee:	ad03      	add	r5, sp, #12
    e1f0:	0028      	movs	r0, r5
    e1f2:	f000 fddf 	bl	edb4 <nvm_get_parameters>

    /* the samd21 flash doesn't use sector terminology. They use Row and
     * page.  A row contains 4 pages. Each pages is a fixed size.  You can
     * only erase based on row. Here I will map the rows to sectors and
     * deal with pages inside this driver.   */
    samd21_flash_dev.hf_itf = &samd21_flash_funcs;
    e1f6:	4b0a      	ldr	r3, [pc, #40]	; (e220 <samd21_flash_init+0x54>)
    e1f8:	4a0a      	ldr	r2, [pc, #40]	; (e224 <samd21_flash_init+0x58>)
    samd21_flash_dev.hf_base_addr = SAMD21_FLASH_START_ADDR;
    e1fa:	605c      	str	r4, [r3, #4]
    samd21_flash_dev.hf_itf = &samd21_flash_funcs;
    e1fc:	601a      	str	r2, [r3, #0]
    samd21_flash_dev.hf_size = params.nvm_number_of_pages * params.page_size;
    e1fe:	886a      	ldrh	r2, [r5, #2]
    e200:	7829      	ldrb	r1, [r5, #0]
    samd21_flash_dev.hf_sector_cnt =
            params.nvm_number_of_pages/SAMD21_FLASH_PAGES_PER_SECTOR;
    samd21_flash_dev.hf_align = 1;

    return 0;
    e202:	0020      	movs	r0, r4
    samd21_flash_dev.hf_size = params.nvm_number_of_pages * params.page_size;
    e204:	4351      	muls	r1, r2
            params.nvm_number_of_pages/SAMD21_FLASH_PAGES_PER_SECTOR;
    e206:	0912      	lsrs	r2, r2, #4
    e208:	60da      	str	r2, [r3, #12]
    samd21_flash_dev.hf_align = 1;
    e20a:	2201      	movs	r2, #1
    samd21_flash_dev.hf_size = params.nvm_number_of_pages * params.page_size;
    e20c:	6099      	str	r1, [r3, #8]
    samd21_flash_dev.hf_align = 1;
    e20e:	611a      	str	r2, [r3, #16]
}
    e210:	b007      	add	sp, #28
    e212:	bd30      	pop	{r4, r5, pc}
        return -1;
    e214:	2001      	movs	r0, #1
    e216:	4240      	negs	r0, r0
    e218:	e7fa      	b.n	e210 <samd21_flash_init+0x44>
    e21a:	46c0      	nop			; (mov r8, r8)
    e21c:	41004000 	.word	0x41004000
    e220:	200000e4 	.word	0x200000e4
    e224:	00010984 	.word	0x00010984

0000e228 <samd21_flash_sector_info>:
{
    e228:	b5f0      	push	{r4, r5, r6, r7, lr}
    e22a:	b085      	sub	sp, #20
    nvm_get_parameters(&params);
    e22c:	ad01      	add	r5, sp, #4
    e22e:	0028      	movs	r0, r5
{
    e230:	0016      	movs	r6, r2
    e232:	001f      	movs	r7, r3
    e234:	000c      	movs	r4, r1
    nvm_get_parameters(&params);
    e236:	f000 fdbd 	bl	edb4 <nvm_get_parameters>
    sector_size = params.page_size*SAMD21_FLASH_PAGES_PER_SECTOR;
    e23a:	782b      	ldrb	r3, [r5, #0]
    sector_cnt = params.nvm_number_of_pages/SAMD21_FLASH_PAGES_PER_SECTOR;
    e23c:	886a      	ldrh	r2, [r5, #2]
    sector_size = params.page_size*SAMD21_FLASH_PAGES_PER_SECTOR;
    e23e:	011b      	lsls	r3, r3, #4
    if((idx >= sector_cnt) || (idx < 0)){
    e240:	0912      	lsrs	r2, r2, #4
    e242:	4294      	cmp	r4, r2
    e244:	d205      	bcs.n	e252 <samd21_flash_sector_info+0x2a>
    return 0;
    e246:	2000      	movs	r0, #0
    *addr = idx * sector_size + SAMD21_FLASH_START_ADDR;
    e248:	435c      	muls	r4, r3
    *sz = sector_size;
    e24a:	603b      	str	r3, [r7, #0]
    *addr = idx * sector_size + SAMD21_FLASH_START_ADDR;
    e24c:	6034      	str	r4, [r6, #0]
}
    e24e:	b005      	add	sp, #20
    e250:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return -1;
    e252:	2001      	movs	r0, #1
    e254:	4240      	negs	r0, r0
    e256:	e7fa      	b.n	e24e <samd21_flash_sector_info+0x26>

0000e258 <samd21_flash_erase_sector>:
{
    e258:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    nvm_get_parameters(&params);
    e25a:	ad01      	add	r5, sp, #4
    e25c:	0028      	movs	r0, r5
{
    e25e:	000e      	movs	r6, r1
    nvm_get_parameters(&params);
    e260:	2400      	movs	r4, #0
    e262:	f000 fda7 	bl	edb4 <nvm_get_parameters>
                i*SAMD21_FLASH_PAGES_PER_ROW*params.page_size;
    e266:	7828      	ldrb	r0, [r5, #0]
    e268:	4360      	muls	r0, r4
        uint32_t row_address = sector_address +
    e26a:	1980      	adds	r0, r0, r6
        rc = nvm_erase_row(row_address);
    e26c:	f000 fd78 	bl	ed60 <nvm_erase_row>
        if(rc != STATUS_OK) {
    e270:	2800      	cmp	r0, #0
    e272:	d104      	bne.n	e27e <samd21_flash_erase_sector+0x26>
    e274:	3404      	adds	r4, #4
    for(i = 0; i < SAMD21_FLASH_ROWS_PER_SECTOR; i++) {
    e276:	2c10      	cmp	r4, #16
    e278:	d1f5      	bne.n	e266 <samd21_flash_erase_sector+0xe>
}
    e27a:	b004      	add	sp, #16
    e27c:	bd70      	pop	{r4, r5, r6, pc}
            return -1;
    e27e:	2001      	movs	r0, #1
    e280:	4240      	negs	r0, r0
    e282:	e7fa      	b.n	e27a <samd21_flash_erase_sector+0x22>

0000e284 <samd21_flash_write>:
{
    e284:	b5f0      	push	{r4, r5, r6, r7, lr}
    e286:	b099      	sub	sp, #100	; 0x64
    nvm_get_parameters(&params);
    e288:	af05      	add	r7, sp, #20
    e28a:	0038      	movs	r0, r7
{
    e28c:	001c      	movs	r4, r3
    e28e:	000e      	movs	r6, r1
    e290:	9202      	str	r2, [sp, #8]
    nvm_get_parameters(&params);
    e292:	f000 fd8f 	bl	edb4 <nvm_get_parameters>
    assert(params.page_size <= sizeof(page_buffer));
    e296:	783b      	ldrb	r3, [r7, #0]
    e298:	2b40      	cmp	r3, #64	; 0x40
    e29a:	d92e      	bls.n	e2fa <samd21_flash_write+0x76>
    e29c:	2300      	movs	r3, #0
    e29e:	001a      	movs	r2, r3
    e2a0:	0019      	movs	r1, r3
    e2a2:	0018      	movs	r0, r3
    e2a4:	f7fe fb48 	bl	c938 <__assert_func>
        base_address = address & ~(params.page_size - 1);
    e2a8:	783a      	ldrb	r2, [r7, #0]
    e2aa:	4253      	negs	r3, r2
    e2ac:	4033      	ands	r3, r6
    e2ae:	9301      	str	r3, [sp, #4]
        offset = address - base_address;
    e2b0:	1af3      	subs	r3, r6, r3
    e2b2:	9303      	str	r3, [sp, #12]
        write_len = params.page_size - offset;
    e2b4:	1ad5      	subs	r5, r2, r3
        if(write_len > len) {
    e2b6:	42a5      	cmp	r5, r4
    e2b8:	d900      	bls.n	e2bc <samd21_flash_write+0x38>
            write_len = len;
    e2ba:	0025      	movs	r5, r4
        if(nvm_read_buffer(base_address, page_buffer, params.page_size)
    e2bc:	b292      	uxth	r2, r2
    e2be:	a908      	add	r1, sp, #32
    e2c0:	9801      	ldr	r0, [sp, #4]
    e2c2:	f000 fd19 	bl	ecf8 <nvm_read_buffer>
    e2c6:	2800      	cmp	r0, #0
    e2c8:	d003      	beq.n	e2d2 <samd21_flash_write+0x4e>
            return -1;
    e2ca:	2001      	movs	r0, #1
    e2cc:	4240      	negs	r0, r0
}
    e2ce:	b019      	add	sp, #100	; 0x64
    e2d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e2d2:	aa08      	add	r2, sp, #32
    e2d4:	4694      	mov	ip, r2
    e2d6:	9b03      	ldr	r3, [sp, #12]
        len -= write_len;
    e2d8:	1b64      	subs	r4, r4, r5
        address += write_len;
    e2da:	1976      	adds	r6, r6, r5
    e2dc:	4463      	add	r3, ip
    e2de:	9a02      	ldr	r2, [sp, #8]
    e2e0:	1812      	adds	r2, r2, r0
    e2e2:	9203      	str	r2, [sp, #12]
        while(write_len--) {
    e2e4:	4285      	cmp	r5, r0
    e2e6:	d10c      	bne.n	e302 <samd21_flash_write+0x7e>
        if(nvm_write_buffer(base_address,page_buffer, params.page_size)
    e2e8:	783a      	ldrb	r2, [r7, #0]
    e2ea:	a908      	add	r1, sp, #32
    e2ec:	9801      	ldr	r0, [sp, #4]
    e2ee:	f000 fcb7 	bl	ec60 <nvm_write_buffer>
    e2f2:	9b03      	ldr	r3, [sp, #12]
    e2f4:	9302      	str	r3, [sp, #8]
    e2f6:	2800      	cmp	r0, #0
    e2f8:	d1e7      	bne.n	e2ca <samd21_flash_write+0x46>
    while(len) {
    e2fa:	2c00      	cmp	r4, #0
    e2fc:	d1d4      	bne.n	e2a8 <samd21_flash_write+0x24>
    return 0;
    e2fe:	0020      	movs	r0, r4
    e300:	e7e5      	b.n	e2ce <samd21_flash_write+0x4a>
            if (page_buffer[offset] != 0xff) {
    e302:	5c1a      	ldrb	r2, [r3, r0]
    e304:	2aff      	cmp	r2, #255	; 0xff
    e306:	d1e0      	bne.n	e2ca <samd21_flash_write+0x46>
            page_buffer[offset++] = *psrc++;
    e308:	9a02      	ldr	r2, [sp, #8]
    e30a:	5c12      	ldrb	r2, [r2, r0]
    e30c:	541a      	strb	r2, [r3, r0]
    e30e:	3001      	adds	r0, #1
    e310:	e7e5      	b.n	e2de <samd21_flash_write+0x5a>

0000e312 <samd21_flash_read>:
{
    e312:	b5f0      	push	{r4, r5, r6, r7, lr}
    e314:	b097      	sub	sp, #92	; 0x5c
    nvm_get_parameters(&params);
    e316:	af03      	add	r7, sp, #12
    e318:	0038      	movs	r0, r7
{
    e31a:	001c      	movs	r4, r3
    e31c:	000e      	movs	r6, r1
    e31e:	9200      	str	r2, [sp, #0]
    nvm_get_parameters(&params);
    e320:	f000 fd48 	bl	edb4 <nvm_get_parameters>
    assert(params.page_size <= sizeof(page_buffer));
    e324:	783b      	ldrb	r3, [r7, #0]
    e326:	2b40      	cmp	r3, #64	; 0x40
    e328:	d91f      	bls.n	e36a <samd21_flash_read+0x58>
    e32a:	2300      	movs	r3, #0
    e32c:	001a      	movs	r2, r3
    e32e:	0019      	movs	r1, r3
    e330:	0018      	movs	r0, r3
    e332:	f7fe fb01 	bl	c938 <__assert_func>
        base_address = address & ~(params.page_size - 1);
    e336:	783a      	ldrb	r2, [r7, #0]
    e338:	4250      	negs	r0, r2
    e33a:	4030      	ands	r0, r6
        offset = address - base_address;
    e33c:	1a33      	subs	r3, r6, r0
    e33e:	9301      	str	r3, [sp, #4]
        read_len = params.page_size - offset;
    e340:	1ad5      	subs	r5, r2, r3
        if(read_len > num_bytes) {
    e342:	42a5      	cmp	r5, r4
    e344:	d900      	bls.n	e348 <samd21_flash_read+0x36>
            read_len = num_bytes;
    e346:	0025      	movs	r5, r4
        if(nvm_read_buffer(base_address, page_buffer, params.page_size)
    e348:	b292      	uxth	r2, r2
    e34a:	a906      	add	r1, sp, #24
    e34c:	f000 fcd4 	bl	ecf8 <nvm_read_buffer>
    e350:	2800      	cmp	r0, #0
    e352:	d114      	bne.n	e37e <samd21_flash_read+0x6c>
             *pdst++ = page_buffer[offset++];
    e354:	aa06      	add	r2, sp, #24
    e356:	4694      	mov	ip, r2
    e358:	9b01      	ldr	r3, [sp, #4]
        num_bytes -= read_len;
    e35a:	1b64      	subs	r4, r4, r5
        address += read_len;
    e35c:	1976      	adds	r6, r6, r5
             *pdst++ = page_buffer[offset++];
    e35e:	4463      	add	r3, ip
        while(read_len--) {
    e360:	4285      	cmp	r5, r0
    e362:	d107      	bne.n	e374 <samd21_flash_read+0x62>
    e364:	9b00      	ldr	r3, [sp, #0]
    e366:	195b      	adds	r3, r3, r5
    e368:	9300      	str	r3, [sp, #0]
    while(num_bytes) {
    e36a:	2c00      	cmp	r4, #0
    e36c:	d1e3      	bne.n	e336 <samd21_flash_read+0x24>
    return 0;
    e36e:	0020      	movs	r0, r4
}
    e370:	b017      	add	sp, #92	; 0x5c
    e372:	bdf0      	pop	{r4, r5, r6, r7, pc}
             *pdst++ = page_buffer[offset++];
    e374:	5c1a      	ldrb	r2, [r3, r0]
    e376:	9900      	ldr	r1, [sp, #0]
    e378:	540a      	strb	r2, [r1, r0]
    e37a:	3001      	adds	r0, #1
    e37c:	e7f0      	b.n	e360 <samd21_flash_read+0x4e>
            return -1;
    e37e:	2001      	movs	r0, #1
    e380:	4240      	negs	r0, r0
    e382:	e7f5      	b.n	e370 <samd21_flash_read+0x5e>

0000e384 <os_tick_idle>:
/*
 * XXX implement tickless mode.
 */
void
os_tick_idle(os_time_t ticks)
{
    e384:	b510      	push	{r4, lr}
    OS_ASSERT_CRITICAL();
    e386:	f7ff f80d 	bl	d3a4 <os_arch_in_critical>
    e38a:	2800      	cmp	r0, #0
    e38c:	d104      	bne.n	e398 <os_tick_idle+0x14>
    e38e:	0003      	movs	r3, r0
    e390:	0002      	movs	r2, r0
    e392:	0001      	movs	r1, r0
    e394:	f7fe fad0 	bl	c938 <__assert_func>
  __ASM volatile ("dsb 0xF":::"memory");
    e398:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("wfi");
    e39c:	bf30      	wfi
    __DSB();
    __WFI();
}
    e39e:	bd10      	pop	{r4, pc}

0000e3a0 <os_tick_init>:
void
os_tick_init(uint32_t os_ticks_per_sec, int prio)
{
    uint32_t reload_val;

    reload_val = ((uint64_t)SystemCoreClock / os_ticks_per_sec) - 1;
    e3a0:	4b0a      	ldr	r3, [pc, #40]	; (e3cc <os_tick_init+0x2c>)
{
    e3a2:	b510      	push	{r4, lr}
    e3a4:	000c      	movs	r4, r1
    reload_val = ((uint64_t)SystemCoreClock / os_ticks_per_sec) - 1;
    e3a6:	0001      	movs	r1, r0
    e3a8:	6818      	ldr	r0, [r3, #0]
    e3aa:	f002 f84b 	bl	10444 <__udivsi3>

    /* Set the system time ticker up */
    SysTick->LOAD = reload_val;
    SysTick->VAL = 0;
    e3ae:	2200      	movs	r2, #0
    SysTick->LOAD = reload_val;
    e3b0:	4b07      	ldr	r3, [pc, #28]	; (e3d0 <os_tick_init+0x30>)
    reload_val = ((uint64_t)SystemCoreClock / os_ticks_per_sec) - 1;
    e3b2:	3801      	subs	r0, #1
    SysTick->LOAD = reload_val;
    e3b4:	6058      	str	r0, [r3, #4]
    SysTick->VAL = 0;
    e3b6:	609a      	str	r2, [r3, #8]
    SysTick->CTRL = 0x0007;
    e3b8:	3207      	adds	r2, #7
    e3ba:	601a      	str	r2, [r3, #0]
    e3bc:	4b05      	ldr	r3, [pc, #20]	; (e3d4 <os_tick_init+0x34>)
    e3be:	07a4      	lsls	r4, r4, #30
    e3c0:	6a19      	ldr	r1, [r3, #32]
    e3c2:	0209      	lsls	r1, r1, #8
    e3c4:	0a09      	lsrs	r1, r1, #8
    e3c6:	4321      	orrs	r1, r4
    e3c8:	6219      	str	r1, [r3, #32]

    /* Set the system tick priority */
    NVIC_SetPriority(SysTick_IRQn, prio);
}
    e3ca:	bd10      	pop	{r4, pc}
    e3cc:	20002300 	.word	0x20002300
    e3d0:	e000e010 	.word	0xe000e010
    e3d4:	e000ed00 	.word	0xe000ed00

0000e3d8 <hal_system_reset>:
}

int
hal_debugger_connected(void)
{
    return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    e3d8:	4b06      	ldr	r3, [pc, #24]	; (e3f4 <hal_system_reset+0x1c>)
    e3da:	789b      	ldrb	r3, [r3, #2]
        if (hal_debugger_connected()) {
    e3dc:	079b      	lsls	r3, r3, #30
    e3de:	d500      	bpl.n	e3e2 <hal_system_reset+0xa>
            __asm__("bkpt");
    e3e0:	be00      	bkpt	0x0000
  __ASM volatile ("dsb 0xF":::"memory");
    e3e2:	f3bf 8f4f 	dsb	sy
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
    e3e6:	4b04      	ldr	r3, [pc, #16]	; (e3f8 <hal_system_reset+0x20>)
    e3e8:	4a04      	ldr	r2, [pc, #16]	; (e3fc <hal_system_reset+0x24>)
    e3ea:	60da      	str	r2, [r3, #12]
    e3ec:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("nop");
    e3f0:	46c0      	nop			; (mov r8, r8)
    e3f2:	e7fd      	b.n	e3f0 <hal_system_reset+0x18>
    e3f4:	41002000 	.word	0x41002000
    e3f8:	e000ed00 	.word	0xe000ed00
    e3fc:	05fa0004 	.word	0x05fa0004

0000e400 <hal_debugger_connected>:
    return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    e400:	4b02      	ldr	r3, [pc, #8]	; (e40c <hal_debugger_connected+0xc>)
    e402:	7898      	ldrb	r0, [r3, #2]
    e404:	2302      	movs	r3, #2
    e406:	4018      	ands	r0, r3
}
    e408:	4770      	bx	lr
    e40a:	46c0      	nop			; (mov r8, r8)
    e40c:	41002000 	.word	0x41002000

0000e410 <samd21_timer_set_ocmp>:
 *
 * @param timer Pointer to timer.
 */
static void
samd21_timer_set_ocmp(struct samd21_hal_timer *bsptimer, uint32_t expiry)
{
    e410:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    int32_t delta_t;

    hwtimer = bsptimer->tc_mod.hw;

    /* Disable ocmp interrupt and set new value */
    hwtimer->COUNT16.INTENCLR.reg = TC_INTENCLR_MC0;
    e412:	2710      	movs	r7, #16

    temp = expiry & 0xffff0000;
    e414:	0c0b      	lsrs	r3, r1, #16
    e416:	40bb      	lsls	r3, r7
    hwtimer = bsptimer->tc_mod.hw;
    e418:	6986      	ldr	r6, [r0, #24]
    delta_t = (int32_t)(temp - bsptimer->tmr_cntr);
    e41a:	6842      	ldr	r2, [r0, #4]
{
    e41c:	0005      	movs	r5, r0
    hwtimer->COUNT16.INTENCLR.reg = TC_INTENCLR_MC0;
    e41e:	7337      	strb	r7, [r6, #12]
    delta_t = (int32_t)(temp - bsptimer->tmr_cntr);
    e420:	1a9b      	subs	r3, r3, r2
    if (delta_t < 0) {
    e422:	d507      	bpl.n	e434 <samd21_timer_set_ocmp+0x24>
  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    e424:	231f      	movs	r3, #31
    e426:	786a      	ldrb	r2, [r5, #1]
    e428:	401a      	ands	r2, r3
    e42a:	3b1e      	subs	r3, #30
    e42c:	4093      	lsls	r3, r2
    e42e:	4a0b      	ldr	r2, [pc, #44]	; (e45c <samd21_timer_set_ocmp+0x4c>)
    e430:	6053      	str	r3, [r2, #4]
    }
    return;

set_ocmp_late:
    NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
}
    e432:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
    } else if (delta_t == 0) {
    e434:	2b00      	cmp	r3, #0
    e436:	d1fc      	bne.n	e432 <samd21_timer_set_ocmp+0x22>
        tc_set_compare_value(&bsptimer->tc_mod, TC_COMPARE_CAPTURE_CHANNEL_0,
    e438:	0004      	movs	r4, r0
    e43a:	3418      	adds	r4, #24
    e43c:	b28a      	uxth	r2, r1
    e43e:	0020      	movs	r0, r4
    e440:	0019      	movs	r1, r3
    e442:	9201      	str	r2, [sp, #4]
    e444:	f001 f90d 	bl	f662 <tc_set_compare_value>
        hwtimer->COUNT16.INTFLAG.reg = TC_INTFLAG_MC0;
    e448:	73b7      	strb	r7, [r6, #14]
        if (tc_get_count_value(&bsptimer->tc_mod) >= expiry16) {
    e44a:	0020      	movs	r0, r4
        hwtimer->COUNT16.INTENSET.reg = TC_INTENSET_MC0;
    e44c:	7377      	strb	r7, [r6, #13]
        if (tc_get_count_value(&bsptimer->tc_mod) >= expiry16) {
    e44e:	f001 f8f3 	bl	f638 <tc_get_count_value>
    e452:	9b01      	ldr	r3, [sp, #4]
    e454:	4298      	cmp	r0, r3
    e456:	d2e5      	bcs.n	e424 <samd21_timer_set_ocmp+0x14>
    e458:	e7eb      	b.n	e432 <samd21_timer_set_ocmp+0x22>
    e45a:	46c0      	nop			; (mov r8, r8)
    e45c:	e000e1fc 	.word	0xe000e1fc

0000e460 <hal_timer_read_bsptimer>:
    hwtimer->COUNT16.INTENCLR.reg = TC_INTENCLR_MC0;
}

static uint32_t
hal_timer_read_bsptimer(struct samd21_hal_timer *bsptimer)
{
    e460:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    e462:	0005      	movs	r5, r0
    Tc *hwtimer;

    hwtimer = bsptimer->tc_mod.hw;
    cpu_irq_enter_critical();
    tcntr = bsptimer->tmr_cntr;
    low = tc_get_count_value(&bsptimer->tc_mod);
    e464:	002f      	movs	r7, r5
    hwtimer = bsptimer->tc_mod.hw;
    e466:	6983      	ldr	r3, [r0, #24]
    low = tc_get_count_value(&bsptimer->tc_mod);
    e468:	3718      	adds	r7, #24
    hwtimer = bsptimer->tc_mod.hw;
    e46a:	9301      	str	r3, [sp, #4]
    cpu_irq_enter_critical();
    e46c:	f7fd ffc6 	bl	c3fc <cpu_irq_enter_critical>
    low = tc_get_count_value(&bsptimer->tc_mod);
    e470:	0038      	movs	r0, r7
    tcntr = bsptimer->tmr_cntr;
    e472:	686e      	ldr	r6, [r5, #4]
    if (hwtimer->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) {
    e474:	2401      	movs	r4, #1
    low = tc_get_count_value(&bsptimer->tc_mod);
    e476:	f001 f8df 	bl	f638 <tc_get_count_value>
    if (hwtimer->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) {
    e47a:	9b01      	ldr	r3, [sp, #4]
    low = tc_get_count_value(&bsptimer->tc_mod);
    e47c:	b280      	uxth	r0, r0
    if (hwtimer->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) {
    e47e:	7b9b      	ldrb	r3, [r3, #14]
    e480:	4223      	tst	r3, r4
    e482:	d00f      	beq.n	e4a4 <hal_timer_read_bsptimer+0x44>
        tcntr += 65536;
    e484:	2380      	movs	r3, #128	; 0x80
    e486:	025b      	lsls	r3, r3, #9
    e488:	18f6      	adds	r6, r6, r3
        bsptimer->tmr_cntr = tcntr;
    e48a:	606e      	str	r6, [r5, #4]
        low = tc_get_count_value(&bsptimer->tc_mod);
    e48c:	0038      	movs	r0, r7
    e48e:	f001 f8d3 	bl	f638 <tc_get_count_value>
    e492:	221f      	movs	r2, #31
        hwtimer->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    e494:	9b01      	ldr	r3, [sp, #4]
        low = tc_get_count_value(&bsptimer->tc_mod);
    e496:	b280      	uxth	r0, r0
        hwtimer->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    e498:	739c      	strb	r4, [r3, #14]
    e49a:	786b      	ldrb	r3, [r5, #1]
    e49c:	4013      	ands	r3, r2
    e49e:	409c      	lsls	r4, r3
    e4a0:	4b03      	ldr	r3, [pc, #12]	; (e4b0 <hal_timer_read_bsptimer+0x50>)
    e4a2:	605c      	str	r4, [r3, #4]
        NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
    }
    tcntr |= low;
    e4a4:	4306      	orrs	r6, r0
    cpu_irq_leave_critical();
    e4a6:	f7fd ffc3 	bl	c430 <cpu_irq_leave_critical>

    return tcntr;
}
    e4aa:	0030      	movs	r0, r6
    e4ac:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    e4ae:	46c0      	nop			; (mov r8, r8)
    e4b0:	e000e1fc 	.word	0xe000e1fc

0000e4b4 <samd21_timer0_irq_handler>:
    uint8_t ovf_int;
    Tc *hwtimer;

    /* Check interrupt source. If set, clear them */
    hwtimer = bsptimer->tc_mod.hw;
    compare = hwtimer->COUNT16.INTFLAG.reg & TC_INTFLAG_MC0;
    e4b4:	2310      	movs	r3, #16
#endif

#if MYNEWT_VAL(TIMER_0)
void
samd21_timer0_irq_handler(void)
{
    e4b6:	b570      	push	{r4, r5, r6, lr}
    hwtimer = bsptimer->tc_mod.hw;
    e4b8:	4c1d      	ldr	r4, [pc, #116]	; (e530 <samd21_timer0_irq_handler+0x7c>)
    e4ba:	69a6      	ldr	r6, [r4, #24]
    compare = hwtimer->COUNT16.INTFLAG.reg & TC_INTFLAG_MC0;
    e4bc:	7bb2      	ldrb	r2, [r6, #14]
    if (compare) {
    e4be:	421a      	tst	r2, r3
    e4c0:	d000      	beq.n	e4c4 <samd21_timer0_irq_handler+0x10>
        hwtimer->COUNT16.INTFLAG.reg = TC_INTFLAG_MC0;
    e4c2:	73b3      	strb	r3, [r6, #14]
    ovf_int = hwtimer->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF;
    e4c4:	2301      	movs	r3, #1
    e4c6:	7bb2      	ldrb	r2, [r6, #14]
    if (ovf_int) {
    e4c8:	421a      	tst	r2, r3
    e4ca:	d005      	beq.n	e4d8 <samd21_timer0_irq_handler+0x24>
        bsptimer->tmr_cntr += 65536;
    e4cc:	2280      	movs	r2, #128	; 0x80
        hwtimer->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
    e4ce:	73b3      	strb	r3, [r6, #14]
        bsptimer->tmr_cntr += 65536;
    e4d0:	6863      	ldr	r3, [r4, #4]
    e4d2:	0252      	lsls	r2, r2, #9
    e4d4:	189b      	adds	r3, r3, r2
    e4d6:	6063      	str	r3, [r4, #4]
    ++bsptimer->timer_isrs;
    e4d8:	68a3      	ldr	r3, [r4, #8]
    e4da:	3301      	adds	r3, #1
    e4dc:	60a3      	str	r3, [r4, #8]
    cpu_irq_enter_critical();
    e4de:	f7fd ff8d 	bl	c3fc <cpu_irq_enter_critical>
    while ((timer = TAILQ_FIRST(&bsptimer->hal_timer_q)) != NULL) {
    e4e2:	6925      	ldr	r5, [r4, #16]
    e4e4:	2d00      	cmp	r5, #0
    e4e6:	d005      	beq.n	e4f4 <samd21_timer0_irq_handler+0x40>
        tcntr = hal_timer_read_bsptimer(bsptimer);
    e4e8:	0020      	movs	r0, r4
    e4ea:	f7ff ffb9 	bl	e460 <hal_timer_read_bsptimer>
        if ((int32_t)(tcntr - timer->expiry) >= 0) {
    e4ee:	68eb      	ldr	r3, [r5, #12]
    e4f0:	1ac0      	subs	r0, r0, r3
    e4f2:	d50a      	bpl.n	e50a <samd21_timer0_irq_handler+0x56>
    timer = TAILQ_FIRST(&bsptimer->hal_timer_q);
    e4f4:	6923      	ldr	r3, [r4, #16]
    if (timer) {
    e4f6:	2b00      	cmp	r3, #0
    e4f8:	d016      	beq.n	e528 <samd21_timer0_irq_handler+0x74>
        samd21_timer_set_ocmp(bsptimer, timer->expiry);
    e4fa:	68d9      	ldr	r1, [r3, #12]
    e4fc:	0020      	movs	r0, r4
    e4fe:	f7ff ff87 	bl	e410 <samd21_timer_set_ocmp>
    cpu_irq_leave_critical();
    e502:	f7fd ff95 	bl	c430 <cpu_irq_leave_critical>
    compare = hwtimer->COUNT16.INTFLAG.reg;
    e506:	7bb3      	ldrb	r3, [r6, #14]
    hal_timer_irq_handler(&samd21_hal_timer0);
}
    e508:	bd70      	pop	{r4, r5, r6, pc}
            TAILQ_REMOVE(&bsptimer->hal_timer_q, timer, link);
    e50a:	692b      	ldr	r3, [r5, #16]
    e50c:	696a      	ldr	r2, [r5, #20]
    e50e:	2b00      	cmp	r3, #0
    e510:	d008      	beq.n	e524 <samd21_timer0_irq_handler+0x70>
    e512:	615a      	str	r2, [r3, #20]
    e514:	696a      	ldr	r2, [r5, #20]
    e516:	6013      	str	r3, [r2, #0]
            timer->link.tqe_prev = NULL;
    e518:	2300      	movs	r3, #0
            timer->cb_func(timer->cb_arg);
    e51a:	68a8      	ldr	r0, [r5, #8]
            timer->link.tqe_prev = NULL;
    e51c:	616b      	str	r3, [r5, #20]
            timer->cb_func(timer->cb_arg);
    e51e:	686b      	ldr	r3, [r5, #4]
    e520:	4798      	blx	r3
    e522:	e7de      	b.n	e4e2 <samd21_timer0_irq_handler+0x2e>
            TAILQ_REMOVE(&bsptimer->hal_timer_q, timer, link);
    e524:	6162      	str	r2, [r4, #20]
    e526:	e7f5      	b.n	e514 <samd21_timer0_irq_handler+0x60>
    hwtimer->COUNT16.INTENCLR.reg = TC_INTENCLR_MC0;
    e528:	2210      	movs	r2, #16
        samd21_timer_disable_ocmp(bsptimer->tc_mod.hw);
    e52a:	69a3      	ldr	r3, [r4, #24]
    hwtimer->COUNT16.INTENCLR.reg = TC_INTENCLR_MC0;
    e52c:	731a      	strb	r2, [r3, #12]
    e52e:	e7e8      	b.n	e502 <samd21_timer0_irq_handler+0x4e>
    e530:	200024d4 	.word	0x200024d4

0000e534 <hal_timer_init>:
 *
 * @return int          0: success; error code otherwise
 */
int
hal_timer_init(int timer_num, void *cfg)
{
    e534:	b5f0      	push	{r4, r5, r6, r7, lr}
    e536:	0004      	movs	r4, r0
    e538:	b085      	sub	sp, #20
    e53a:	000f      	movs	r7, r1
    struct samd21_timer_cfg *tmr_cfg;
    hal_timer_irq_handler_t irq_isr;
    struct system_gclk_gen_config gcfg;

    /* Get timer. Make sure not enabled */
    SAMD21_HAL_TIMER_RESOLVE(timer_num, bsptimer);
    e53c:	2802      	cmp	r0, #2
    e53e:	dc5d      	bgt.n	e5fc <hal_timer_init+0xc8>
    e540:	4b31      	ldr	r3, [pc, #196]	; (e608 <hal_timer_init+0xd4>)
    e542:	0082      	lsls	r2, r0, #2
    e544:	58d3      	ldr	r3, [r2, r3]
    e546:	2b00      	cmp	r3, #0
    e548:	d058      	beq.n	e5fc <hal_timer_init+0xc8>
    if (bsptimer->tmr_enabled) {
    e54a:	781b      	ldrb	r3, [r3, #0]
    e54c:	2b00      	cmp	r3, #0
    e54e:	d155      	bne.n	e5fc <hal_timer_init+0xc8>
        goto err;
    }
    tmr_cfg = (struct samd21_timer_cfg *)cfg;

    rc = 0;
    switch (timer_num) {
    e550:	2800      	cmp	r0, #0
    e552:	d155      	bne.n	e600 <hal_timer_init+0xcc>
    if (rc) {
        goto err;
    }

    /* set up gclk generator to source this timer */
    gcfg.division_factor = 1;
    e554:	2601      	movs	r6, #1
    gcfg.high_when_disabled = false;
    gcfg.output_enable = false;
    gcfg.run_in_standby = true;
    gcfg.source_clock = tmr_cfg->src_clock;
    e556:	783b      	ldrb	r3, [r7, #0]
    gcfg.division_factor = 1;
    e558:	a901      	add	r1, sp, #4
    e55a:	604e      	str	r6, [r1, #4]
    gcfg.run_in_standby = true;
    e55c:	720e      	strb	r6, [r1, #8]
    gcfg.source_clock = tmr_cfg->src_clock;
    e55e:	700b      	strb	r3, [r1, #0]
    gcfg.high_when_disabled = false;
    e560:	7048      	strb	r0, [r1, #1]
    gcfg.output_enable = false;
    e562:	7248      	strb	r0, [r1, #9]
    system_gclk_gen_set_config(tmr_cfg->clkgen, &gcfg);
    e564:	7a38      	ldrb	r0, [r7, #8]
    e566:	f7fd fe31 	bl	c1cc <system_gclk_gen_set_config>

    irq_num = tmr_cfg->irq_num;
    e56a:	6878      	ldr	r0, [r7, #4]
    bsptimer->tmr_irq_num = irq_num;
    e56c:	4d27      	ldr	r5, [pc, #156]	; (e60c <hal_timer_init+0xd8>)
    irq_num = tmr_cfg->irq_num;
    e56e:	b2c2      	uxtb	r2, r0
    bsptimer->tmr_irq_num = irq_num;
    e570:	706a      	strb	r2, [r5, #1]
    bsptimer->tmr_srcclk = tmr_cfg->src_clock;
    e572:	783b      	ldrb	r3, [r7, #0]
    bsptimer->tmr_clkgen = tmr_cfg->clkgen;
    bsptimer->tc_mod.hw = tmr_cfg->hwtimer;
    bsptimer->tmr_initialized = 1;

    NVIC_DisableIRQ(irq_num);
    e574:	b240      	sxtb	r0, r0
    bsptimer->tmr_srcclk = tmr_cfg->src_clock;
    e576:	70ab      	strb	r3, [r5, #2]
    bsptimer->tmr_clkgen = tmr_cfg->clkgen;
    e578:	7a39      	ldrb	r1, [r7, #8]
    e57a:	19ab      	adds	r3, r5, r6
    e57c:	77d9      	strb	r1, [r3, #31]
    bsptimer->tc_mod.hw = tmr_cfg->hwtimer;
    e57e:	68fb      	ldr	r3, [r7, #12]
    bsptimer->tmr_initialized = 1;
    e580:	70ee      	strb	r6, [r5, #3]
    bsptimer->tc_mod.hw = tmr_cfg->hwtimer;
    e582:	61ab      	str	r3, [r5, #24]
  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    e584:	231f      	movs	r3, #31
    e586:	4013      	ands	r3, r2
    e588:	409e      	lsls	r6, r3
    e58a:	4b21      	ldr	r3, [pc, #132]	; (e610 <hal_timer_init+0xdc>)
    e58c:	67de      	str	r6, [r3, #124]	; 0x7c
  if ((int32_t)(IRQn) < 0)
    e58e:	2800      	cmp	r0, #0
    e590:	da21      	bge.n	e5d6 <hal_timer_init+0xa2>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e592:	2603      	movs	r6, #3
    e594:	230f      	movs	r3, #15
    e596:	4013      	ands	r3, r2
    e598:	4032      	ands	r2, r6
    e59a:	40b2      	lsls	r2, r6
    e59c:	36fc      	adds	r6, #252	; 0xfc
    e59e:	4096      	lsls	r6, r2
    e5a0:	3b08      	subs	r3, #8
    e5a2:	491c      	ldr	r1, [pc, #112]	; (e614 <hal_timer_init+0xe0>)
    e5a4:	089b      	lsrs	r3, r3, #2
    e5a6:	009b      	lsls	r3, r3, #2
    e5a8:	185b      	adds	r3, r3, r1
    e5aa:	69d9      	ldr	r1, [r3, #28]
    e5ac:	43b1      	bics	r1, r6
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    e5ae:	26c0      	movs	r6, #192	; 0xc0
    e5b0:	4096      	lsls	r6, r2
    e5b2:	0032      	movs	r2, r6
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e5b4:	430a      	orrs	r2, r1
    e5b6:	61da      	str	r2, [r3, #28]
    NVIC_SetPriority(irq_num, (1 << __NVIC_PRIO_BITS) - 1);
    NVIC_SetVector(irq_num, (uint32_t)irq_isr);
    e5b8:	4917      	ldr	r1, [pc, #92]	; (e618 <hal_timer_init+0xe4>)
    e5ba:	f7fe f879 	bl	c6b0 <NVIC_SetVector>
    e5be:	69ab      	ldr	r3, [r5, #24]
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (tc_module->SYNCBUSY.reg);
#else
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    e5c0:	7bda      	ldrb	r2, [r3, #15]
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	TcCount8 *const tc_module = &(module_inst->hw->COUNT8);

	while (tc_is_syncing(module_inst)) {
    e5c2:	b252      	sxtb	r2, r2
    e5c4:	2a00      	cmp	r2, #0
    e5c6:	dbfb      	blt.n	e5c0 <hal_timer_init+0x8c>
		/* Wait for sync */
	}

	/* Disable TC module */
	tc_module->CTRLA.reg  &= ~TC_CTRLA_ENABLE;
    e5c8:	2102      	movs	r1, #2
    e5ca:	881a      	ldrh	r2, [r3, #0]
    e5cc:	438a      	bics	r2, r1
    e5ce:	801a      	strh	r2, [r3, #0]

    return 0;

err:
    return rc;
}
    e5d0:	0020      	movs	r0, r4
    e5d2:	b005      	add	sp, #20
    e5d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e5d6:	2703      	movs	r7, #3
    e5d8:	403a      	ands	r2, r7
    e5da:	40ba      	lsls	r2, r7
    e5dc:	490f      	ldr	r1, [pc, #60]	; (e61c <hal_timer_init+0xe8>)
    e5de:	0883      	lsrs	r3, r0, #2
    e5e0:	009b      	lsls	r3, r3, #2
    e5e2:	185b      	adds	r3, r3, r1
    e5e4:	21c0      	movs	r1, #192	; 0xc0
    e5e6:	37fc      	adds	r7, #252	; 0xfc
    e5e8:	4097      	lsls	r7, r2
    e5ea:	0089      	lsls	r1, r1, #2
    e5ec:	585e      	ldr	r6, [r3, r1]
    e5ee:	43be      	bics	r6, r7
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
    e5f0:	27c0      	movs	r7, #192	; 0xc0
    e5f2:	4097      	lsls	r7, r2
    e5f4:	003a      	movs	r2, r7
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
    e5f6:	4332      	orrs	r2, r6
    e5f8:	505a      	str	r2, [r3, r1]
    e5fa:	e7dd      	b.n	e5b8 <hal_timer_init+0x84>
    SAMD21_HAL_TIMER_RESOLVE(timer_num, bsptimer);
    e5fc:	2416      	movs	r4, #22
    e5fe:	e7e7      	b.n	e5d0 <hal_timer_init+0x9c>
        rc = -1;
    e600:	2401      	movs	r4, #1
    e602:	4264      	negs	r4, r4
    e604:	e7e4      	b.n	e5d0 <hal_timer_init+0x9c>
    e606:	46c0      	nop			; (mov r8, r8)
    e608:	000109b0 	.word	0x000109b0
    e60c:	200024d4 	.word	0x200024d4
    e610:	e000e104 	.word	0xe000e104
    e614:	e000ed00 	.word	0xe000ed00
    e618:	0000e4b5 	.word	0x0000e4b5
    e61c:	e000e100 	.word	0xe000e100

0000e620 <hal_timer_config>:
 *
 * @return int
 */
int
hal_timer_config(int timer_num, uint32_t freq_hz)
{
    e620:	b5f0      	push	{r4, r5, r6, r7, lr}
    e622:	b091      	sub	sp, #68	; 0x44
    struct samd21_hal_timer *bsptimer;
    enum status_code tc_rc;
    struct tc_config cfg;

    /* Get timer. Make sure not enabled */
    SAMD21_HAL_TIMER_RESOLVE(timer_num, bsptimer);
    e624:	2802      	cmp	r0, #2
    e626:	dd03      	ble.n	e630 <hal_timer_config+0x10>
    e628:	2316      	movs	r3, #22

    return 0;

err:
    return rc;
}
    e62a:	0018      	movs	r0, r3
    e62c:	b011      	add	sp, #68	; 0x44
    e62e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    SAMD21_HAL_TIMER_RESOLVE(timer_num, bsptimer);
    e630:	4b3d      	ldr	r3, [pc, #244]	; (e728 <hal_timer_config+0x108>)
    e632:	0080      	lsls	r0, r0, #2
    e634:	58c6      	ldr	r6, [r0, r3]
    e636:	2e00      	cmp	r6, #0
    e638:	d0f6      	beq.n	e628 <hal_timer_config+0x8>
    if (bsptimer->tmr_enabled || (bsptimer->tmr_initialized == 0) ||
    e63a:	7834      	ldrb	r4, [r6, #0]
    e63c:	2c00      	cmp	r4, #0
    e63e:	d1f3      	bne.n	e628 <hal_timer_config+0x8>
    e640:	78f3      	ldrb	r3, [r6, #3]
    e642:	2b00      	cmp	r3, #0
    e644:	d0f0      	beq.n	e628 <hal_timer_config+0x8>
    e646:	2900      	cmp	r1, #0
    e648:	d0ee      	beq.n	e628 <hal_timer_config+0x8>
	config->clock_source               = GCLK_GENERATOR_0;
    e64a:	ad03      	add	r5, sp, #12
    e64c:	702c      	strb	r4, [r5, #0]
	config->counter_size               = TC_COUNTER_SIZE_16BIT;
    e64e:	70ac      	strb	r4, [r5, #2]
	config->clock_prescaler            = TC_CLOCK_PRESCALER_DIV1;
    e650:	80ac      	strh	r4, [r5, #4]
	config->wave_generation            = TC_WAVE_GENERATION_NORMAL_FREQ;
    e652:	71ac      	strb	r4, [r5, #6]
	config->reload_action              = TC_RELOAD_ACTION_GCLK;
    e654:	812c      	strh	r4, [r5, #8]
	config->run_in_standby             = false;
    e656:	706c      	strb	r4, [r5, #1]
	config->waveform_invert_output     = TC_WAVEFORM_INVERT_OUTPUT_NONE;
    e658:	72ac      	strb	r4, [r5, #10]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_0] = false;
    e65a:	72ec      	strb	r4, [r5, #11]
	config->enable_capture_on_channel[TC_COMPARE_CAPTURE_CHANNEL_1] = false;
    e65c:	732c      	strb	r4, [r5, #12]
	config->count_direction            = TC_COUNT_DIRECTION_UP;
    e65e:	73ac      	strb	r4, [r5, #14]
	config->oneshot                    = false;
    e660:	736c      	strb	r4, [r5, #13]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].enabled = false;
    e662:	742c      	strb	r4, [r5, #16]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_out = 0;
    e664:	616c      	str	r4, [r5, #20]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_0].pin_mux = 0;
    e666:	61ac      	str	r4, [r5, #24]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].enabled = false;
    e668:	772c      	strb	r4, [r5, #28]
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_out = 0;
    e66a:	940b      	str	r4, [sp, #44]	; 0x2c
    e66c:	940c      	str	r4, [sp, #48]	; 0x30
	config->pwm_channel[TC_COMPARE_CAPTURE_CHANNEL_1].pin_mux = 0;
    e66e:	940d      	str	r4, [sp, #52]	; 0x34
		[TC_COMPARE_CAPTURE_CHANNEL_0]                        = 0x0000;
    e670:	85ac      	strh	r4, [r5, #44]	; 0x2c
    e672:	78b3      	ldrb	r3, [r6, #2]
    e674:	3b03      	subs	r3, #3
    e676:	b2db      	uxtb	r3, r3
    e678:	2b05      	cmp	r3, #5
    e67a:	d852      	bhi.n	e722 <hal_timer_config+0x102>
    e67c:	4a2b      	ldr	r2, [pc, #172]	; (e72c <hal_timer_config+0x10c>)
    e67e:	009b      	lsls	r3, r3, #2
    e680:	589f      	ldr	r7, [r3, r2]
err:
    e682:	0023      	movs	r3, r4
    if (rc || (freq_hz > max_frequency) || (div == 0) || (div > 1024)) {
    e684:	428f      	cmp	r7, r1
    e686:	d3d0      	bcc.n	e62a <hal_timer_config+0xa>
    div = max_frequency / freq_hz;
    e688:	0038      	movs	r0, r7
    e68a:	f001 fedb 	bl	10444 <__udivsi3>
    if (rc || (freq_hz > max_frequency) || (div == 0) || (div > 1024)) {
    e68e:	4a28      	ldr	r2, [pc, #160]	; (e730 <hal_timer_config+0x110>)
    e690:	1e41      	subs	r1, r0, #1
err:
    e692:	0023      	movs	r3, r4
    if (rc || (freq_hz > max_frequency) || (div == 0) || (div > 1024)) {
    e694:	4291      	cmp	r1, r2
    e696:	d8c8      	bhi.n	e62a <hal_timer_config+0xa>
    if (div == 1) {
    e698:	2801      	cmp	r0, #1
    e69a:	d011      	beq.n	e6c0 <hal_timer_config+0xa0>
        prescaler_reg = 1;
    e69c:	3301      	adds	r3, #1
        prescaler = 1;
    e69e:	001c      	movs	r4, r3
            if (div <= (1 << prescaler)) {
    e6a0:	2101      	movs	r1, #1
    e6a2:	40a1      	lsls	r1, r4
    e6a4:	9101      	str	r1, [sp, #4]
    e6a6:	4281      	cmp	r1, r0
    e6a8:	d330      	bcc.n	e70c <hal_timer_config+0xec>
                min_delta = div - (1 << (prescaler - 1));
    e6aa:	2101      	movs	r1, #1
    e6ac:	1e62      	subs	r2, r4, #1
    e6ae:	4091      	lsls	r1, r2
    e6b0:	4694      	mov	ip, r2
    e6b2:	1a42      	subs	r2, r0, r1
                max_delta = (1 << prescaler) - div;
    e6b4:	9901      	ldr	r1, [sp, #4]
    e6b6:	1a08      	subs	r0, r1, r0
                if (min_delta < max_delta) {
    e6b8:	4282      	cmp	r2, r0
    e6ba:	d201      	bcs.n	e6c0 <hal_timer_config+0xa0>
                    prescaler -= 1;
    e6bc:	4662      	mov	r2, ip
    e6be:	b2d4      	uxtb	r4, r2
    cfg.clock_prescaler = prescaler_reg << TC_CTRLA_PRESCALER_Pos;
    e6c0:	021b      	lsls	r3, r3, #8
    e6c2:	80ab      	strh	r3, [r5, #4]
    cfg.clock_source = bsptimer->tmr_clkgen;
    e6c4:	1c73      	adds	r3, r6, #1
    e6c6:	7fd8      	ldrb	r0, [r3, #31]
    e6c8:	7028      	strb	r0, [r5, #0]
    system_gclk_gen_enable(bsptimer->tmr_clkgen);
    e6ca:	f7fd fdcd 	bl	c268 <system_gclk_gen_enable>
    tc_rc = tc_init(&bsptimer->tc_mod, bsptimer->tc_mod.hw, &cfg);
    e6ce:	0030      	movs	r0, r6
    e6d0:	002a      	movs	r2, r5
    e6d2:	69b1      	ldr	r1, [r6, #24]
    e6d4:	3018      	adds	r0, #24
    e6d6:	f000 fead 	bl	f434 <tc_init>
    if (tc_rc == STATUS_OK) {
    e6da:	2800      	cmp	r0, #0
    e6dc:	d1a4      	bne.n	e628 <hal_timer_config+0x8>
        bsptimer->tc_mod.hw->COUNT16.INTENSET.reg = TC_INTFLAG_OVF;
    e6de:	2201      	movs	r2, #1
    e6e0:	69b3      	ldr	r3, [r6, #24]
    e6e2:	735a      	strb	r2, [r3, #13]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    e6e4:	7bda      	ldrb	r2, [r3, #15]
	while (tc_is_syncing(module_inst)) {
    e6e6:	b252      	sxtb	r2, r2
    e6e8:	2a00      	cmp	r2, #0
    e6ea:	dbfb      	blt.n	e6e4 <hal_timer_config+0xc4>
	tc_module->CTRLA.reg |= TC_CTRLA_ENABLE;
    e6ec:	2202      	movs	r2, #2
    e6ee:	8819      	ldrh	r1, [r3, #0]
    bsptimer->tmr_freq = max_frequency / (1 << prescaler);
    e6f0:	40e7      	lsrs	r7, r4
    e6f2:	430a      	orrs	r2, r1
  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
    e6f4:	211f      	movs	r1, #31
    e6f6:	801a      	strh	r2, [r3, #0]
    bsptimer->tmr_enabled = 1;
    e6f8:	2301      	movs	r3, #1
    e6fa:	7872      	ldrb	r2, [r6, #1]
    e6fc:	7033      	strb	r3, [r6, #0]
    e6fe:	400a      	ands	r2, r1
    e700:	4093      	lsls	r3, r2
    e702:	4a0c      	ldr	r2, [pc, #48]	; (e734 <hal_timer_config+0x114>)
    bsptimer->tmr_freq = max_frequency / (1 << prescaler);
    e704:	60f7      	str	r7, [r6, #12]
    e706:	6013      	str	r3, [r2, #0]
    return 0;
    e708:	2300      	movs	r3, #0
    e70a:	e78e      	b.n	e62a <hal_timer_config+0xa>
            if (prescaler < 4) {
    e70c:	2c03      	cmp	r4, #3
    e70e:	d806      	bhi.n	e71e <hal_timer_config+0xfe>
                ++prescaler;
    e710:	3401      	adds	r4, #1
            ++prescaler_reg;
    e712:	3301      	adds	r3, #1
                prescaler += 2;
    e714:	b2e4      	uxtb	r4, r4
            ++prescaler_reg;
    e716:	b29b      	uxth	r3, r3
        while (prescaler < 11) {
    e718:	2c0a      	cmp	r4, #10
    e71a:	d9c1      	bls.n	e6a0 <hal_timer_config+0x80>
    e71c:	e7d0      	b.n	e6c0 <hal_timer_config+0xa0>
                prescaler += 2;
    e71e:	3402      	adds	r4, #2
    e720:	e7f7      	b.n	e712 <hal_timer_config+0xf2>
    switch (bsptimer->tmr_srcclk) {
    e722:	2301      	movs	r3, #1
    e724:	425b      	negs	r3, r3
    e726:	e780      	b.n	e62a <hal_timer_config+0xa>
    e728:	000109b0 	.word	0x000109b0
    e72c:	00010998 	.word	0x00010998
    e730:	000003ff 	.word	0x000003ff
    e734:	e000e100 	.word	0xe000e100

0000e738 <fill_tx_buf>:
    void *u_func_arg;
    const struct samd21_uart_config *u_cfg;
};
static struct hal_uart uarts[UART_CNT];

static int fill_tx_buf(struct hal_uart *u) {
    e738:	b570      	push	{r4, r5, r6, lr}
    e73a:	0005      	movs	r5, r0
    int i;

    for(i = 0; i < TX_BUFFER_SIZE; i++) {
    e73c:	2400      	movs	r4, #0
        int val;
        val = u->u_tx_func(u->u_func_arg);
    e73e:	6ce8      	ldr	r0, [r5, #76]	; 0x4c
    e740:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    e742:	4798      	blx	r3
        if(val < 0) {
    e744:	2800      	cmp	r0, #0
    e746:	db05      	blt.n	e754 <fill_tx_buf+0x1c>
            break;
        }
        u->txdata[i] = val;
    e748:	0023      	movs	r3, r4
    for(i = 0; i < TX_BUFFER_SIZE; i++) {
    e74a:	3401      	adds	r4, #1
        u->txdata[i] = val;
    e74c:	3338      	adds	r3, #56	; 0x38
    e74e:	54e8      	strb	r0, [r5, r3]
    for(i = 0; i < TX_BUFFER_SIZE; i++) {
    e750:	2c08      	cmp	r4, #8
    e752:	d1f4      	bne.n	e73e <fill_tx_buf+0x6>
    }
    return i;
}
    e754:	0020      	movs	r0, r4
    e756:	bd70      	pop	{r4, r5, r6, pc}

0000e758 <usart_callback_rx>:

static void
usart_callback_rx(struct usart_module *const module) {
    struct hal_uart *u = (struct hal_uart*) module;

    if(!u->u_open) {
    e758:	0003      	movs	r3, r0
usart_callback_rx(struct usart_module *const module) {
    e75a:	b510      	push	{r4, lr}
    if(!u->u_open) {
    e75c:	3334      	adds	r3, #52	; 0x34
    e75e:	781b      	ldrb	r3, [r3, #0]
usart_callback_rx(struct usart_module *const module) {
    e760:	0004      	movs	r4, r0
    if(!u->u_open) {
    e762:	2b00      	cmp	r3, #0
    e764:	d00b      	beq.n	e77e <usart_callback_rx+0x26>
        return;
    }

    if(u->u_rx_func) {
    e766:	6c03      	ldr	r3, [r0, #64]	; 0x40
    e768:	2b00      	cmp	r3, #0
    e76a:	d003      	beq.n	e774 <usart_callback_rx+0x1c>
        u->u_rx_func(u->u_func_arg, (uint8_t) u->rxdata);
    e76c:	8ec1      	ldrh	r1, [r0, #54]	; 0x36
    e76e:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
    e770:	b2c9      	uxtb	r1, r1
    e772:	4798      	blx	r3
    }
    usart_read_job(&u->instance, (uint16_t*) &u->rxdata);
    e774:	0021      	movs	r1, r4
    e776:	0020      	movs	r0, r4
    e778:	3136      	adds	r1, #54	; 0x36
    e77a:	f000 fd7a 	bl	f272 <usart_read_job>
}
    e77e:	bd10      	pop	{r4, pc}

0000e780 <usart_callback_txdone>:
    if(!u->u_open) {
    e780:	0003      	movs	r3, r0
usart_callback_txdone(struct usart_module *const module) {
    e782:	b510      	push	{r4, lr}
    if(!u->u_open) {
    e784:	3334      	adds	r3, #52	; 0x34
    e786:	781b      	ldrb	r3, [r3, #0]
usart_callback_txdone(struct usart_module *const module) {
    e788:	0004      	movs	r4, r0
    if(!u->u_open) {
    e78a:	2b00      	cmp	r3, #0
    e78c:	d00d      	beq.n	e7aa <usart_callback_txdone+0x2a>
    sz = fill_tx_buf(u);
    e78e:	f7ff ffd3 	bl	e738 <fill_tx_buf>
    e792:	0023      	movs	r3, r4
    e794:	3335      	adds	r3, #53	; 0x35
    if(sz > 0) {
    e796:	2800      	cmp	r0, #0
    e798:	dd08      	ble.n	e7ac <usart_callback_txdone+0x2c>
        u->tx_on=1;
    e79a:	2201      	movs	r2, #1
        usart_write_buffer_job(&u->instance, u->txdata, sz);
    e79c:	0021      	movs	r1, r4
        u->tx_on=1;
    e79e:	701a      	strb	r2, [r3, #0]
        usart_write_buffer_job(&u->instance, u->txdata, sz);
    e7a0:	3138      	adds	r1, #56	; 0x38
    e7a2:	b282      	uxth	r2, r0
    e7a4:	0020      	movs	r0, r4
    e7a6:	f000 fd69 	bl	f27c <usart_write_buffer_job>
}
    e7aa:	bd10      	pop	{r4, pc}
        u->tx_on = 0;
    e7ac:	2200      	movs	r2, #0
    e7ae:	701a      	strb	r2, [r3, #0]
        if(u->u_tx_done) {
    e7b0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    e7b2:	4293      	cmp	r3, r2
    e7b4:	d0f9      	beq.n	e7aa <usart_callback_txdone+0x2a>
            u->u_tx_done(u->u_func_arg);
    e7b6:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
    e7b8:	4798      	blx	r3
    e7ba:	e7f6      	b.n	e7aa <usart_callback_txdone+0x2a>

0000e7bc <hal_uart_init_cbs>:

int
hal_uart_init_cbs(int port, hal_uart_tx_char tx_func, hal_uart_tx_done tx_done,
  hal_uart_rx_char rx_func, void *arg)
{
    e7bc:	b510      	push	{r4, lr}
    struct hal_uart *u;

    u = &uarts[port];
    if (port >= UART_CNT || u->u_open) {
    e7be:	2805      	cmp	r0, #5
    e7c0:	dc0e      	bgt.n	e7e0 <hal_uart_init_cbs+0x24>
    e7c2:	2454      	movs	r4, #84	; 0x54
    e7c4:	4360      	muls	r0, r4
    e7c6:	4c08      	ldr	r4, [pc, #32]	; (e7e8 <hal_uart_init_cbs+0x2c>)
    e7c8:	1824      	adds	r4, r4, r0
    e7ca:	0020      	movs	r0, r4
    e7cc:	3034      	adds	r0, #52	; 0x34
    e7ce:	7800      	ldrb	r0, [r0, #0]
    e7d0:	2800      	cmp	r0, #0
    e7d2:	d105      	bne.n	e7e0 <hal_uart_init_cbs+0x24>
        return -1;
    }
    u->u_rx_func = rx_func;
    e7d4:	6423      	str	r3, [r4, #64]	; 0x40
    u->u_tx_func = tx_func;
    u->u_tx_done = tx_done;
    u->u_func_arg = arg;
    e7d6:	9b02      	ldr	r3, [sp, #8]
    u->u_tx_func = tx_func;
    e7d8:	6461      	str	r1, [r4, #68]	; 0x44
    u->u_tx_done = tx_done;
    e7da:	64a2      	str	r2, [r4, #72]	; 0x48
    u->u_func_arg = arg;
    e7dc:	64e3      	str	r3, [r4, #76]	; 0x4c
    return 0;
}
    e7de:	bd10      	pop	{r4, pc}
        return -1;
    e7e0:	2001      	movs	r0, #1
    e7e2:	4240      	negs	r0, r0
    e7e4:	e7fb      	b.n	e7de <hal_uart_init_cbs+0x22>
    e7e6:	46c0      	nop			; (mov r8, r8)
    e7e8:	20002060 	.word	0x20002060

0000e7ec <hal_uart_start_rx>:

void
hal_uart_start_rx(int port)
{
    e7ec:	b510      	push	{r4, lr}
    struct hal_uart *u;

    u = &uarts[port];
    if (port >= UART_CNT || !u->u_open) {
    e7ee:	2805      	cmp	r0, #5
    e7f0:	dc0c      	bgt.n	e80c <hal_uart_start_rx+0x20>
    e7f2:	2354      	movs	r3, #84	; 0x54
    e7f4:	4343      	muls	r3, r0
    e7f6:	4906      	ldr	r1, [pc, #24]	; (e810 <hal_uart_start_rx+0x24>)
    e7f8:	18c8      	adds	r0, r1, r3
    e7fa:	0002      	movs	r2, r0
    e7fc:	3234      	adds	r2, #52	; 0x34
    e7fe:	7812      	ldrb	r2, [r2, #0]
    e800:	2a00      	cmp	r2, #0
    e802:	d003      	beq.n	e80c <hal_uart_start_rx+0x20>
        return;
    }
    usart_read_job(&u->instance, (uint16_t*) &u->rxdata);
    e804:	3336      	adds	r3, #54	; 0x36
    e806:	1859      	adds	r1, r3, r1
    e808:	f000 fd33 	bl	f272 <usart_read_job>
}
    e80c:	bd10      	pop	{r4, pc}
    e80e:	46c0      	nop			; (mov r8, r8)
    e810:	20002060 	.word	0x20002060

0000e814 <hal_uart_start_tx>:

void
hal_uart_start_tx(int port)
{
    e814:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    struct hal_uart *u;
    u = &uarts[port];
    if (port >= UART_CNT || !u->u_open) {
    e816:	2805      	cmp	r0, #5
    e818:	dc1e      	bgt.n	e858 <hal_uart_start_tx+0x44>
    e81a:	2454      	movs	r4, #84	; 0x54
    e81c:	4344      	muls	r4, r0
    e81e:	4e0f      	ldr	r6, [pc, #60]	; (e85c <hal_uart_start_tx+0x48>)
    e820:	1935      	adds	r5, r6, r4
    e822:	002b      	movs	r3, r5
    e824:	3334      	adds	r3, #52	; 0x34
    e826:	781b      	ldrb	r3, [r3, #0]
    e828:	2b00      	cmp	r3, #0
    e82a:	d015      	beq.n	e858 <hal_uart_start_tx+0x44>
        return;
    }

    if(u->tx_on) {
    e82c:	002f      	movs	r7, r5
    e82e:	3735      	adds	r7, #53	; 0x35
    e830:	783b      	ldrb	r3, [r7, #0]
    e832:	2b00      	cmp	r3, #0
    e834:	d110      	bne.n	e858 <hal_uart_start_tx+0x44>
        /* we are already transmitting */
        return;
    }

    if(u->u_tx_func) {
    e836:	6c6b      	ldr	r3, [r5, #68]	; 0x44
    e838:	2b00      	cmp	r3, #0
    e83a:	d00d      	beq.n	e858 <hal_uart_start_tx+0x44>
        int sz;
        sz = fill_tx_buf(u);
    e83c:	0028      	movs	r0, r5
    e83e:	f7ff ff7b 	bl	e738 <fill_tx_buf>
        if(sz > 0) {
    e842:	2800      	cmp	r0, #0
    e844:	dd08      	ble.n	e858 <hal_uart_start_tx+0x44>
            u->tx_on=1;
            usart_write_buffer_job(&u->instance, u->txdata, sz);
    e846:	0021      	movs	r1, r4
            u->tx_on=1;
    e848:	2301      	movs	r3, #1
            usart_write_buffer_job(&u->instance, u->txdata, sz);
    e84a:	3138      	adds	r1, #56	; 0x38
    e84c:	b282      	uxth	r2, r0
            u->tx_on=1;
    e84e:	703b      	strb	r3, [r7, #0]
            usart_write_buffer_job(&u->instance, u->txdata, sz);
    e850:	1989      	adds	r1, r1, r6
    e852:	0028      	movs	r0, r5
    e854:	f000 fd12 	bl	f27c <usart_write_buffer_job>
        }
    }
}
    e858:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    e85a:	46c0      	nop			; (mov r8, r8)
    e85c:	20002060 	.word	0x20002060

0000e860 <hal_uart_blocking_tx>:

void
hal_uart_blocking_tx(int port, uint8_t data)
{
    e860:	0003      	movs	r3, r0
    struct hal_uart *u;
    u = &uarts[port];

    if(!u->u_open) {
    e862:	2054      	movs	r0, #84	; 0x54
    e864:	4358      	muls	r0, r3
    e866:	4b0a      	ldr	r3, [pc, #40]	; (e890 <hal_uart_blocking_tx+0x30>)
{
    e868:	b570      	push	{r4, r5, r6, lr}
    if(!u->u_open) {
    e86a:	1818      	adds	r0, r3, r0
    e86c:	0003      	movs	r3, r0
    e86e:	3334      	adds	r3, #52	; 0x34
    e870:	781b      	ldrb	r3, [r3, #0]
    e872:	2b00      	cmp	r3, #0
    e874:	d00b      	beq.n	e88e <hal_uart_blocking_tx+0x2e>
{
	/* Sanity check arguments */
	Assert(module);

	/* Disable callback */
	module->callback_enable_mask &= ~(1 << callback_type);
    e876:	0004      	movs	r4, r0
    e878:	2501      	movs	r5, #1
    e87a:	3431      	adds	r4, #49	; 0x31
    e87c:	7823      	ldrb	r3, [r4, #0]
        return;
    }

    usart_disable_callback(&u->instance, USART_CALLBACK_BUFFER_TRANSMITTED);
    usart_write_wait(&u->instance, data);
    e87e:	b289      	uxth	r1, r1
    e880:	43ab      	bics	r3, r5
    e882:	7023      	strb	r3, [r4, #0]
    e884:	f000 fc94 	bl	f1b0 <usart_write_wait>
	module->callback_enable_mask |= (1 << callback_type);
    e888:	7823      	ldrb	r3, [r4, #0]
    e88a:	431d      	orrs	r5, r3
    e88c:	7025      	strb	r5, [r4, #0]
    usart_enable_callback(&u->instance, USART_CALLBACK_BUFFER_TRANSMITTED);
}
    e88e:	bd70      	pop	{r4, r5, r6, pc}
    e890:	20002060 	.word	0x20002060

0000e894 <hal_uart_config>:

int
hal_uart_config(int port, int32_t baudrate, uint8_t databits, uint8_t stopbits,
  enum hal_uart_parity parity, enum hal_uart_flow_ctl flow_ctl)
{
    e894:	b5f0      	push	{r4, r5, r6, r7, lr}
    e896:	b095      	sub	sp, #84	; 0x54
    e898:	9202      	str	r2, [sp, #8]
    e89a:	aa1a      	add	r2, sp, #104	; 0x68
    e89c:	7816      	ldrb	r6, [r2, #0]
    e89e:	aa1b      	add	r2, sp, #108	; 0x6c
    e8a0:	7812      	ldrb	r2, [r2, #0]
    e8a2:	0005      	movs	r5, r0
    e8a4:	9203      	str	r2, [sp, #12]
    struct usart_config config_usart;
    const struct samd21_uart_config *samd21_cfg;
    SercomUsart *su;
    int i;

    if (uarts[port].u_open) {
    e8a6:	2254      	movs	r2, #84	; 0x54
    e8a8:	4342      	muls	r2, r0
    e8aa:	4861      	ldr	r0, [pc, #388]	; (ea30 <hal_uart_config+0x19c>)
{
    e8ac:	9101      	str	r1, [sp, #4]
    if (uarts[port].u_open) {
    e8ae:	1880      	adds	r0, r0, r2
    e8b0:	0002      	movs	r2, r0
    e8b2:	3234      	adds	r2, #52	; 0x34
    e8b4:	7812      	ldrb	r2, [r2, #0]
{
    e8b6:	9300      	str	r3, [sp, #0]
    if (uarts[port].u_open) {
    e8b8:	2a00      	cmp	r2, #0
    e8ba:	d003      	beq.n	e8c4 <hal_uart_config+0x30>
            break;
        case 9:
            config_usart.character_size = USART_CHARACTER_SIZE_9BIT;
            break;
        default:
            return -1;
    e8bc:	2001      	movs	r0, #1
    e8be:	4240      	negs	r0, r0
    uarts[port].u_open = 1;

    hal_uart_start_rx(port);

    return 0;
}
    e8c0:	b015      	add	sp, #84	; 0x54
    e8c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    samd21_cfg = uarts[port].u_cfg;
    e8c4:	6d04      	ldr	r4, [r0, #80]	; 0x50
    if (!samd21_cfg) {
    e8c6:	2c00      	cmp	r4, #0
    e8c8:	d0f8      	beq.n	e8bc <hal_uart_config+0x28>
{
	/* Sanity check arguments */
	Assert(config);

	/* Set default config in the config struct */
	config->data_order       = USART_DATAORDER_LSB;
    e8ca:	2080      	movs	r0, #128	; 0x80
    e8cc:	05c0      	lsls	r0, r0, #23
    e8ce:	9004      	str	r0, [sp, #16]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
	config->parity           = USART_PARITY_NONE;
    e8d0:	20ff      	movs	r0, #255	; 0xff
    e8d2:	af04      	add	r7, sp, #16
    e8d4:	8138      	strh	r0, [r7, #8]
	config->stopbits         = USART_STOPBITS_1;
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
	config->baudrate         = 9600;
	config->receiver_enable  = true;
    e8d6:	2001      	movs	r0, #1
	config->stopbits         = USART_STOPBITS_1;
    e8d8:	72ba      	strb	r2, [r7, #10]
	config->character_size   = USART_CHARACTER_SIZE_8BIT;
    e8da:	72fa      	strb	r2, [r7, #11]
	config->receiver_enable  = true;
    e8dc:	3705      	adds	r7, #5
    e8de:	77f8      	strb	r0, [r7, #31]
	config->transmitter_enable = true;
    e8e0:	af04      	add	r7, sp, #16
    e8e2:	3706      	adds	r7, #6
    e8e4:	77f8      	strb	r0, [r7, #31]
	config->clock_polarity_inverted = false;
    e8e6:	af04      	add	r7, sp, #16
    e8e8:	3707      	adds	r7, #7
    e8ea:	77fa      	strb	r2, [r7, #31]
	config->use_external_clock = false;
    e8ec:	af06      	add	r7, sp, #24
    e8ee:	77fa      	strb	r2, [r7, #31]
	config->ext_clock_freq   = 0;
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
    e8f0:	2788      	movs	r7, #136	; 0x88
#ifdef FEATURE_USART_START_FRAME_DECTION
	config->start_frame_detection_enable            = false;
#endif
#ifdef FEATURE_USART_IRDA
	config->encoding_format_enable                  = false;
	config->receive_pulse_length                    = 19;
    e8f2:	2113      	movs	r1, #19
	config->mux_setting      = USART_RX_1_TX_2_XCK_3;
    e8f4:	037f      	lsls	r7, r7, #13
    e8f6:	9707      	str	r7, [sp, #28]
	config->run_in_standby   = false;
    e8f8:	af0f      	add	r7, sp, #60	; 0x3c
    e8fa:	703a      	strb	r2, [r7, #0]
	config->receive_pulse_length                    = 19;
    e8fc:	468c      	mov	ip, r1
	config->generator_source = GCLK_GENERATOR_0;
    e8fe:	272d      	movs	r7, #45	; 0x2d
    e900:	ab04      	add	r3, sp, #16
	config->receive_pulse_length                    = 19;
    e902:	0019      	movs	r1, r3
	config->generator_source = GCLK_GENERATOR_0;
    e904:	18ff      	adds	r7, r7, r3
	config->sample_rate           = USART_SAMPLE_RATE_16X_ARITHMETIC;
    e906:	821a      	strh	r2, [r3, #16]
	config->lin_slave_enable      = false;
    e908:	76da      	strb	r2, [r3, #27]
	config->immediate_buffer_overflow_notification  = false;
    e90a:	761a      	strb	r2, [r3, #24]
	config->start_frame_detection_enable            = false;
    e90c:	771a      	strb	r2, [r3, #28]
	config->encoding_format_enable                  = false;
    e90e:	765a      	strb	r2, [r3, #25]
	config->receive_pulse_length                    = 19;
    e910:	4663      	mov	r3, ip
	config->iso7816_config.inhibit_nack             = ISO7816_INHIBIT_NACK_DISABLE;
	config->iso7816_config.successive_recv_nack     = ISO7816_SUCCESSIVE_RECV_NACK_DISABLE;
	config->iso7816_config.max_iterations           = 7;
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
	config->collision_detection_enable              = false;
    e912:	774a      	strb	r2, [r1, #29]
	config->transfer_mode    = USART_TRANSFER_ASYNCHRONOUSLY;
    e914:	9205      	str	r2, [sp, #20]
	config->ext_clock_freq   = 0;
    e916:	920e      	str	r2, [sp, #56]	; 0x38
	config->generator_source = GCLK_GENERATOR_0;
    e918:	703a      	strb	r2, [r7, #0]
	config->pinmux_pad0      = PINMUX_DEFAULT;
    e91a:	9210      	str	r2, [sp, #64]	; 0x40
	config->pinmux_pad1      = PINMUX_DEFAULT;
    e91c:	9211      	str	r2, [sp, #68]	; 0x44
	config->pinmux_pad2      = PINMUX_DEFAULT;
    e91e:	9212      	str	r2, [sp, #72]	; 0x48
	config->pinmux_pad3      = PINMUX_DEFAULT;
    e920:	9213      	str	r2, [sp, #76]	; 0x4c
	config->sample_adjustment     = USART_SAMPLE_ADJUSTMENT_7_8_9;
    e922:	9209      	str	r2, [sp, #36]	; 0x24
    switch(databits) {
    e924:	9a02      	ldr	r2, [sp, #8]
	config->receive_pulse_length                    = 19;
    e926:	768b      	strb	r3, [r1, #26]
    config_usart.baudrate    = baudrate;
    e928:	9b01      	ldr	r3, [sp, #4]
    switch(databits) {
    e92a:	3a05      	subs	r2, #5
    config_usart.baudrate    = baudrate;
    e92c:	930c      	str	r3, [sp, #48]	; 0x30
    e92e:	0001      	movs	r1, r0
    switch(databits) {
    e930:	2a04      	cmp	r2, #4
    e932:	d8c3      	bhi.n	e8bc <hal_uart_config+0x28>
    e934:	0010      	movs	r0, r2
    e936:	f001 fd7b 	bl	10430 <__gnu_thumb1_case_uqi>
    e93a:	0e03      	.short	0x0e03
    e93c:	0610      	.short	0x0610
    e93e:	12          	.byte	0x12
    e93f:	00          	.byte	0x00
            config_usart.character_size = USART_CHARACTER_SIZE_5BIT;
    e940:	2205      	movs	r2, #5
            config_usart.character_size = USART_CHARACTER_SIZE_6BIT;
    e942:	ab04      	add	r3, sp, #16
    e944:	72da      	strb	r2, [r3, #11]
    switch(parity) {
    e946:	2e01      	cmp	r6, #1
    e948:	d00c      	beq.n	e964 <hal_uart_config+0xd0>
    e94a:	2e00      	cmp	r6, #0
    e94c:	d00e      	beq.n	e96c <hal_uart_config+0xd8>
    e94e:	2e02      	cmp	r6, #2
    e950:	d1b4      	bne.n	e8bc <hal_uart_config+0x28>
            config_usart.parity = USART_PARITY_EVEN;
    e952:	2200      	movs	r2, #0
    e954:	e008      	b.n	e968 <hal_uart_config+0xd4>
            config_usart.character_size = USART_CHARACTER_SIZE_6BIT;
    e956:	2206      	movs	r2, #6
    e958:	e7f3      	b.n	e942 <hal_uart_config+0xae>
            config_usart.character_size = USART_CHARACTER_SIZE_7BIT;
    e95a:	2207      	movs	r2, #7
    e95c:	e7f1      	b.n	e942 <hal_uart_config+0xae>
            config_usart.character_size = USART_CHARACTER_SIZE_9BIT;
    e95e:	ab04      	add	r3, sp, #16
    e960:	72d9      	strb	r1, [r3, #11]
            break;
    e962:	e7f0      	b.n	e946 <hal_uart_config+0xb2>
            config_usart.parity = USART_PARITY_ODD;
    e964:	2280      	movs	r2, #128	; 0x80
    e966:	0192      	lsls	r2, r2, #6
            config_usart.parity = USART_PARITY_EVEN;
    e968:	ab04      	add	r3, sp, #16
    e96a:	811a      	strh	r2, [r3, #8]
    switch(stopbits) {
    e96c:	9b00      	ldr	r3, [sp, #0]
    e96e:	2b01      	cmp	r3, #1
    e970:	d004      	beq.n	e97c <hal_uart_config+0xe8>
    e972:	2b02      	cmp	r3, #2
    e974:	d1a2      	bne.n	e8bc <hal_uart_config+0x28>
            config_usart.stopbits = USART_STOPBITS_2;
    e976:	333e      	adds	r3, #62	; 0x3e
    e978:	aa04      	add	r2, sp, #16
    e97a:	7293      	strb	r3, [r2, #10]
    switch(flow_ctl) {
    e97c:	9b03      	ldr	r3, [sp, #12]
    e97e:	2b01      	cmp	r3, #1
    e980:	d89c      	bhi.n	e8bc <hal_uart_config+0x28>
    config_usart.mux_setting       = samd21_cfg->suc_mux_setting;
    e982:	6863      	ldr	r3, [r4, #4]
    config_usart.sample_rate       = samd21_cfg->suc_sample_rate;
    e984:	aa04      	add	r2, sp, #16
    config_usart.mux_setting       = samd21_cfg->suc_mux_setting;
    e986:	9307      	str	r3, [sp, #28]
    config_usart.generator_source  = samd21_cfg->suc_generator_source;
    e988:	7a23      	ldrb	r3, [r4, #8]
    su = &samd21_cfg->suc_sercom->USART;
    e98a:	6821      	ldr	r1, [r4, #0]
    config_usart.generator_source  = samd21_cfg->suc_generator_source;
    e98c:	703b      	strb	r3, [r7, #0]
    config_usart.sample_adjustment = samd21_cfg->suc_sample_adjustment;
    e98e:	68e3      	ldr	r3, [r4, #12]
    e990:	9309      	str	r3, [sp, #36]	; 0x24
    config_usart.sample_rate       = samd21_cfg->suc_sample_rate;
    e992:	8963      	ldrh	r3, [r4, #10]
    e994:	8213      	strh	r3, [r2, #16]
    su->CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    e996:	2202      	movs	r2, #2
    config_usart.pinmux_pad0       = samd21_cfg->suc_pad0;
    e998:	6923      	ldr	r3, [r4, #16]
    e99a:	9310      	str	r3, [sp, #64]	; 0x40
    config_usart.pinmux_pad1       = samd21_cfg->suc_pad1;
    e99c:	6963      	ldr	r3, [r4, #20]
    e99e:	9311      	str	r3, [sp, #68]	; 0x44
    config_usart.pinmux_pad2       = samd21_cfg->suc_pad2;
    e9a0:	69a3      	ldr	r3, [r4, #24]
    e9a2:	9312      	str	r3, [sp, #72]	; 0x48
    config_usart.pinmux_pad3       = samd21_cfg->suc_pad3;
    e9a4:	69e3      	ldr	r3, [r4, #28]
    e9a6:	9313      	str	r3, [sp, #76]	; 0x4c
    su->CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    e9a8:	680b      	ldr	r3, [r1, #0]
    e9aa:	4393      	bics	r3, r2
    e9ac:	600b      	str	r3, [r1, #0]
    su->CTRLA.reg |= SERCOM_USART_CTRLA_SWRST;
    e9ae:	2301      	movs	r3, #1
    e9b0:	680a      	ldr	r2, [r1, #0]
    e9b2:	431a      	orrs	r2, r3
    e9b4:	600a      	str	r2, [r1, #0]
    e9b6:	2264      	movs	r2, #100	; 0x64
        if ((su->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) == 0) {
    e9b8:	6808      	ldr	r0, [r1, #0]
    e9ba:	4218      	tst	r0, r3
    e9bc:	d002      	beq.n	e9c4 <hal_uart_config+0x130>
    e9be:	3a01      	subs	r2, #1
    for (i = 0; i < 100; i++) {
    e9c0:	2a00      	cmp	r2, #0
    e9c2:	d1f9      	bne.n	e9b8 <hal_uart_config+0x124>
    struct usart_module *pinst = &uarts[port].instance;
    e9c4:	2654      	movs	r6, #84	; 0x54
    e9c6:	436e      	muls	r6, r5
    e9c8:	4c19      	ldr	r4, [pc, #100]	; (ea30 <hal_uart_config+0x19c>)
    if (usart_init(pinst, samd21_cfg->suc_sercom, &config_usart) != STATUS_OK) {
    e9ca:	aa04      	add	r2, sp, #16
    struct usart_module *pinst = &uarts[port].instance;
    e9cc:	1937      	adds	r7, r6, r4
    if (usart_init(pinst, samd21_cfg->suc_sercom, &config_usart) != STATUS_OK) {
    e9ce:	0038      	movs	r0, r7
    e9d0:	f000 faa8 	bl	ef24 <usart_init>
    e9d4:	1e02      	subs	r2, r0, #0
    e9d6:	d000      	beq.n	e9da <hal_uart_config+0x146>
    e9d8:	e770      	b.n	e8bc <hal_uart_config+0x28>
    usart_register_callback(pinst, usart_callback_txdone,
    e9da:	0038      	movs	r0, r7
    e9dc:	4915      	ldr	r1, [pc, #84]	; (ea34 <hal_uart_config+0x1a0>)
    e9de:	f000 fc3c 	bl	f25a <usart_register_callback>
    usart_register_callback(pinst, usart_callback_rx,
    e9e2:	0038      	movs	r0, r7
    e9e4:	2201      	movs	r2, #1
    e9e6:	4914      	ldr	r1, [pc, #80]	; (ea38 <hal_uart_config+0x1a4>)
    e9e8:	f000 fc37 	bl	f25a <usart_register_callback>
    e9ec:	2303      	movs	r3, #3
    e9ee:	3731      	adds	r7, #49	; 0x31
    e9f0:	783a      	ldrb	r2, [r7, #0]
    e9f2:	4313      	orrs	r3, r2
    e9f4:	703b      	strb	r3, [r7, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    e9f6:	5937      	ldr	r7, [r6, r4]

#if USART_CALLBACK_MODE == true
	/* Enable Global interrupt for module */
	system_interrupt_enable(_sercom_get_interrupt_vector(module->hw));
    e9f8:	0038      	movs	r0, r7
    e9fa:	f000 fa3b 	bl	ee74 <_sercom_get_interrupt_vector>
    e9fe:	231f      	movs	r3, #31
    ea00:	4018      	ands	r0, r3
    ea02:	3b1e      	subs	r3, #30
    ea04:	4083      	lsls	r3, r0
    ea06:	4a0d      	ldr	r2, [pc, #52]	; (ea3c <hal_uart_config+0x1a8>)
    ea08:	6013      	str	r3, [r2, #0]
	SercomUsart *const usart_hw = &(module->hw->USART);
    ea0a:	5933      	ldr	r3, [r6, r4]
	return (usart_hw->SYNCBUSY.reg);
    ea0c:	69de      	ldr	r6, [r3, #28]
	while (usart_is_syncing(module)) {
    ea0e:	2e00      	cmp	r6, #0
    ea10:	d1fc      	bne.n	ea0c <hal_uart_config+0x178>

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Enable USART module */
	usart_hw->CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
    ea12:	2302      	movs	r3, #2
    ea14:	683a      	ldr	r2, [r7, #0]
    hal_uart_start_rx(port);
    ea16:	0028      	movs	r0, r5
    ea18:	4313      	orrs	r3, r2
    ea1a:	603b      	str	r3, [r7, #0]
    uarts[port].u_open = 1;
    ea1c:	2354      	movs	r3, #84	; 0x54
    ea1e:	436b      	muls	r3, r5
    ea20:	18e4      	adds	r4, r4, r3
    ea22:	2301      	movs	r3, #1
    ea24:	3434      	adds	r4, #52	; 0x34
    ea26:	7023      	strb	r3, [r4, #0]
    hal_uart_start_rx(port);
    ea28:	f7ff fee0 	bl	e7ec <hal_uart_start_rx>
    return 0;
    ea2c:	0030      	movs	r0, r6
    ea2e:	e747      	b.n	e8c0 <hal_uart_config+0x2c>
    ea30:	20002060 	.word	0x20002060
    ea34:	0000e781 	.word	0x0000e781
    ea38:	0000e759 	.word	0x0000e759
    ea3c:	e000e100 	.word	0xe000e100

0000ea40 <hal_uart_close>:

int
hal_uart_close(int port)
{
    ea40:	b570      	push	{r4, r5, r6, lr}
	module->callback_enable_mask &= ~(1 << callback_type);
    ea42:	2454      	movs	r4, #84	; 0x54
    ea44:	2103      	movs	r1, #3
    ea46:	4344      	muls	r4, r0
    ea48:	4d0c      	ldr	r5, [pc, #48]	; (ea7c <hal_uart_close+0x3c>)
    ea4a:	192b      	adds	r3, r5, r4
    ea4c:	3331      	adds	r3, #49	; 0x31
    ea4e:	781a      	ldrb	r2, [r3, #0]
	/* Sanity check arguments */
	Assert(module);
	Assert(module->hw);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    ea50:	5966      	ldr	r6, [r4, r5]
    ea52:	438a      	bics	r2, r1
    ea54:	701a      	strb	r2, [r3, #0]

#if USART_CALLBACK_MODE == true
	/* Disable Global interrupt for module */
	system_interrupt_disable(_sercom_get_interrupt_vector(module->hw));
    ea56:	0030      	movs	r0, r6
    ea58:	f000 fa0c 	bl	ee74 <_sercom_get_interrupt_vector>
 * \param[in] vector  Interrupt vector to disable
 */
static inline void system_interrupt_disable(
		const enum system_interrupt_vector vector)
{
	NVIC->ICER[0] = (uint32_t)(1 << ((uint32_t)vector & 0x0000001f));
    ea5c:	231f      	movs	r3, #31
    ea5e:	4018      	ands	r0, r3
    ea60:	3b1e      	subs	r3, #30
    ea62:	4083      	lsls	r3, r0
    ea64:	4a06      	ldr	r2, [pc, #24]	; (ea80 <hal_uart_close+0x40>)
    ea66:	67d3      	str	r3, [r2, #124]	; 0x7c
	SercomUsart *const usart_hw = &(module->hw->USART);
    ea68:	5963      	ldr	r3, [r4, r5]
	return (usart_hw->SYNCBUSY.reg);
    ea6a:	69d8      	ldr	r0, [r3, #28]
	while (usart_is_syncing(module)) {
    ea6c:	2800      	cmp	r0, #0
    ea6e:	d1fc      	bne.n	ea6a <hal_uart_close+0x2a>
#endif
	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);

	/* Disable USART module */
	usart_hw->CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
    ea70:	2202      	movs	r2, #2
    ea72:	6833      	ldr	r3, [r6, #0]
    ea74:	4393      	bics	r3, r2
    ea76:	6033      	str	r3, [r6, #0]
    usart_disable_callback(pinst, USART_CALLBACK_BUFFER_TRANSMITTED);
    usart_disable_callback(pinst, USART_CALLBACK_BUFFER_RECEIVED);
    usart_disable(pinst);

    return 0;
}
    ea78:	bd70      	pop	{r4, r5, r6, pc}
    ea7a:	46c0      	nop			; (mov r8, r8)
    ea7c:	20002060 	.word	0x20002060
    ea80:	e000e104 	.word	0xe000e104

0000ea84 <hal_uart_init>:
int
hal_uart_init(int port, void *arg)
{
    struct hal_uart *u;

    if (port >= UART_CNT) {
    ea84:	2805      	cmp	r0, #5
    ea86:	dc06      	bgt.n	ea96 <hal_uart_init+0x12>
        return -1;
    }
    u = &uarts[port];
    u->u_cfg = (const struct samd21_uart_config *)arg;
    ea88:	2354      	movs	r3, #84	; 0x54
    ea8a:	4343      	muls	r3, r0
    ea8c:	4803      	ldr	r0, [pc, #12]	; (ea9c <hal_uart_init+0x18>)
    ea8e:	18c0      	adds	r0, r0, r3
    ea90:	6501      	str	r1, [r0, #80]	; 0x50

    return 0;
    ea92:	2000      	movs	r0, #0
}
    ea94:	4770      	bx	lr
        return -1;
    ea96:	2001      	movs	r0, #1
    ea98:	4240      	negs	r0, r0
    ea9a:	e7fb      	b.n	ea94 <hal_uart_init+0x10>
    ea9c:	20002060 	.word	0x20002060

0000eaa0 <hal_watchdog_init>:

struct wdt_conf g_wdt_config;

int
hal_watchdog_init(uint32_t expire_msecs)
{
    eaa0:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* Default configuration values */
	config->always_on            = false;
	config->enable               = true;
#if !(SAML21) && !(SAML22) && !(SAMC20) && !(SAMC21)
	config->clock_source         = GCLK_GENERATOR_4;
    eaa2:	2204      	movs	r2, #4
	config->always_on            = false;
    eaa4:	2300      	movs	r3, #0
     * XXX: change this!
     * Another note: since we dont know if the oscillator is calibrated,
     * we multiply the number of clocks by 2.
     */
    clocks = 32768 / 2048;
    clocks = (clocks * expire_msecs) / 1000;
    eaa6:	21fa      	movs	r1, #250	; 0xfa
    eaa8:	4c18      	ldr	r4, [pc, #96]	; (eb0c <hal_watchdog_init+0x6c>)
    eaaa:	0100      	lsls	r0, r0, #4
	config->clock_source         = GCLK_GENERATOR_4;
    eaac:	70a2      	strb	r2, [r4, #2]
#endif
	config->timeout_period       = WDT_PERIOD_16384CLK;
    eaae:	3208      	adds	r2, #8
	config->always_on            = false;
    eab0:	7023      	strb	r3, [r4, #0]
	config->timeout_period       = WDT_PERIOD_16384CLK;
    eab2:	70e2      	strb	r2, [r4, #3]
	config->window_period        = WDT_PERIOD_NONE;
    eab4:	7123      	strb	r3, [r4, #4]
	config->early_warning_period = WDT_PERIOD_NONE;
    eab6:	7163      	strb	r3, [r4, #5]
    g_wdt_config.enable = false;
    eab8:	7063      	strb	r3, [r4, #1]
    clocks = (clocks * expire_msecs) / 1000;
    eaba:	0089      	lsls	r1, r1, #2
    eabc:	f001 fcc2 	bl	10444 <__udivsi3>
    clocks = clocks * 2;

    /* The watchdog count starts at 8 and goes up to 16384 max. */
    temp = 8;
    to_period = WDT_PERIOD_8CLK;
    eac0:	2301      	movs	r3, #1
    temp = 8;
    eac2:	2208      	movs	r2, #8
    clocks = clocks * 2;
    eac4:	0040      	lsls	r0, r0, #1
    while (1) {
        if (clocks <= temp) {
    eac6:	4282      	cmp	r2, r0
    eac8:	d208      	bcs.n	eadc <hal_watchdog_init+0x3c>
            break;
        }
        temp <<= 1;
        ++to_period;
    eaca:	3301      	adds	r3, #1
        temp <<= 1;
    eacc:	0052      	lsls	r2, r2, #1
        ++to_period;
    eace:	b29b      	uxth	r3, r3
        temp <<= 1;
    ead0:	b292      	uxth	r2, r2
        if (to_period > WDT_PERIOD_16384CLK) {
    ead2:	2b0d      	cmp	r3, #13
    ead4:	d1f7      	bne.n	eac6 <hal_watchdog_init+0x26>
            return -1;
    ead6:	2001      	movs	r0, #1
    ead8:	4240      	negs	r0, r0
    eada:	e014      	b.n	eb06 <hal_watchdog_init+0x66>
        }
    }
    g_wdt_config.timeout_period = to_period;
    eadc:	70e3      	strb	r3, [r4, #3]

    gcfg.division_factor = 2048;
    eade:	2380      	movs	r3, #128	; 0x80
    eae0:	a901      	add	r1, sp, #4
    eae2:	011b      	lsls	r3, r3, #4
    eae4:	604b      	str	r3, [r1, #4]
    gcfg.high_when_disabled = false;
    eae6:	2300      	movs	r3, #0
    eae8:	704b      	strb	r3, [r1, #1]
    gcfg.output_enable = true;  /* XXX: why is this set true? */
    eaea:	3301      	adds	r3, #1
    eaec:	724b      	strb	r3, [r1, #9]
    gcfg.run_in_standby = true;
    eaee:	720b      	strb	r3, [r1, #8]
    gcfg.source_clock = GCLK_SOURCE_OSCULP32K;
    system_gclk_gen_set_config(g_wdt_config.clock_source, &gcfg);
    eaf0:	2004      	movs	r0, #4
    gcfg.source_clock = GCLK_SOURCE_OSCULP32K;
    eaf2:	3302      	adds	r3, #2
    eaf4:	700b      	strb	r3, [r1, #0]
    system_gclk_gen_set_config(g_wdt_config.clock_source, &gcfg);
    eaf6:	f7fd fb69 	bl	c1cc <system_gclk_gen_set_config>
    system_gclk_gen_enable(g_wdt_config.clock_source);
    eafa:	78a0      	ldrb	r0, [r4, #2]
    eafc:	f7fd fbb4 	bl	c268 <system_gclk_gen_enable>

    /* We init but dont turn on device */
    rc = wdt_set_config(&g_wdt_config);
    eb00:	0020      	movs	r0, r4
    eb02:	f000 fdd3 	bl	f6ac <wdt_set_config>

    return ((int)rc);
}
    eb06:	b004      	add	sp, #16
    eb08:	bd10      	pop	{r4, pc}
    eb0a:	46c0      	nop			; (mov r8, r8)
    eb0c:	200024f8 	.word	0x200024f8

0000eb10 <hal_watchdog_enable>:

void
hal_watchdog_enable(void)
{
    g_wdt_config.enable = true;
    eb10:	2301      	movs	r3, #1
{
    eb12:	b510      	push	{r4, lr}
    g_wdt_config.enable = true;
    eb14:	4802      	ldr	r0, [pc, #8]	; (eb20 <hal_watchdog_enable+0x10>)
    eb16:	7043      	strb	r3, [r0, #1]
    wdt_set_config(&g_wdt_config);
    eb18:	f000 fdc8 	bl	f6ac <wdt_set_config>
}
    eb1c:	bd10      	pop	{r4, pc}
    eb1e:	46c0      	nop			; (mov r8, r8)
    eb20:	200024f8 	.word	0x200024f8

0000eb24 <hal_watchdog_tickle>:

void
hal_watchdog_tickle(void)
{
    eb24:	b510      	push	{r4, lr}
    wdt_reset_count();
    eb26:	f000 fe27 	bl	f778 <wdt_reset_count>
}
    eb2a:	bd10      	pop	{r4, pc}

0000eb2c <nvm_is_ready>:
static inline bool nvm_is_ready(void)
{
	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	return nvm_module->INTFLAG.reg & NVMCTRL_INTFLAG_READY;
    eb2c:	4b02      	ldr	r3, [pc, #8]	; (eb38 <nvm_is_ready+0xc>)
    eb2e:	7d18      	ldrb	r0, [r3, #20]
    eb30:	2301      	movs	r3, #1
    eb32:	4018      	ands	r0, r3
}
    eb34:	4770      	bx	lr
    eb36:	46c0      	nop			; (mov r8, r8)
    eb38:	41004000 	.word	0x41004000

0000eb3c <nvm_set_config>:
			PM->APBBMASK.reg |= mask;
    eb3c:	2304      	movs	r3, #4
    eb3e:	4a1c      	ldr	r2, [pc, #112]	; (ebb0 <nvm_set_config+0x74>)
 *                        EEPROM and/or auxiliary space configuration from being
 *                        altered
 */
enum status_code nvm_set_config(
		const struct nvm_config *const config)
{
    eb40:	b570      	push	{r4, r5, r6, lr}
    eb42:	69d1      	ldr	r1, [r2, #28]
	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBB, PM_APBBMASK_NVMCTRL);
#endif

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    eb44:	4c1b      	ldr	r4, [pc, #108]	; (ebb4 <nvm_set_config+0x78>)
    eb46:	430b      	orrs	r3, r1
    eb48:	61d3      	str	r3, [r2, #28]
    eb4a:	2320      	movs	r3, #32
    eb4c:	8b22      	ldrh	r2, [r4, #24]
    eb4e:	33ff      	adds	r3, #255	; 0xff
    eb50:	4313      	orrs	r3, r2
    eb52:	8323      	strh	r3, [r4, #24]
{
    eb54:	0005      	movs	r5, r0

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    eb56:	f7ff ffe9 	bl	eb2c <nvm_is_ready>
    eb5a:	0003      	movs	r3, r0
		return STATUS_BUSY;
    eb5c:	2005      	movs	r0, #5
	if (!nvm_is_ready()) {
    eb5e:	2b00      	cmp	r3, #0
    eb60:	d024      	beq.n	ebac <nvm_set_config+0x70>
	}

#if (!SAMC20) && (!SAMC21)
	/* Writing configuration to the CTRLB register */
	nvm_module->CTRLB.reg =
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
    eb62:	20c0      	movs	r0, #192	; 0xc0
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
    eb64:	786a      	ldrb	r2, [r5, #1]
			NVMCTRL_CTRLB_RWS(config->wait_states) |
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
    eb66:	78eb      	ldrb	r3, [r5, #3]
			((config->manual_page_write & 0x01) << NVMCTRL_CTRLB_MANW_Pos) |
    eb68:	01d1      	lsls	r1, r2, #7
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
    eb6a:	049b      	lsls	r3, r3, #18
			NVMCTRL_CTRLB_RWS(config->wait_states) |
    eb6c:	430b      	orrs	r3, r1
			NVMCTRL_CTRLB_SLEEPPRM(config->sleep_power_mode) |
    eb6e:	7829      	ldrb	r1, [r5, #0]
    eb70:	0080      	lsls	r0, r0, #2
    eb72:	0209      	lsls	r1, r1, #8
    eb74:	4001      	ands	r1, r0
			NVMCTRL_CTRLB_RWS(config->wait_states) |
    eb76:	201e      	movs	r0, #30
    eb78:	430b      	orrs	r3, r1
    eb7a:	78a9      	ldrb	r1, [r5, #2]
    eb7c:	0049      	lsls	r1, r1, #1
    eb7e:	4001      	ands	r1, r0
			NVMCTRL_CTRLB_READMODE(config->cache_readmode);
    eb80:	20c0      	movs	r0, #192	; 0xc0
			NVMCTRL_CTRLB_RWS(config->wait_states) |
    eb82:	430b      	orrs	r3, r1
			NVMCTRL_CTRLB_READMODE(config->cache_readmode);
    eb84:	7929      	ldrb	r1, [r5, #4]
    eb86:	0280      	lsls	r0, r0, #10
    eb88:	0409      	lsls	r1, r1, #16
    eb8a:	4001      	ands	r1, r0
			(cache_disable_value << NVMCTRL_CTRLB_CACHEDIS_Pos) |
			NVMCTRL_CTRLB_READMODE(config->cache_readmode);
#endif

	/* Initialize the internal device struct */
	_nvm_dev.page_size         = (8 << nvm_module->PARAM.bit.PSZ);
    eb8c:	2008      	movs	r0, #8
			((config->disable_cache & 0x01) << NVMCTRL_CTRLB_CACHEDIS_Pos) |
    eb8e:	430b      	orrs	r3, r1
	nvm_module->CTRLB.reg =
    eb90:	6063      	str	r3, [r4, #4]
	_nvm_dev.page_size         = (8 << nvm_module->PARAM.bit.PSZ);
    eb92:	68a3      	ldr	r3, [r4, #8]
    eb94:	4908      	ldr	r1, [pc, #32]	; (ebb8 <nvm_set_config+0x7c>)
    eb96:	035b      	lsls	r3, r3, #13
    eb98:	0f5b      	lsrs	r3, r3, #29
    eb9a:	4098      	lsls	r0, r3
    eb9c:	8008      	strh	r0, [r1, #0]
	_nvm_dev.number_of_pages   = nvm_module->PARAM.bit.NVMP;
    eb9e:	68a3      	ldr	r3, [r4, #8]
	_nvm_dev.manual_page_write = config->manual_page_write;
    eba0:	710a      	strb	r2, [r1, #4]
	_nvm_dev.number_of_pages   = nvm_module->PARAM.bit.NVMP;
    eba2:	804b      	strh	r3, [r1, #2]

	/* If the security bit is set, the auxiliary space cannot be written */
	if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
    eba4:	8b20      	ldrh	r0, [r4, #24]
    eba6:	05c0      	lsls	r0, r0, #23
		return STATUS_ERR_IO;
	}

	return STATUS_OK;
    eba8:	0fc0      	lsrs	r0, r0, #31
    ebaa:	0100      	lsls	r0, r0, #4
}
    ebac:	bd70      	pop	{r4, r5, r6, pc}
    ebae:	46c0      	nop			; (mov r8, r8)
    ebb0:	40000400 	.word	0x40000400
    ebb4:	41004000 	.word	0x41004000
    ebb8:	20002258 	.word	0x20002258

0000ebbc <nvm_execute_command>:
 */
enum status_code nvm_execute_command(
		const enum nvm_command command,
		const uint32_t address,
		const uint32_t parameter)
{
    ebbc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint32_t ctrlb_bak;

	/* Check that the address given is valid  */
	if (address > ((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)
    ebbe:	4a25      	ldr	r2, [pc, #148]	; (ec54 <nvm_execute_command+0x98>)
{
    ebc0:	9101      	str	r1, [sp, #4]
	if (address > ((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)
    ebc2:	8853      	ldrh	r3, [r2, #2]
    ebc4:	8811      	ldrh	r1, [r2, #0]
    ebc6:	9a01      	ldr	r2, [sp, #4]
    ebc8:	434b      	muls	r3, r1
{
    ebca:	0004      	movs	r4, r0
	if (address > ((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)
    ebcc:	4293      	cmp	r3, r2
    ebce:	d207      	bcs.n	ebe0 <nvm_execute_command+0x24>
		&& !(address >= NVMCTRL_AUX0_ADDRESS && address <= NVMCTRL_AUX1_ADDRESS )){
    ebd0:	2280      	movs	r2, #128	; 0x80
    ebd2:	9b01      	ldr	r3, [sp, #4]
    ebd4:	4920      	ldr	r1, [pc, #128]	; (ec58 <nvm_execute_command+0x9c>)
    ebd6:	0192      	lsls	r2, r2, #6
    ebd8:	185b      	adds	r3, r3, r1
		if (address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
#else
		return STATUS_ERR_BAD_ADDRESS;
    ebda:	2018      	movs	r0, #24
		&& !(address >= NVMCTRL_AUX0_ADDRESS && address <= NVMCTRL_AUX1_ADDRESS )){
    ebdc:	4293      	cmp	r3, r2
    ebde:	d811      	bhi.n	ec04 <nvm_execute_command+0x48>
	ctrlb_bak = nvm_module->CTRLB.reg;
#if (SAMC20) || (SAMC21)
	nvm_module->CTRLB.reg = ((ctrlb_bak &(~(NVMCTRL_CTRLB_CACHEDIS(0x2)))) 
							| NVMCTRL_CTRLB_CACHEDIS(0x1));
#else
	nvm_module->CTRLB.reg = ctrlb_bak | NVMCTRL_CTRLB_CACHEDIS;
    ebe0:	2380      	movs	r3, #128	; 0x80
	ctrlb_bak = nvm_module->CTRLB.reg;
    ebe2:	4d1e      	ldr	r5, [pc, #120]	; (ec5c <nvm_execute_command+0xa0>)
	nvm_module->CTRLB.reg = ctrlb_bak | NVMCTRL_CTRLB_CACHEDIS;
    ebe4:	02db      	lsls	r3, r3, #11
	ctrlb_bak = nvm_module->CTRLB.reg;
    ebe6:	686f      	ldr	r7, [r5, #4]
    ebe8:	002e      	movs	r6, r5
	nvm_module->CTRLB.reg = ctrlb_bak | NVMCTRL_CTRLB_CACHEDIS;
    ebea:	433b      	orrs	r3, r7
    ebec:	606b      	str	r3, [r5, #4]
#endif

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ebee:	2320      	movs	r3, #32
    ebf0:	8b2a      	ldrh	r2, [r5, #24]
    ebf2:	33ff      	adds	r3, #255	; 0xff
    ebf4:	4313      	orrs	r3, r2
    ebf6:	832b      	strh	r3, [r5, #24]

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    ebf8:	f7ff ff98 	bl	eb2c <nvm_is_ready>
    ebfc:	2800      	cmp	r0, #0
    ebfe:	d102      	bne.n	ec06 <nvm_execute_command+0x4a>
		/* Restore the setting */
		nvm_module->CTRLB.reg = ctrlb_bak;
    ec00:	606f      	str	r7, [r5, #4]
		return STATUS_BUSY;
    ec02:	3005      	adds	r0, #5

	/* Restore the setting */
	nvm_module->CTRLB.reg = ctrlb_bak;

	return STATUS_OK;
}
    ec04:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	switch (command) {
    ec06:	2c06      	cmp	r4, #6
    ec08:	d814      	bhi.n	ec34 <nvm_execute_command+0x78>
    ec0a:	2c05      	cmp	r4, #5
    ec0c:	d21b      	bcs.n	ec46 <nvm_execute_command+0x8a>
    ec0e:	2c02      	cmp	r4, #2
    ec10:	d001      	beq.n	ec16 <nvm_execute_command+0x5a>
    ec12:	2c04      	cmp	r4, #4
    ec14:	d114      	bne.n	ec40 <nvm_execute_command+0x84>
			nvm_module->ADDR.reg = (uintptr_t)&NVM_MEMORY[address / 4];
    ec16:	9b01      	ldr	r3, [sp, #4]
    ec18:	089b      	lsrs	r3, r3, #2
    ec1a:	005b      	lsls	r3, r3, #1
    ec1c:	61f3      	str	r3, [r6, #28]
	nvm_module->CTRLA.reg = command | NVMCTRL_CTRLA_CMDEX_KEY;
    ec1e:	23a5      	movs	r3, #165	; 0xa5
    ec20:	021b      	lsls	r3, r3, #8
    ec22:	431c      	orrs	r4, r3
    ec24:	8034      	strh	r4, [r6, #0]
	while (!nvm_is_ready()) {
    ec26:	f7ff ff81 	bl	eb2c <nvm_is_ready>
    ec2a:	2800      	cmp	r0, #0
    ec2c:	d0fb      	beq.n	ec26 <nvm_execute_command+0x6a>
	nvm_module->CTRLB.reg = ctrlb_bak;
    ec2e:	6077      	str	r7, [r6, #4]
	return STATUS_OK;
    ec30:	2000      	movs	r0, #0
    ec32:	e7e7      	b.n	ec04 <nvm_execute_command+0x48>
	switch (command) {
    ec34:	2c40      	cmp	r4, #64	; 0x40
    ec36:	d303      	bcc.n	ec40 <nvm_execute_command+0x84>
    ec38:	2c41      	cmp	r4, #65	; 0x41
    ec3a:	d9ec      	bls.n	ec16 <nvm_execute_command+0x5a>
    ec3c:	2c45      	cmp	r4, #69	; 0x45
    ec3e:	d9ee      	bls.n	ec1e <nvm_execute_command+0x62>
			nvm_module->CTRLB.reg = ctrlb_bak;
    ec40:	6077      	str	r7, [r6, #4]
			return STATUS_ERR_INVALID_ARG;
    ec42:	2017      	movs	r0, #23
    ec44:	e7de      	b.n	ec04 <nvm_execute_command+0x48>
			if (nvm_module->STATUS.reg & NVMCTRL_STATUS_SB) {
    ec46:	8b2b      	ldrh	r3, [r5, #24]
    ec48:	05db      	lsls	r3, r3, #23
    ec4a:	d5e4      	bpl.n	ec16 <nvm_execute_command+0x5a>
				nvm_module->CTRLB.reg = ctrlb_bak;
    ec4c:	606f      	str	r7, [r5, #4]
				return STATUS_ERR_IO;
    ec4e:	2010      	movs	r0, #16
    ec50:	e7d8      	b.n	ec04 <nvm_execute_command+0x48>
    ec52:	46c0      	nop			; (mov r8, r8)
    ec54:	20002258 	.word	0x20002258
    ec58:	ff7fc000 	.word	0xff7fc000
    ec5c:	41004000 	.word	0x41004000

0000ec60 <nvm_write_buffer>:
 */
enum status_code nvm_write_buffer(
		const uint32_t destination_address,
		const uint8_t *buffer,
		uint16_t length)
{
    ec60:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	bool is_rww_eeprom = false;
#endif

	/* Check if the destination address is valid */
	if (destination_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ec62:	4f22      	ldr	r7, [pc, #136]	; (ecec <nvm_write_buffer+0x8c>)
{
    ec64:	9101      	str	r1, [sp, #4]
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ec66:	883b      	ldrh	r3, [r7, #0]
    ec68:	8879      	ldrh	r1, [r7, #2]
{
    ec6a:	0016      	movs	r6, r2
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ec6c:	4359      	muls	r1, r3
{
    ec6e:	0005      	movs	r5, r0
			|| destination_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
#else
		return STATUS_ERR_BAD_ADDRESS;
    ec70:	2218      	movs	r2, #24
	if (destination_address >
    ec72:	4281      	cmp	r1, r0
    ec74:	d327      	bcc.n	ecc6 <nvm_write_buffer+0x66>
#endif
	}

	/* Check if the write address not aligned to the start of a page */
	if (destination_address & (_nvm_dev.page_size - 1)) {
    ec76:	1e59      	subs	r1, r3, #1
    ec78:	4208      	tst	r0, r1
    ec7a:	d124      	bne.n	ecc6 <nvm_write_buffer+0x66>
		return STATUS_ERR_BAD_ADDRESS;
	}

	/* Check if the write length is longer than an NVM page */
	if (length > _nvm_dev.page_size) {
		return STATUS_ERR_INVALID_ARG;
    ec7c:	3a01      	subs	r2, #1
	if (length > _nvm_dev.page_size) {
    ec7e:	42b3      	cmp	r3, r6
    ec80:	d321      	bcc.n	ecc6 <nvm_write_buffer+0x66>

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    ec82:	f7ff ff53 	bl	eb2c <nvm_is_ready>
		return STATUS_BUSY;
    ec86:	2205      	movs	r2, #5
	if (!nvm_is_ready()) {
    ec88:	2800      	cmp	r0, #0
    ec8a:	d01c      	beq.n	ecc6 <nvm_write_buffer+0x66>
	}

	/* Erase the page buffer before buffering new data */
	nvm_module->CTRLA.reg = NVM_COMMAND_PAGE_BUFFER_CLEAR | NVMCTRL_CTRLA_CMDEX_KEY;
    ec8c:	4c18      	ldr	r4, [pc, #96]	; (ecf0 <nvm_write_buffer+0x90>)
    ec8e:	4b19      	ldr	r3, [pc, #100]	; (ecf4 <nvm_write_buffer+0x94>)
    ec90:	8023      	strh	r3, [r4, #0]

	/* Check if the module is busy */
	while (!nvm_is_ready()) {
    ec92:	f7ff ff4b 	bl	eb2c <nvm_is_ready>
    ec96:	2800      	cmp	r0, #0
    ec98:	d0fb      	beq.n	ec92 <nvm_write_buffer+0x32>
		/* Force-wait for the buffer clear to complete */
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ec9a:	2320      	movs	r3, #32
    ec9c:	8b22      	ldrh	r2, [r4, #24]
    ec9e:	33ff      	adds	r3, #255	; 0xff
    eca0:	4313      	orrs	r3, r2
    eca2:	8323      	strh	r3, [r4, #24]

	uint32_t nvm_address = destination_address / 2;

	/* NVM _must_ be accessed as a series of 16-bit words, perform manual copy
	 * to ensure alignment */
	for (uint16_t i = 0; i < length; i += 2) {
    eca4:	2300      	movs	r3, #0
	uint32_t nvm_address = destination_address / 2;
    eca6:	086a      	lsrs	r2, r5, #1
    eca8:	0052      	lsls	r2, r2, #1
		/* Copy first byte of the 16-bit chunk to the temporary buffer */
		data = buffer[i];

		/* If we are not at the end of a write request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
    ecaa:	1e70      	subs	r0, r6, #1
	for (uint16_t i = 0; i < length; i += 2) {
    ecac:	429e      	cmp	r6, r3
    ecae:	d80c      	bhi.n	ecca <nvm_write_buffer+0x6a>
		return nvm_execute_command(NVM_COMMAND_WRITE_PAGE,
				destination_address, 0);
#endif
	}

	return STATUS_OK;
    ecb0:	2200      	movs	r2, #0
	if ((_nvm_dev.manual_page_write == false) && (length < NVMCTRL_PAGE_SIZE)) {
    ecb2:	793b      	ldrb	r3, [r7, #4]
    ecb4:	4293      	cmp	r3, r2
    ecb6:	d106      	bne.n	ecc6 <nvm_write_buffer+0x66>
    ecb8:	2e3f      	cmp	r6, #63	; 0x3f
    ecba:	d804      	bhi.n	ecc6 <nvm_write_buffer+0x66>
		return nvm_execute_command(NVM_COMMAND_WRITE_PAGE,
    ecbc:	0029      	movs	r1, r5
    ecbe:	2004      	movs	r0, #4
    ecc0:	f7ff ff7c 	bl	ebbc <nvm_execute_command>
    ecc4:	0002      	movs	r2, r0
}
    ecc6:	0010      	movs	r0, r2
    ecc8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
		data = buffer[i];
    ecca:	9901      	ldr	r1, [sp, #4]
    eccc:	5cc9      	ldrb	r1, [r1, r3]
		if (i < (length - 1)) {
    ecce:	4283      	cmp	r3, r0
    ecd0:	db05      	blt.n	ecde <nvm_write_buffer+0x7e>
		data = buffer[i];
    ecd2:	b289      	uxth	r1, r1
	for (uint16_t i = 0; i < length; i += 2) {
    ecd4:	3302      	adds	r3, #2
		NVM_MEMORY[nvm_address++] = data;
    ecd6:	8011      	strh	r1, [r2, #0]
	for (uint16_t i = 0; i < length; i += 2) {
    ecd8:	b29b      	uxth	r3, r3
    ecda:	3202      	adds	r2, #2
    ecdc:	e7e6      	b.n	ecac <nvm_write_buffer+0x4c>
			data |= (buffer[i + 1] << 8);
    ecde:	9c01      	ldr	r4, [sp, #4]
    ece0:	18e4      	adds	r4, r4, r3
    ece2:	7864      	ldrb	r4, [r4, #1]
    ece4:	0224      	lsls	r4, r4, #8
    ece6:	4321      	orrs	r1, r4
    ece8:	e7f4      	b.n	ecd4 <nvm_write_buffer+0x74>
    ecea:	46c0      	nop			; (mov r8, r8)
    ecec:	20002258 	.word	0x20002258
    ecf0:	41004000 	.word	0x41004000
    ecf4:	ffffa544 	.word	0xffffa544

0000ecf8 <nvm_read_buffer>:
 */
enum status_code nvm_read_buffer(
		const uint32_t source_address,
		uint8_t *const buffer,
		uint16_t length)
{
    ecf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check if the source address is valid */
	if (source_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ecfa:	4b17      	ldr	r3, [pc, #92]	; (ed58 <nvm_read_buffer+0x60>)
{
    ecfc:	000f      	movs	r7, r1
    ecfe:	0016      	movs	r6, r2
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ed00:	8859      	ldrh	r1, [r3, #2]
    ed02:	881a      	ldrh	r2, [r3, #0]
{
    ed04:	0005      	movs	r5, r0
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ed06:	4351      	muls	r1, r2
		if (source_address >= ((uint32_t)NVMCTRL_RWW_EEPROM_SIZE + NVMCTRL_RWW_EEPROM_ADDR)
			|| source_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
#else
		return STATUS_ERR_BAD_ADDRESS;
    ed08:	2318      	movs	r3, #24
	if (source_address >
    ed0a:	4281      	cmp	r1, r0
    ed0c:	d316      	bcc.n	ed3c <nvm_read_buffer+0x44>
#endif
	}

	/* Check if the read address is not aligned to the start of a page */
	if (source_address & (_nvm_dev.page_size - 1)) {
    ed0e:	1e54      	subs	r4, r2, #1
    ed10:	4004      	ands	r4, r0
    ed12:	d113      	bne.n	ed3c <nvm_read_buffer+0x44>
		return STATUS_ERR_BAD_ADDRESS;
	}

	/* Check if the write length is longer than an NVM page */
	if (length > _nvm_dev.page_size) {
		return STATUS_ERR_INVALID_ARG;
    ed14:	3b01      	subs	r3, #1
	if (length > _nvm_dev.page_size) {
    ed16:	42b2      	cmp	r2, r6
    ed18:	d310      	bcc.n	ed3c <nvm_read_buffer+0x44>

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    ed1a:	f7ff ff07 	bl	eb2c <nvm_is_ready>
		return STATUS_BUSY;
    ed1e:	2305      	movs	r3, #5
	if (!nvm_is_ready()) {
    ed20:	2800      	cmp	r0, #0
    ed22:	d00b      	beq.n	ed3c <nvm_read_buffer+0x44>
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ed24:	2320      	movs	r3, #32
    ed26:	4a0d      	ldr	r2, [pc, #52]	; (ed5c <nvm_read_buffer+0x64>)
    ed28:	33ff      	adds	r3, #255	; 0xff
    ed2a:	8b11      	ldrh	r1, [r2, #24]

	uint32_t page_address = source_address / 2;
    ed2c:	086d      	lsrs	r5, r5, #1
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ed2e:	430b      	orrs	r3, r1
    ed30:	8313      	strh	r3, [r2, #24]
    ed32:	006d      	lsls	r5, r5, #1
		/* Copy first byte of the 16-bit chunk to the destination buffer */
		buffer[i] = (data & 0xFF);

		/* If we are not at the end of a read request with an odd byte count,
		 * store the next byte of data as well */
		if (i < (length - 1)) {
    ed34:	1e71      	subs	r1, r6, #1
	for (uint16_t i = 0; i < length; i += 2) {
    ed36:	42a6      	cmp	r6, r4
    ed38:	d802      	bhi.n	ed40 <nvm_read_buffer+0x48>
    ed3a:	2300      	movs	r3, #0
			buffer[i + 1] = (data >> 8);
		}
	}

	return STATUS_OK;
}
    ed3c:	0018      	movs	r0, r3
    ed3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uint16_t data = NVM_MEMORY[page_address++];
    ed40:	882b      	ldrh	r3, [r5, #0]
    ed42:	b29b      	uxth	r3, r3
		buffer[i] = (data & 0xFF);
    ed44:	553b      	strb	r3, [r7, r4]
		if (i < (length - 1)) {
    ed46:	428c      	cmp	r4, r1
    ed48:	da02      	bge.n	ed50 <nvm_read_buffer+0x58>
			buffer[i + 1] = (data >> 8);
    ed4a:	193a      	adds	r2, r7, r4
    ed4c:	0a1b      	lsrs	r3, r3, #8
    ed4e:	7053      	strb	r3, [r2, #1]
	for (uint16_t i = 0; i < length; i += 2) {
    ed50:	3402      	adds	r4, #2
    ed52:	b2a4      	uxth	r4, r4
    ed54:	3502      	adds	r5, #2
    ed56:	e7ee      	b.n	ed36 <nvm_read_buffer+0x3e>
    ed58:	20002258 	.word	0x20002258
    ed5c:	41004000 	.word	0x41004000

0000ed60 <nvm_erase_row>:
 *                                 acceptable range of the NVM memory region or
 *                                 not aligned to the start of a row
 */
enum status_code nvm_erase_row(
		const uint32_t row_address)
{
    ed60:	b510      	push	{r4, lr}
		bool is_rww_eeprom = false;
#endif

	/* Check if the row address is valid */
	if (row_address >
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ed62:	4a11      	ldr	r2, [pc, #68]	; (eda8 <nvm_erase_row+0x48>)
{
    ed64:	0004      	movs	r4, r0
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ed66:	8813      	ldrh	r3, [r2, #0]
    ed68:	8851      	ldrh	r1, [r2, #2]
			|| row_address < NVMCTRL_RWW_EEPROM_ADDR){
			return STATUS_ERR_BAD_ADDRESS;
		}
		is_rww_eeprom = true;
#else
		return STATUS_ERR_BAD_ADDRESS;
    ed6a:	2218      	movs	r2, #24
			((uint32_t)_nvm_dev.page_size * _nvm_dev.number_of_pages)) {
    ed6c:	4359      	muls	r1, r3
	if (row_address >
    ed6e:	4281      	cmp	r1, r0
    ed70:	d318      	bcc.n	eda4 <nvm_erase_row+0x44>
#endif
	}

	/* Check if the address to erase is not aligned to the start of a row */
	if (row_address & ((_nvm_dev.page_size * NVMCTRL_ROW_PAGES) - 1)) {
    ed72:	009b      	lsls	r3, r3, #2
    ed74:	3b01      	subs	r3, #1
    ed76:	4218      	tst	r0, r3
    ed78:	d114      	bne.n	eda4 <nvm_erase_row+0x44>

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Check if the module is busy */
	if (!nvm_is_ready()) {
    ed7a:	f7ff fed7 	bl	eb2c <nvm_is_ready>
		return STATUS_BUSY;
    ed7e:	2205      	movs	r2, #5
	if (!nvm_is_ready()) {
    ed80:	2800      	cmp	r0, #0
    ed82:	d00f      	beq.n	eda4 <nvm_erase_row+0x44>
	}

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ed84:	2220      	movs	r2, #32
    ed86:	4b09      	ldr	r3, [pc, #36]	; (edac <nvm_erase_row+0x4c>)
    ed88:	32ff      	adds	r2, #255	; 0xff
    ed8a:	8b19      	ldrh	r1, [r3, #24]

	/* Set address and command */
	nvm_module->ADDR.reg  = (uintptr_t)&NVM_MEMORY[row_address / 4];
    ed8c:	08a4      	lsrs	r4, r4, #2
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    ed8e:	430a      	orrs	r2, r1
    ed90:	831a      	strh	r2, [r3, #24]
#ifdef FEATURE_NVM_RWWEE
	nvm_module->CTRLA.reg = ((is_rww_eeprom) ?
								(NVM_COMMAND_RWWEE_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY):
								(NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY));
#else
	nvm_module->CTRLA.reg = NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY;
    ed92:	4a07      	ldr	r2, [pc, #28]	; (edb0 <nvm_erase_row+0x50>)
	nvm_module->ADDR.reg  = (uintptr_t)&NVM_MEMORY[row_address / 4];
    ed94:	0064      	lsls	r4, r4, #1
    ed96:	61dc      	str	r4, [r3, #28]
	nvm_module->CTRLA.reg = NVM_COMMAND_ERASE_ROW | NVMCTRL_CTRLA_CMDEX_KEY;
    ed98:	801a      	strh	r2, [r3, #0]
#endif

	while (!nvm_is_ready()) {
    ed9a:	f7ff fec7 	bl	eb2c <nvm_is_ready>
    ed9e:	2800      	cmp	r0, #0
    eda0:	d0fb      	beq.n	ed9a <nvm_erase_row+0x3a>
    eda2:	2200      	movs	r2, #0
	}

	return STATUS_OK;
}
    eda4:	0010      	movs	r0, r2
    eda6:	bd10      	pop	{r4, pc}
    eda8:	20002258 	.word	0x20002258
    edac:	41004000 	.word	0x41004000
    edb0:	ffffa502 	.word	0xffffa502

0000edb4 <nvm_get_parameters>:

	/* Get a pointer to the module hardware instance */
	Nvmctrl *const nvm_module = NVMCTRL;

	/* Clear error flags */
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    edb4:	2220      	movs	r2, #32
{
    edb6:	b510      	push	{r4, lr}
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    edb8:	4b13      	ldr	r3, [pc, #76]	; (ee08 <nvm_get_parameters+0x54>)
    edba:	32ff      	adds	r2, #255	; 0xff
    edbc:	8b19      	ldrh	r1, [r3, #24]
	/* Read out from the PARAM register */
	uint32_t param_reg = nvm_module->PARAM.reg;

	/* Mask out page size exponent and convert to a number of bytes */
	parameters->page_size =
			8 << ((param_reg & NVMCTRL_PARAM_PSZ_Msk) >> NVMCTRL_PARAM_PSZ_Pos);
    edbe:	2407      	movs	r4, #7
	nvm_module->STATUS.reg |= NVMCTRL_STATUS_MASK;
    edc0:	430a      	orrs	r2, r1
    edc2:	831a      	strh	r2, [r3, #24]
			8 << ((param_reg & NVMCTRL_PARAM_PSZ_Msk) >> NVMCTRL_PARAM_PSZ_Pos);
    edc4:	2208      	movs	r2, #8
	uint32_t param_reg = nvm_module->PARAM.reg;
    edc6:	689b      	ldr	r3, [r3, #8]
			8 << ((param_reg & NVMCTRL_PARAM_PSZ_Msk) >> NVMCTRL_PARAM_PSZ_Pos);
    edc8:	0c19      	lsrs	r1, r3, #16
    edca:	4021      	ands	r1, r4
    edcc:	408a      	lsls	r2, r1
	parameters->page_size =
    edce:	7002      	strb	r2, [r0, #0]
			(param_reg & NVMCTRL_PARAM_RWWEEP_Msk) >> NVMCTRL_PARAM_RWWEEP_Pos;
#endif

	/* Read the current EEPROM fuse value from the USER row */
	uint16_t eeprom_fuse_value =
			(NVM_USER_MEMORY[NVMCTRL_FUSES_EEPROM_SIZE_Pos / 16] &
    edd0:	4a0e      	ldr	r2, [pc, #56]	; (ee0c <nvm_get_parameters+0x58>)
	parameters->nvm_number_of_pages =
    edd2:	8043      	strh	r3, [r0, #2]
			(NVM_USER_MEMORY[NVMCTRL_FUSES_EEPROM_SIZE_Pos / 16] &
    edd4:	8813      	ldrh	r3, [r2, #0]
			NVMCTRL_FUSES_EEPROM_SIZE_Msk) >> NVMCTRL_FUSES_EEPROM_SIZE_Pos;
    edd6:	091b      	lsrs	r3, r3, #4
	uint16_t eeprom_fuse_value =
    edd8:	4023      	ands	r3, r4

	/* Translate the EEPROM fuse byte value to a number of NVM pages */
	if (eeprom_fuse_value == 7) {
    edda:	42a3      	cmp	r3, r4
    eddc:	d109      	bne.n	edf2 <nvm_get_parameters+0x3e>
		parameters->eeprom_number_of_pages = 0;
    edde:	2300      	movs	r3, #0
	}
	else {
		parameters->eeprom_number_of_pages =
    ede0:	6043      	str	r3, [r0, #4]
				NVMCTRL_ROW_PAGES << (6 - eeprom_fuse_value);
	}

	/* Read the current BOOTSZ fuse value from the USER row */
	uint16_t boot_fuse_value =
    ede2:	2307      	movs	r3, #7
			(NVM_USER_MEMORY[NVMCTRL_FUSES_BOOTPROT_Pos / 16] &
    ede4:	8812      	ldrh	r2, [r2, #0]
	uint16_t boot_fuse_value =
    ede6:	401a      	ands	r2, r3
			NVMCTRL_FUSES_BOOTPROT_Msk) >> NVMCTRL_FUSES_BOOTPROT_Pos;

	/* Translate the BOOTSZ fuse byte value to a number of NVM pages */
	if (boot_fuse_value == 7) {
    ede8:	429a      	cmp	r2, r3
    edea:	d107      	bne.n	edfc <nvm_get_parameters+0x48>
		parameters->bootloader_number_of_pages = 0;
    edec:	2300      	movs	r3, #0
    edee:	6083      	str	r3, [r0, #8]
	}
	else {
		parameters->bootloader_number_of_pages =
				NVMCTRL_ROW_PAGES << (7 - boot_fuse_value);
	}
}
    edf0:	bd10      	pop	{r4, pc}
				NVMCTRL_ROW_PAGES << (6 - eeprom_fuse_value);
    edf2:	2106      	movs	r1, #6
    edf4:	1ac9      	subs	r1, r1, r3
    edf6:	2304      	movs	r3, #4
    edf8:	408b      	lsls	r3, r1
    edfa:	e7f1      	b.n	ede0 <nvm_get_parameters+0x2c>
				NVMCTRL_ROW_PAGES << (7 - boot_fuse_value);
    edfc:	1a9b      	subs	r3, r3, r2
    edfe:	2204      	movs	r2, #4
    ee00:	409a      	lsls	r2, r3
		parameters->bootloader_number_of_pages =
    ee02:	6082      	str	r2, [r0, #8]
}
    ee04:	e7f4      	b.n	edf0 <nvm_get_parameters+0x3c>
    ee06:	46c0      	nop			; (mov r8, r8)
    ee08:	41004000 	.word	0x41004000
    ee0c:	00804000 	.word	0x00804000

0000ee10 <_sercom_default_handler>:
 */
static void _sercom_default_handler(
		const uint8_t instance)
{
	Assert(false);
}
    ee10:	4770      	bx	lr
	...

0000ee14 <SERCOM0_Handler>:
	/* Get the vector number from the lookup table for the requested SERCOM */
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
}

/** Auto-generate a set of interrupt handlers for each SERCOM in the device */
MREPEAT(SERCOM_INST_NUM, _SERCOM_INTERRUPT_HANDLER, ~)
    ee14:	b510      	push	{r4, lr}
    ee16:	4b02      	ldr	r3, [pc, #8]	; (ee20 <SERCOM0_Handler+0xc>)
    ee18:	2000      	movs	r0, #0
    ee1a:	681b      	ldr	r3, [r3, #0]
    ee1c:	4798      	blx	r3
    ee1e:	bd10      	pop	{r4, pc}
    ee20:	20002260 	.word	0x20002260

0000ee24 <SERCOM1_Handler>:
    ee24:	b510      	push	{r4, lr}
    ee26:	4b02      	ldr	r3, [pc, #8]	; (ee30 <SERCOM1_Handler+0xc>)
    ee28:	2001      	movs	r0, #1
    ee2a:	685b      	ldr	r3, [r3, #4]
    ee2c:	4798      	blx	r3
    ee2e:	bd10      	pop	{r4, pc}
    ee30:	20002260 	.word	0x20002260

0000ee34 <SERCOM2_Handler>:
    ee34:	b510      	push	{r4, lr}
    ee36:	4b02      	ldr	r3, [pc, #8]	; (ee40 <SERCOM2_Handler+0xc>)
    ee38:	2002      	movs	r0, #2
    ee3a:	689b      	ldr	r3, [r3, #8]
    ee3c:	4798      	blx	r3
    ee3e:	bd10      	pop	{r4, pc}
    ee40:	20002260 	.word	0x20002260

0000ee44 <SERCOM3_Handler>:
    ee44:	b510      	push	{r4, lr}
    ee46:	4b02      	ldr	r3, [pc, #8]	; (ee50 <SERCOM3_Handler+0xc>)
    ee48:	2003      	movs	r0, #3
    ee4a:	68db      	ldr	r3, [r3, #12]
    ee4c:	4798      	blx	r3
    ee4e:	bd10      	pop	{r4, pc}
    ee50:	20002260 	.word	0x20002260

0000ee54 <SERCOM4_Handler>:
    ee54:	b510      	push	{r4, lr}
    ee56:	4b02      	ldr	r3, [pc, #8]	; (ee60 <SERCOM4_Handler+0xc>)
    ee58:	2004      	movs	r0, #4
    ee5a:	691b      	ldr	r3, [r3, #16]
    ee5c:	4798      	blx	r3
    ee5e:	bd10      	pop	{r4, pc}
    ee60:	20002260 	.word	0x20002260

0000ee64 <SERCOM5_Handler>:
    ee64:	b510      	push	{r4, lr}
    ee66:	4b02      	ldr	r3, [pc, #8]	; (ee70 <SERCOM5_Handler+0xc>)
    ee68:	2005      	movs	r0, #5
    ee6a:	695b      	ldr	r3, [r3, #20]
    ee6c:	4798      	blx	r3
    ee6e:	bd10      	pop	{r4, pc}
    ee70:	20002260 	.word	0x20002260

0000ee74 <_sercom_get_interrupt_vector>:
{
    ee74:	b507      	push	{r0, r1, r2, lr}
	const uint8_t sercom_int_vectors[SERCOM_INST_NUM] =
    ee76:	466a      	mov	r2, sp
    ee78:	4b04      	ldr	r3, [pc, #16]	; (ee8c <_sercom_get_interrupt_vector+0x18>)
    ee7a:	9300      	str	r3, [sp, #0]
    ee7c:	4b04      	ldr	r3, [pc, #16]	; (ee90 <_sercom_get_interrupt_vector+0x1c>)
    ee7e:	8093      	strh	r3, [r2, #4]
	uint8_t instance_index = _sercom_get_sercom_inst_index(sercom_instance);
    ee80:	f000 fe04 	bl	fa8c <_sercom_get_sercom_inst_index>
	return (enum system_interrupt_vector)sercom_int_vectors[instance_index];
    ee84:	466b      	mov	r3, sp
    ee86:	5618      	ldrsb	r0, [r3, r0]
}
    ee88:	bd0e      	pop	{r1, r2, r3, pc}
    ee8a:	46c0      	nop			; (mov r8, r8)
    ee8c:	0c0b0a09 	.word	0x0c0b0a09
    ee90:	00000e0d 	.word	0x00000e0d

0000ee94 <_sercom_set_handler>:
 * \param[in]  interrupt_handler  Pointer to instance callback handler.
 */
void _sercom_set_handler(
		const uint8_t instance,
		const sercom_handler_t interrupt_handler)
{
    ee94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    
	/* Initialize handlers with default handler and device instances with 0 */
	if (_handler_table_initialized == false) {
    ee96:	4c16      	ldr	r4, [pc, #88]	; (eef0 <_sercom_set_handler+0x5c>)
    ee98:	4a16      	ldr	r2, [pc, #88]	; (eef4 <_sercom_set_handler+0x60>)
    ee9a:	7823      	ldrb	r3, [r4, #0]
    ee9c:	2b00      	cmp	r3, #0
    ee9e:	d109      	bne.n	eeb4 <_sercom_set_handler+0x20>
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
			_sercom_instances[i] = NULL;
    eea0:	001e      	movs	r6, r3
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    eea2:	4f15      	ldr	r7, [pc, #84]	; (eef8 <_sercom_set_handler+0x64>)
			_sercom_instances[i] = NULL;
    eea4:	4d15      	ldr	r5, [pc, #84]	; (eefc <_sercom_set_handler+0x68>)
			_sercom_interrupt_handlers[i] = &_sercom_default_handler;
    eea6:	50d7      	str	r7, [r2, r3]
			_sercom_instances[i] = NULL;
    eea8:	50ee      	str	r6, [r5, r3]
    eeaa:	3304      	adds	r3, #4
		for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    eeac:	2b18      	cmp	r3, #24
    eeae:	d1fa      	bne.n	eea6 <_sercom_set_handler+0x12>
		}

		_handler_table_initialized = true;
    eeb0:	3b17      	subs	r3, #23
    eeb2:	7023      	strb	r3, [r4, #0]
	}

	/* Save interrupt handler */
	_sercom_interrupt_handlers[instance] = interrupt_handler;  
    eeb4:	0083      	lsls	r3, r0, #2
    eeb6:	50d1      	str	r1, [r2, r3]
        /* install the interrupt handler in the proper spot in the 
         * vector table. */
        
        /* specific to SAMD21G since we are trying to add interrupts here to
         * the ram based NVIC controller */
        switch(instance) {
    eeb8:	2805      	cmp	r0, #5
    eeba:	d808      	bhi.n	eece <_sercom_set_handler+0x3a>
    eebc:	f001 fab8 	bl	10430 <__gnu_thumb1_case_uqi>
    eec0:	0e0b0803 	.word	0x0e0b0803
    eec4:	1411      	.short	0x1411
                case 0:
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM0, 
    eec6:	2009      	movs	r0, #9
    eec8:	490d      	ldr	r1, [pc, #52]	; (ef00 <_sercom_set_handler+0x6c>)
                case 4:
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM4, 
                            (uint32_t) SERCOM4_Handler);
                    break;
                case 5:
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM5, 
    eeca:	f7fd fbf1 	bl	c6b0 <NVIC_SetVector>
                            (uint32_t) SERCOM5_Handler);
                    break;                                        
        }
}
    eece:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM1, 
    eed0:	490c      	ldr	r1, [pc, #48]	; (ef04 <_sercom_set_handler+0x70>)
    eed2:	200a      	movs	r0, #10
    eed4:	e7f9      	b.n	eeca <_sercom_set_handler+0x36>
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM2, 
    eed6:	490c      	ldr	r1, [pc, #48]	; (ef08 <_sercom_set_handler+0x74>)
    eed8:	200b      	movs	r0, #11
    eeda:	e7f6      	b.n	eeca <_sercom_set_handler+0x36>
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM3, 
    eedc:	490b      	ldr	r1, [pc, #44]	; (ef0c <_sercom_set_handler+0x78>)
    eede:	200c      	movs	r0, #12
    eee0:	e7f3      	b.n	eeca <_sercom_set_handler+0x36>
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM4, 
    eee2:	490b      	ldr	r1, [pc, #44]	; (ef10 <_sercom_set_handler+0x7c>)
    eee4:	200d      	movs	r0, #13
    eee6:	e7f0      	b.n	eeca <_sercom_set_handler+0x36>
                    NVIC_SetVector(SYSTEM_INTERRUPT_MODULE_SERCOM5, 
    eee8:	490a      	ldr	r1, [pc, #40]	; (ef14 <_sercom_set_handler+0x80>)
    eeea:	200e      	movs	r0, #14
    eeec:	e7ed      	b.n	eeca <_sercom_set_handler+0x36>
    eeee:	46c0      	nop			; (mov r8, r8)
    eef0:	2000225e 	.word	0x2000225e
    eef4:	20002260 	.word	0x20002260
    eef8:	0000ee11 	.word	0x0000ee11
    eefc:	20002500 	.word	0x20002500
    ef00:	0000ee15 	.word	0x0000ee15
    ef04:	0000ee25 	.word	0x0000ee25
    ef08:	0000ee35 	.word	0x0000ee35
    ef0c:	0000ee45 	.word	0x0000ee45
    ef10:	0000ee55 	.word	0x0000ee55
    ef14:	0000ee65 	.word	0x0000ee65

0000ef18 <_usart_wait_for_sync>:
	SercomUsart *const usart_hw = &(module->hw->USART);
    ef18:	6802      	ldr	r2, [r0, #0]
	return (usart_hw->SYNCBUSY.reg);
    ef1a:	69d3      	ldr	r3, [r2, #28]
	while (usart_is_syncing(module)) {
    ef1c:	2b00      	cmp	r3, #0
    ef1e:	d1fc      	bne.n	ef1a <_usart_wait_for_sync+0x2>
}
    ef20:	4770      	bx	lr
	...

0000ef24 <usart_init>:
 */
enum status_code usart_init(
		struct usart_module *const module,
		Sercom *const hw,
		const struct usart_config *const config)
{
    ef24:	b5f0      	push	{r4, r5, r6, r7, lr}
    ef26:	0007      	movs	r7, r0
    ef28:	b08f      	sub	sp, #60	; 0x3c
	Assert(config);

	enum status_code status_code = STATUS_OK;

	/* Assign module pointer to software instance struct */
	module->hw = hw;
    ef2a:	6039      	str	r1, [r7, #0]

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    ef2c:	0008      	movs	r0, r1
{
    ef2e:	9105      	str	r1, [sp, #20]
    ef30:	0015      	movs	r5, r2
#else
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
	gclk_index   = sercom_index + SERCOM0_GCLK_ID_CORE;
#endif

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    ef32:	2601      	movs	r6, #1
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    ef34:	f000 fdaa 	bl	fa8c <_sercom_get_sercom_inst_index>
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    ef38:	9b05      	ldr	r3, [sp, #20]
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    ef3a:	4684      	mov	ip, r0
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    ef3c:	681b      	ldr	r3, [r3, #0]
		/* The module is busy resetting itself */
		return STATUS_BUSY;
    ef3e:	2005      	movs	r0, #5
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_SWRST) {
    ef40:	4233      	tst	r3, r6
    ef42:	d000      	beq.n	ef46 <usart_init+0x22>
    ef44:	e0f7      	b.n	f136 <usart_init+0x212>
	}

	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    ef46:	9b05      	ldr	r3, [sp, #20]
		/* Check the module is enabled */
		return STATUS_ERR_DENIED;
    ef48:	3017      	adds	r0, #23
	if (usart_hw->CTRLA.reg & SERCOM_USART_CTRLA_ENABLE) {
    ef4a:	681c      	ldr	r4, [r3, #0]
    ef4c:	2302      	movs	r3, #2
    ef4e:	401c      	ands	r4, r3
    ef50:	d000      	beq.n	ef54 <usart_init+0x30>
    ef52:	e0f0      	b.n	f136 <usart_init+0x212>
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    ef54:	4663      	mov	r3, ip
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBD, 1 << pm_index);
	} else {
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);	
	}
#else
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    ef56:	0030      	movs	r0, r6
	pm_index     = sercom_index + PM_APBCMASK_SERCOM0_Pos;
    ef58:	3302      	adds	r3, #2
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC, 1 << pm_index);
    ef5a:	4098      	lsls	r0, r3
    ef5c:	0003      	movs	r3, r0
			PM->APBCMASK.reg |= mask;
    ef5e:	4a90      	ldr	r2, [pc, #576]	; (f1a0 <usart_init+0x27c>)
    ef60:	6a11      	ldr	r1, [r2, #32]
    ef62:	430b      	orrs	r3, r1
    ef64:	6213      	str	r3, [r2, #32]
#endif

	/* Set up the GCLK for the module */
	struct system_gclk_chan_config gclk_chan_conf;
	system_gclk_chan_get_config_defaults(&gclk_chan_conf);
	gclk_chan_conf.source_generator = config->generator_source;
    ef66:	002b      	movs	r3, r5
    ef68:	332d      	adds	r3, #45	; 0x2d
    ef6a:	9304      	str	r3, [sp, #16]
    ef6c:	781b      	ldrb	r3, [r3, #0]
    ef6e:	a908      	add	r1, sp, #32
    ef70:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(gclk_index, &gclk_chan_conf);
    ef72:	4663      	mov	r3, ip
    ef74:	3314      	adds	r3, #20
    ef76:	b2db      	uxtb	r3, r3
    ef78:	0018      	movs	r0, r3
    ef7a:	9303      	str	r3, [sp, #12]
    ef7c:	f7fd fa04 	bl	c388 <system_gclk_chan_set_config>
	system_gclk_chan_enable(gclk_index);
    ef80:	9803      	ldr	r0, [sp, #12]
    ef82:	f7fd f9c5 	bl	c310 <system_gclk_chan_enable>
	sercom_set_gclk_generator(config->generator_source, false);
    ef86:	9b04      	ldr	r3, [sp, #16]
    ef88:	0021      	movs	r1, r4
    ef8a:	7818      	ldrb	r0, [r3, #0]
    ef8c:	f000 fcb2 	bl	f8f4 <sercom_set_gclk_generator>

	/* Set character size */
	module->character_size = config->character_size;
    ef90:	7aeb      	ldrb	r3, [r5, #11]
    ef92:	717b      	strb	r3, [r7, #5]

	/* Set transmitter and receiver status */
	module->receiver_enabled = config->receiver_enable;
    ef94:	1d6b      	adds	r3, r5, #5
    ef96:	7fdb      	ldrb	r3, [r3, #31]
    ef98:	71bb      	strb	r3, [r7, #6]
	module->transmitter_enabled = config->transmitter_enable;
    ef9a:	1dab      	adds	r3, r5, #6
    ef9c:	7fdb      	ldrb	r3, [r3, #31]
    ef9e:	71fb      	strb	r3, [r7, #7]

#ifdef FEATURE_USART_LIN_SLAVE
	module->lin_slave_enabled = config->lin_slave_enable;
    efa0:	7eeb      	ldrb	r3, [r5, #27]
    efa2:	723b      	strb	r3, [r7, #8]
#endif
#ifdef FEATURE_USART_START_FRAME_DECTION
	module->start_frame_detection_enabled = config->start_frame_detection_enable;
    efa4:	7f2b      	ldrb	r3, [r5, #28]
    efa6:	727b      	strb	r3, [r7, #9]
	SercomUsart *const usart_hw = &(module->hw->USART);
    efa8:	683b      	ldr	r3, [r7, #0]
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    efaa:	0018      	movs	r0, r3
	SercomUsart *const usart_hw = &(module->hw->USART);
    efac:	9304      	str	r3, [sp, #16]
	uint32_t sercom_index = _sercom_get_sercom_inst_index(module->hw);
    efae:	f000 fd6d 	bl	fa8c <_sercom_get_sercom_inst_index>
	uint16_t baud  = 0;
    efb2:	ab0a      	add	r3, sp, #40	; 0x28
    efb4:	801c      	strh	r4, [r3, #0]
	switch (config->sample_rate) {
    efb6:	2380      	movs	r3, #128	; 0x80
    efb8:	8a2a      	ldrh	r2, [r5, #16]
    efba:	01db      	lsls	r3, r3, #7
    efbc:	429a      	cmp	r2, r3
    efbe:	d100      	bne.n	efc2 <usart_init+0x9e>
    efc0:	e0cb      	b.n	f15a <usart_init+0x236>
    efc2:	d900      	bls.n	efc6 <usart_init+0xa2>
    efc4:	e0b9      	b.n	f13a <usart_init+0x216>
    efc6:	2380      	movs	r3, #128	; 0x80
    efc8:	019b      	lsls	r3, r3, #6
    efca:	429a      	cmp	r2, r3
    efcc:	d100      	bne.n	efd0 <usart_init+0xac>
    efce:	e0bf      	b.n	f150 <usart_init+0x22c>
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    efd0:	2310      	movs	r3, #16
	enum sercom_asynchronous_operation_mode mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    efd2:	2600      	movs	r6, #0
	enum sercom_asynchronous_sample_num sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    efd4:	9303      	str	r3, [sp, #12]
		(config->clock_polarity_inverted << SERCOM_USART_CTRLA_CPOL_Pos);
    efd6:	1deb      	adds	r3, r5, #7
    efd8:	7fdc      	ldrb	r4, [r3, #31]
    efda:	68e9      	ldr	r1, [r5, #12]
    efdc:	0763      	lsls	r3, r4, #29
    efde:	682c      	ldr	r4, [r5, #0]
    efe0:	9306      	str	r3, [sp, #24]
    efe2:	430c      	orrs	r4, r1
    efe4:	6969      	ldr	r1, [r5, #20]
	transfer_mode = (uint32_t)config->transfer_mode;
    efe6:	686b      	ldr	r3, [r5, #4]
    efe8:	430c      	orrs	r4, r1
    efea:	431c      	orrs	r4, r3
    efec:	4314      	orrs	r4, r2
		(config->immediate_buffer_overflow_notification << SERCOM_USART_CTRLA_IBON_Pos) |
    efee:	7e2a      	ldrb	r2, [r5, #24]
    eff0:	0212      	lsls	r2, r2, #8
    eff2:	4314      	orrs	r4, r2
    eff4:	002a      	movs	r2, r5
    eff6:	9407      	str	r4, [sp, #28]
    eff8:	3208      	adds	r2, #8
	switch (transfer_mode)
    effa:	2b00      	cmp	r3, #0
    effc:	d100      	bne.n	f000 <usart_init+0xdc>
    effe:	e0b0      	b.n	f162 <usart_init+0x23e>
    f000:	2180      	movs	r1, #128	; 0x80
    f002:	0549      	lsls	r1, r1, #21
    f004:	428b      	cmp	r3, r1
    f006:	d10f      	bne.n	f028 <usart_init+0x104>
			if (!config->use_external_clock) {
    f008:	7fd3      	ldrb	r3, [r2, #31]
    f00a:	2b00      	cmp	r3, #0
    f00c:	d10c      	bne.n	f028 <usart_init+0x104>
				status_code = _sercom_get_sync_baud_val(config->baudrate,
    f00e:	3014      	adds	r0, #20
    f010:	b2c0      	uxtb	r0, r0
    f012:	6a2c      	ldr	r4, [r5, #32]
    f014:	f7fd f9d8 	bl	c3c8 <system_gclk_chan_get_hz>
    f018:	aa0a      	add	r2, sp, #40	; 0x28
    f01a:	0001      	movs	r1, r0
    f01c:	0020      	movs	r0, r4
    f01e:	f000 fbb5 	bl	f78c <_sercom_get_sync_baud_val>
	if (status_code != STATUS_OK) {
    f022:	2800      	cmp	r0, #0
    f024:	d000      	beq.n	f028 <usart_init+0x104>
    f026:	e086      	b.n	f136 <usart_init+0x212>
	if(config->encoding_format_enable) {
    f028:	7e6b      	ldrb	r3, [r5, #25]
    f02a:	2b00      	cmp	r3, #0
    f02c:	d002      	beq.n	f034 <usart_init+0x110>
		usart_hw->RXPL.reg = config->receive_pulse_length;
    f02e:	7eab      	ldrb	r3, [r5, #26]
    f030:	9a04      	ldr	r2, [sp, #16]
    f032:	7393      	strb	r3, [r2, #14]
	_usart_wait_for_sync(module);
    f034:	0038      	movs	r0, r7
    f036:	f7ff ff6f 	bl	ef18 <_usart_wait_for_sync>
	usart_hw->BAUD.reg = baud;
    f03a:	ab06      	add	r3, sp, #24
    f03c:	8a1b      	ldrh	r3, [r3, #16]
    f03e:	9a04      	ldr	r2, [sp, #16]
	ctrla |= transfer_mode;
    f040:	9c06      	ldr	r4, [sp, #24]
	usart_hw->BAUD.reg = baud;
    f042:	8193      	strh	r3, [r2, #12]
	ctrla |= transfer_mode;
    f044:	9b07      	ldr	r3, [sp, #28]
    f046:	431c      	orrs	r4, r3
	if (config->use_external_clock == false) {
    f048:	002b      	movs	r3, r5
    f04a:	3308      	adds	r3, #8
    f04c:	7fdb      	ldrb	r3, [r3, #31]
    f04e:	2b00      	cmp	r3, #0
    f050:	d101      	bne.n	f056 <usart_init+0x132>
		ctrla |= SERCOM_USART_CTRLA_MODE(0x1);
    f052:	3304      	adds	r3, #4
    f054:	431c      	orrs	r4, r3
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    f056:	7e6e      	ldrb	r6, [r5, #25]
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    f058:	7f2b      	ldrb	r3, [r5, #28]
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    f05a:	02b6      	lsls	r6, r6, #10
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    f05c:	025b      	lsls	r3, r3, #9
			(config->encoding_format_enable << SERCOM_USART_CTRLB_ENC_Pos) |
    f05e:	431e      	orrs	r6, r3
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    f060:	7f6b      	ldrb	r3, [r5, #29]
    f062:	021b      	lsls	r3, r3, #8
			(config->start_frame_detection_enable << SERCOM_USART_CTRLB_SFDE_Pos) |
    f064:	431e      	orrs	r6, r3
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    f066:	1d6b      	adds	r3, r5, #5
    f068:	7fdb      	ldrb	r3, [r3, #31]
    f06a:	045b      	lsls	r3, r3, #17
			(config->collision_detection_enable << SERCOM_USART_CTRLB_COLDEN_Pos) |
    f06c:	431e      	orrs	r6, r3
			(config->transmitter_enable << SERCOM_USART_CTRLB_TXEN_Pos);
    f06e:	1dab      	adds	r3, r5, #6
    f070:	7fdb      	ldrb	r3, [r3, #31]
    f072:	041b      	lsls	r3, r3, #16
			(config->receiver_enable << SERCOM_USART_CTRLB_RXEN_Pos) |
    f074:	431e      	orrs	r6, r3
	ctrlb |= (uint32_t)config->character_size;
    f076:	7aeb      	ldrb	r3, [r5, #11]
    f078:	431e      	orrs	r6, r3
	if (config->parity != USART_PARITY_NONE) {
    f07a:	892b      	ldrh	r3, [r5, #8]
    f07c:	2bff      	cmp	r3, #255	; 0xff
    f07e:	d100      	bne.n	f082 <usart_init+0x15e>
    f080:	e086      	b.n	f190 <usart_init+0x26c>
		ctrla |= SERCOM_USART_CTRLA_FORM(1);
    f082:	2280      	movs	r2, #128	; 0x80
    f084:	0452      	lsls	r2, r2, #17
    f086:	4314      	orrs	r4, r2
		ctrlb |= config->parity;
    f088:	431e      	orrs	r6, r3
	if (config->run_in_standby || system_is_debugger_present()) {
    f08a:	002b      	movs	r3, r5
    f08c:	332c      	adds	r3, #44	; 0x2c
    f08e:	781b      	ldrb	r3, [r3, #0]
    f090:	2b00      	cmp	r3, #0
    f092:	d103      	bne.n	f09c <usart_init+0x178>
 * \retval false Debugger is not connected to the system
 *
 */
static inline bool system_is_debugger_present(void)
{
	return DSU->STATUSB.reg & DSU_STATUSB_DBGPRES;
    f094:	4b43      	ldr	r3, [pc, #268]	; (f1a4 <usart_init+0x280>)
    f096:	789b      	ldrb	r3, [r3, #2]
    f098:	079b      	lsls	r3, r3, #30
    f09a:	d501      	bpl.n	f0a0 <usart_init+0x17c>
		ctrla |= SERCOM_USART_CTRLA_RUNSTDBY;
    f09c:	2380      	movs	r3, #128	; 0x80
    f09e:	431c      	orrs	r4, r3
	_usart_wait_for_sync(module);
    f0a0:	0038      	movs	r0, r7
    f0a2:	f7ff ff39 	bl	ef18 <_usart_wait_for_sync>
	usart_hw->CTRLB.reg = ctrlb;
    f0a6:	9b04      	ldr	r3, [sp, #16]
	_usart_wait_for_sync(module);
    f0a8:	0038      	movs	r0, r7
	usart_hw->CTRLB.reg = ctrlb;
    f0aa:	605e      	str	r6, [r3, #4]
	_usart_wait_for_sync(module);
    f0ac:	f7ff ff34 	bl	ef18 <_usart_wait_for_sync>
	usart_hw->CTRLA.reg = ctrla;
    f0b0:	9b04      	ldr	r3, [sp, #16]
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    f0b2:	2600      	movs	r6, #0
    f0b4:	601c      	str	r4, [r3, #0]
	config->mux_position = SYSTEM_PINMUX_GPIO;
    f0b6:	2380      	movs	r3, #128	; 0x80
    f0b8:	ac09      	add	r4, sp, #36	; 0x24
    f0ba:	7023      	strb	r3, [r4, #0]
	struct system_pinmux_config pin_conf;
	system_pinmux_get_config_defaults(&pin_conf);
	pin_conf.direction = SYSTEM_PINMUX_PIN_DIR_INPUT;
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;

	uint32_t pad_pinmuxes[] = {
    f0bc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
	config->direction    = SYSTEM_PINMUX_PIN_DIR_INPUT;
    f0be:	7066      	strb	r6, [r4, #1]
    f0c0:	930a      	str	r3, [sp, #40]	; 0x28
    f0c2:	6b6b      	ldr	r3, [r5, #52]	; 0x34
	config->powersave    = false;
    f0c4:	70e6      	strb	r6, [r4, #3]
    f0c6:	930b      	str	r3, [sp, #44]	; 0x2c
    f0c8:	6bab      	ldr	r3, [r5, #56]	; 0x38
	pin_conf.input_pull = SYSTEM_PINMUX_PIN_PULL_NONE;
    f0ca:	70a6      	strb	r6, [r4, #2]
	uint32_t pad_pinmuxes[] = {
    f0cc:	930c      	str	r3, [sp, #48]	; 0x30
    f0ce:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    f0d0:	9303      	str	r3, [sp, #12]
    f0d2:	930d      	str	r3, [sp, #52]	; 0x34
			config->pinmux_pad2, config->pinmux_pad3
		};

	/* Configure the SERCOM pins according to the user configuration */
	for (uint8_t pad = 0; pad < 4; pad++) {
		uint32_t current_pinmux = pad_pinmuxes[pad];
    f0d4:	2010      	movs	r0, #16
    f0d6:	aa06      	add	r2, sp, #24
    f0d8:	00b3      	lsls	r3, r6, #2
    f0da:	1812      	adds	r2, r2, r0
    f0dc:	58d0      	ldr	r0, [r2, r3]
    f0de:	b2f1      	uxtb	r1, r6

		if (current_pinmux == PINMUX_DEFAULT) {
    f0e0:	2800      	cmp	r0, #0
    f0e2:	d102      	bne.n	f0ea <usart_init+0x1c6>
			current_pinmux = _sercom_get_default_pad(hw, pad);
    f0e4:	9805      	ldr	r0, [sp, #20]
    f0e6:	f000 fc23 	bl	f930 <_sercom_get_default_pad>
		}

		if (current_pinmux != PINMUX_UNUSED) {
    f0ea:	1c43      	adds	r3, r0, #1
    f0ec:	d005      	beq.n	f0fa <usart_init+0x1d6>
			pin_conf.mux_position = current_pinmux & 0xFFFF;
    f0ee:	7020      	strb	r0, [r4, #0]
			system_pinmux_pin_set_config(current_pinmux >> 16, &pin_conf);
    f0f0:	0c00      	lsrs	r0, r0, #16
    f0f2:	b2c0      	uxtb	r0, r0
    f0f4:	0021      	movs	r1, r4
    f0f6:	f7fd fc0b 	bl	c910 <system_pinmux_pin_set_config>
    f0fa:	3601      	adds	r6, #1
	for (uint8_t pad = 0; pad < 4; pad++) {
    f0fc:	2e04      	cmp	r6, #4
    f0fe:	d1e9      	bne.n	f0d4 <usart_init+0x1b0>
	module->rx_buffer_ptr              = NULL;
	module->remaining_tx_buffer_length = 0x0000;
	module->remaining_rx_buffer_length = 0x0000;
	module->callback_reg_mask          = 0x00;
	module->callback_enable_mask       = 0x00;
	module->rx_status                  = STATUS_OK;
    f100:	003b      	movs	r3, r7
		module->callback[i]            = NULL;
    f102:	2400      	movs	r4, #0
	module->rx_status                  = STATUS_OK;
    f104:	3332      	adds	r3, #50	; 0x32
	module->remaining_tx_buffer_length = 0x0000;
    f106:	85fc      	strh	r4, [r7, #46]	; 0x2e
		module->callback[i]            = NULL;
    f108:	60fc      	str	r4, [r7, #12]
    f10a:	613c      	str	r4, [r7, #16]
    f10c:	617c      	str	r4, [r7, #20]
    f10e:	61bc      	str	r4, [r7, #24]
    f110:	61fc      	str	r4, [r7, #28]
    f112:	623c      	str	r4, [r7, #32]
	module->tx_buffer_ptr              = NULL;
    f114:	62bc      	str	r4, [r7, #40]	; 0x28
	module->rx_buffer_ptr              = NULL;
    f116:	627c      	str	r4, [r7, #36]	; 0x24
	module->remaining_rx_buffer_length = 0x0000;
    f118:	85bc      	strh	r4, [r7, #44]	; 0x2c
	module->callback_reg_mask          = 0x00;
    f11a:	863c      	strh	r4, [r7, #48]	; 0x30
	module->tx_status                  = STATUS_OK;

	/* Set interrupt handler and register USART software module struct in
	 * look-up table */
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    f11c:	6838      	ldr	r0, [r7, #0]
	module->rx_status                  = STATUS_OK;
    f11e:	701c      	strb	r4, [r3, #0]
	module->tx_status                  = STATUS_OK;
    f120:	705c      	strb	r4, [r3, #1]
	uint8_t instance_index = _sercom_get_sercom_inst_index(module->hw);
    f122:	f000 fcb3 	bl	fa8c <_sercom_get_sercom_inst_index>
    f126:	0005      	movs	r5, r0
	_sercom_set_handler(instance_index, _usart_interrupt_handler);
    f128:	491f      	ldr	r1, [pc, #124]	; (f1a8 <usart_init+0x284>)
    f12a:	f7ff feb3 	bl	ee94 <_sercom_set_handler>
	_sercom_instances[instance_index] = module;
#endif

	return status_code;
    f12e:	0020      	movs	r0, r4
	_sercom_instances[instance_index] = module;
    f130:	4b1e      	ldr	r3, [pc, #120]	; (f1ac <usart_init+0x288>)
    f132:	00ad      	lsls	r5, r5, #2
    f134:	50ef      	str	r7, [r5, r3]
}
    f136:	b00f      	add	sp, #60	; 0x3c
    f138:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (config->sample_rate) {
    f13a:	23c0      	movs	r3, #192	; 0xc0
    f13c:	01db      	lsls	r3, r3, #7
    f13e:	429a      	cmp	r2, r3
    f140:	d009      	beq.n	f156 <usart_init+0x232>
    f142:	2380      	movs	r3, #128	; 0x80
    f144:	021b      	lsls	r3, r3, #8
    f146:	429a      	cmp	r2, r3
    f148:	d000      	beq.n	f14c <usart_init+0x228>
    f14a:	e741      	b.n	efd0 <usart_init+0xac>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_3;
    f14c:	2303      	movs	r3, #3
    f14e:	e740      	b.n	efd2 <usart_init+0xae>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_16;
    f150:	2310      	movs	r3, #16
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    f152:	9303      	str	r3, [sp, #12]
    f154:	e73f      	b.n	efd6 <usart_init+0xb2>
    f156:	2308      	movs	r3, #8
    f158:	e7fb      	b.n	f152 <usart_init+0x22e>
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    f15a:	2308      	movs	r3, #8
			mode = SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC;
    f15c:	0026      	movs	r6, r4
			sample_num = SERCOM_ASYNC_SAMPLE_NUM_8;
    f15e:	9303      	str	r3, [sp, #12]
    f160:	e739      	b.n	efd6 <usart_init+0xb2>
			if (config->use_external_clock) {
    f162:	7fd3      	ldrb	r3, [r2, #31]
    f164:	6a2c      	ldr	r4, [r5, #32]
    f166:	2b00      	cmp	r3, #0
    f168:	d008      	beq.n	f17c <usart_init+0x258>
				status_code =
    f16a:	9b03      	ldr	r3, [sp, #12]
    f16c:	aa0a      	add	r2, sp, #40	; 0x28
    f16e:	9300      	str	r3, [sp, #0]
    f170:	0033      	movs	r3, r6
    f172:	6aa9      	ldr	r1, [r5, #40]	; 0x28
				status_code =
    f174:	0020      	movs	r0, r4
    f176:	f000 fb1d 	bl	f7b4 <_sercom_get_async_baud_val>
    f17a:	e752      	b.n	f022 <usart_init+0xfe>
						_sercom_get_async_baud_val(config->baudrate,
    f17c:	3014      	adds	r0, #20
    f17e:	b2c0      	uxtb	r0, r0
    f180:	f7fd f922 	bl	c3c8 <system_gclk_chan_get_hz>
				status_code =
    f184:	9b03      	ldr	r3, [sp, #12]
						_sercom_get_async_baud_val(config->baudrate,
    f186:	0001      	movs	r1, r0
				status_code =
    f188:	9300      	str	r3, [sp, #0]
    f18a:	aa0a      	add	r2, sp, #40	; 0x28
    f18c:	0033      	movs	r3, r6
    f18e:	e7f1      	b.n	f174 <usart_init+0x250>
		if(config->lin_slave_enable) {
    f190:	7eeb      	ldrb	r3, [r5, #27]
    f192:	2b00      	cmp	r3, #0
    f194:	d100      	bne.n	f198 <usart_init+0x274>
    f196:	e778      	b.n	f08a <usart_init+0x166>
			ctrla |= SERCOM_USART_CTRLA_FORM(0x4);
    f198:	2380      	movs	r3, #128	; 0x80
    f19a:	04db      	lsls	r3, r3, #19
    f19c:	431c      	orrs	r4, r3
    f19e:	e774      	b.n	f08a <usart_init+0x166>
    f1a0:	40000400 	.word	0x40000400
    f1a4:	41002000 	.word	0x41002000
    f1a8:	0000f299 	.word	0x0000f299
    f1ac:	20002500 	.word	0x20002500

0000f1b0 <usart_write_wait>:
 * \retval STATUS_ERR_DENIED If the transmitter is not enabled
 */
enum status_code usart_write_wait(
		struct usart_module *const module,
		const uint16_t tx_data)
{
    f1b0:	b570      	push	{r4, r5, r6, lr}

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);

	/* Check that the transmitter is enabled */
	if (!(module->transmitter_enabled)) {
    f1b2:	79c2      	ldrb	r2, [r0, #7]
{
    f1b4:	000d      	movs	r5, r1
		return STATUS_ERR_DENIED;
    f1b6:	231c      	movs	r3, #28
	if (!(module->transmitter_enabled)) {
    f1b8:	2a00      	cmp	r2, #0
    f1ba:	d00c      	beq.n	f1d6 <usart_write_wait+0x26>
	}

#if USART_CALLBACK_MODE == true
	/* Check if the USART is busy doing asynchronous operation. */
	if (module->remaining_tx_buffer_length > 0) {
    f1bc:	8dc2      	ldrh	r2, [r0, #46]	; 0x2e
		return STATUS_BUSY;
    f1be:	3b17      	subs	r3, #23
	if (module->remaining_tx_buffer_length > 0) {
    f1c0:	2a00      	cmp	r2, #0
    f1c2:	d108      	bne.n	f1d6 <usart_write_wait+0x26>
	SercomUsart *const usart_hw = &(module->hw->USART);
    f1c4:	6804      	ldr	r4, [r0, #0]
		return STATUS_BUSY;
	}
#endif

	/* Wait until synchronization is complete */
	_usart_wait_for_sync(module);
    f1c6:	f7ff fea7 	bl	ef18 <_usart_wait_for_sync>

	/* Write data to USART module */
	usart_hw->DATA.reg = tx_data;

	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
    f1ca:	2302      	movs	r3, #2
	usart_hw->DATA.reg = tx_data;
    f1cc:	8525      	strh	r5, [r4, #40]	; 0x28
	while (!(usart_hw->INTFLAG.reg & SERCOM_USART_INTFLAG_TXC)) {
    f1ce:	7e22      	ldrb	r2, [r4, #24]
    f1d0:	421a      	tst	r2, r3
    f1d2:	d0fc      	beq.n	f1ce <usart_write_wait+0x1e>
		/* Wait until data is sent */
	}

	return STATUS_OK;
    f1d4:	2300      	movs	r3, #0
}
    f1d6:	0018      	movs	r0, r3
    f1d8:	bd70      	pop	{r4, r5, r6, pc}

0000f1da <_usart_write_buffer>:
 */
enum status_code _usart_write_buffer(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
    f1da:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    f1dc:	0005      	movs	r5, r0
	Assert(module);
	Assert(module->hw);
	Assert(tx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    f1de:	6803      	ldr	r3, [r0, #0]
{
    f1e0:	000e      	movs	r6, r1
    f1e2:	0017      	movs	r7, r2
	SercomUsart *const usart_hw = &(module->hw->USART);
    f1e4:	9301      	str	r3, [sp, #4]
	cpu_irq_enter_critical();
    f1e6:	f7fd f909 	bl	c3fc <cpu_irq_enter_critical>

	system_interrupt_enter_critical_section();

	/* Check if the USART transmitter is busy */
	if (module->remaining_tx_buffer_length > 0) {
    f1ea:	8dec      	ldrh	r4, [r5, #46]	; 0x2e
    f1ec:	b2a4      	uxth	r4, r4
    f1ee:	2c00      	cmp	r4, #0
    f1f0:	d003      	beq.n	f1fa <_usart_write_buffer+0x20>
	cpu_irq_leave_critical();
    f1f2:	f7fd f91d 	bl	c430 <cpu_irq_leave_critical>
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
    f1f6:	2005      	movs	r0, #5

	/* Enable the Data Register Empty Interrupt */
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;

	return STATUS_OK;
}
    f1f8:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
	module->remaining_tx_buffer_length = length;
    f1fa:	85ef      	strh	r7, [r5, #46]	; 0x2e
    f1fc:	f7fd f918 	bl	c430 <cpu_irq_leave_critical>
	module->tx_status                  = STATUS_BUSY;
    f200:	2305      	movs	r3, #5
	module->tx_buffer_ptr              = tx_data;
    f202:	62ae      	str	r6, [r5, #40]	; 0x28
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;
    f204:	9a01      	ldr	r2, [sp, #4]
	module->tx_status                  = STATUS_BUSY;
    f206:	3533      	adds	r5, #51	; 0x33
    f208:	702b      	strb	r3, [r5, #0]
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_DRE;
    f20a:	3b04      	subs	r3, #4
    f20c:	7593      	strb	r3, [r2, #22]
	return STATUS_OK;
    f20e:	0020      	movs	r0, r4
    f210:	e7f2      	b.n	f1f8 <_usart_write_buffer+0x1e>

0000f212 <_usart_read_buffer>:
 */
enum status_code _usart_read_buffer(
		struct usart_module *const module,
		uint8_t *rx_data,
		uint16_t length)
{
    f212:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f214:	0004      	movs	r4, r0
    f216:	000e      	movs	r6, r1
    f218:	0017      	movs	r7, r2
	Assert(module);
	Assert(module->hw);
	Assert(rx_data);

	/* Get a pointer to the hardware module instance */
	SercomUsart *const usart_hw = &(module->hw->USART);
    f21a:	6805      	ldr	r5, [r0, #0]
	cpu_irq_enter_critical();
    f21c:	f7fd f8ee 	bl	c3fc <cpu_irq_enter_critical>

	system_interrupt_enter_critical_section();

	/* Check if the USART receiver is busy */
	if (module->remaining_rx_buffer_length > 0) {
    f220:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    f222:	2b00      	cmp	r3, #0
    f224:	d003      	beq.n	f22e <_usart_read_buffer+0x1c>
	cpu_irq_leave_critical();
    f226:	f7fd f903 	bl	c430 <cpu_irq_leave_critical>
		system_interrupt_leave_critical_section();
		return STATUS_BUSY;
    f22a:	2005      	movs	r0, #5
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
	}
#endif

	return STATUS_OK;
}
    f22c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	module->remaining_rx_buffer_length = length;
    f22e:	85a7      	strh	r7, [r4, #44]	; 0x2c
    f230:	f7fd f8fe 	bl	c430 <cpu_irq_leave_critical>
	module->rx_status                  = STATUS_BUSY;
    f234:	0023      	movs	r3, r4
    f236:	2205      	movs	r2, #5
    f238:	3332      	adds	r3, #50	; 0x32
	module->rx_buffer_ptr              = rx_data;
    f23a:	6266      	str	r6, [r4, #36]	; 0x24
	module->rx_status                  = STATUS_BUSY;
    f23c:	701a      	strb	r2, [r3, #0]
	usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXC;
    f23e:	2304      	movs	r3, #4
    f240:	75ab      	strb	r3, [r5, #22]
	if(module->lin_slave_enabled) {
    f242:	7a23      	ldrb	r3, [r4, #8]
    f244:	2b00      	cmp	r3, #0
    f246:	d001      	beq.n	f24c <_usart_read_buffer+0x3a>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXBRK;
    f248:	2320      	movs	r3, #32
    f24a:	75ab      	strb	r3, [r5, #22]
	return STATUS_OK;
    f24c:	2000      	movs	r0, #0
	if(module->start_frame_detection_enabled) {
    f24e:	7a63      	ldrb	r3, [r4, #9]
    f250:	4283      	cmp	r3, r0
    f252:	d0eb      	beq.n	f22c <_usart_read_buffer+0x1a>
		usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_RXS;
    f254:	2308      	movs	r3, #8
    f256:	75ab      	strb	r3, [r5, #22]
    f258:	e7e8      	b.n	f22c <_usart_read_buffer+0x1a>

0000f25a <usart_register_callback>:
	/* Sanity check arguments */
	Assert(module);
	Assert(callback_func);

	/* Register callback function */
	module->callback[callback_type] = callback_func;
    f25a:	1c93      	adds	r3, r2, #2
    f25c:	009b      	lsls	r3, r3, #2
    f25e:	18c3      	adds	r3, r0, r3
    f260:	6059      	str	r1, [r3, #4]

	/* Set the bit corresponding to the callback_type */
	module->callback_reg_mask |= (1 << callback_type);
    f262:	2301      	movs	r3, #1
    f264:	4093      	lsls	r3, r2
    f266:	001a      	movs	r2, r3
    f268:	3030      	adds	r0, #48	; 0x30
    f26a:	7803      	ldrb	r3, [r0, #0]
    f26c:	4313      	orrs	r3, r2
    f26e:	7003      	strb	r3, [r0, #0]
}
    f270:	4770      	bx	lr

0000f272 <usart_read_job>:
 * \retval  STATUS_BUSY  If operation was not completed
 */
enum status_code usart_read_job(
		struct usart_module *const module,
		uint16_t *const rx_data)
{
    f272:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(rx_data);

	/* Call internal read buffer function with length 1 */
	return _usart_read_buffer(module, (uint8_t *)rx_data, 1);
    f274:	2201      	movs	r2, #1
    f276:	f7ff ffcc 	bl	f212 <_usart_read_buffer>
}
    f27a:	bd10      	pop	{r4, pc}

0000f27c <usart_write_buffer_job>:
 */
enum status_code usart_write_buffer_job(
		struct usart_module *const module,
		uint8_t *tx_data,
		uint16_t length)
{
    f27c:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module);
	Assert(tx_data);

	if (length == 0) {
		return STATUS_ERR_INVALID_ARG;
    f27e:	2317      	movs	r3, #23
	if (length == 0) {
    f280:	2a00      	cmp	r2, #0
    f282:	d006      	beq.n	f292 <usart_write_buffer_job+0x16>
	}

	/* Check that the receiver is enabled */
	if (!(module->transmitter_enabled)) {
    f284:	79c4      	ldrb	r4, [r0, #7]
		return STATUS_ERR_DENIED;
    f286:	3305      	adds	r3, #5
	if (!(module->transmitter_enabled)) {
    f288:	2c00      	cmp	r4, #0
    f28a:	d002      	beq.n	f292 <usart_write_buffer_job+0x16>
	}

	/* Issue internal asynchronous write */
	return _usart_write_buffer(module, tx_data, length);
    f28c:	f7ff ffa5 	bl	f1da <_usart_write_buffer>
    f290:	0003      	movs	r3, r0
}
    f292:	0018      	movs	r0, r3
    f294:	bd10      	pop	{r4, pc}
	...

0000f298 <_usart_interrupt_handler>:
 * \param[in]  instance  ID of the SERCOM instance calling the interrupt
 *                       handler.
 */
void _usart_interrupt_handler(
		uint8_t instance)
{
    f298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t callback_status;
	uint8_t error_code;


	/* Get device instance from the look-up table */
	struct usart_module *module
    f29a:	4b59      	ldr	r3, [pc, #356]	; (f400 <_usart_interrupt_handler+0x168>)
    f29c:	0080      	lsls	r0, r0, #2
    f29e:	58c4      	ldr	r4, [r0, r3]
		= (struct usart_module *)_sercom_instances[instance];

	/* Pointer to the hardware module instance */
	SercomUsart *const usart_hw
		= &(module->hw->USART);
    f2a0:	6825      	ldr	r5, [r4, #0]
	return (usart_hw->SYNCBUSY.reg);
    f2a2:	69eb      	ldr	r3, [r5, #28]
	while (usart_is_syncing(module)) {
    f2a4:	2b00      	cmp	r3, #0
    f2a6:	d1fc      	bne.n	f2a2 <_usart_interrupt_handler+0xa>

	/* Wait for the synchronization to complete */
	_usart_wait_for_sync(module);

	/* Read and mask interrupt flag register */
	interrupt_status = usart_hw->INTFLAG.reg;
    f2a8:	7e2b      	ldrb	r3, [r5, #24]
	interrupt_status &= usart_hw->INTENSET.reg;
    f2aa:	7daf      	ldrb	r7, [r5, #22]
    f2ac:	401f      	ands	r7, r3
	callback_status = module->callback_reg_mask &
    f2ae:	0023      	movs	r3, r4
    f2b0:	3330      	adds	r3, #48	; 0x30
    f2b2:	781a      	ldrb	r2, [r3, #0]
    f2b4:	785e      	ldrb	r6, [r3, #1]
			module->callback_enable_mask;

	/* Check if a DATA READY interrupt has occurred,
	 * and if there is more to transfer */
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    f2b6:	2301      	movs	r3, #1
	callback_status = module->callback_reg_mask &
    f2b8:	4016      	ands	r6, r2
	if (interrupt_status & SERCOM_USART_INTFLAG_DRE) {
    f2ba:	421f      	tst	r7, r3
    f2bc:	d01a      	beq.n	f2f4 <_usart_interrupt_handler+0x5c>
		if (module->remaining_tx_buffer_length) {
    f2be:	8de2      	ldrh	r2, [r4, #46]	; 0x2e
    f2c0:	2a00      	cmp	r2, #0
    f2c2:	d100      	bne.n	f2c6 <_usart_interrupt_handler+0x2e>
    f2c4:	e075      	b.n	f3b2 <_usart_interrupt_handler+0x11a>
			/* Write value will be at least 8-bits long */
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    f2c6:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			/* Increment 8-bit pointer */
			(module->tx_buffer_ptr)++;
    f2c8:	1c51      	adds	r1, r2, #1
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    f2ca:	7813      	ldrb	r3, [r2, #0]
			(module->tx_buffer_ptr)++;
    f2cc:	62a1      	str	r1, [r4, #40]	; 0x28

			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    f2ce:	7961      	ldrb	r1, [r4, #5]
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    f2d0:	b2db      	uxtb	r3, r3
			if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    f2d2:	2901      	cmp	r1, #1
    f2d4:	d100      	bne.n	f2d8 <_usart_interrupt_handler+0x40>
    f2d6:	e066      	b.n	f3a6 <_usart_interrupt_handler+0x10e>
			uint16_t data_to_send = *(module->tx_buffer_ptr);
    f2d8:	b29b      	uxth	r3, r3
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
				/* Increment 8-bit pointer */
				(module->tx_buffer_ptr)++;
			}
			/* Write the data to send */
			usart_hw->DATA.reg = (data_to_send & SERCOM_USART_DATA_MASK);
    f2da:	05db      	lsls	r3, r3, #23
    f2dc:	0ddb      	lsrs	r3, r3, #23
    f2de:	852b      	strh	r3, [r5, #40]	; 0x28

			if (--(module->remaining_tx_buffer_length) == 0) {
    f2e0:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    f2e2:	3b01      	subs	r3, #1
    f2e4:	b29b      	uxth	r3, r3
    f2e6:	85e3      	strh	r3, [r4, #46]	; 0x2e
    f2e8:	2b00      	cmp	r3, #0
    f2ea:	d103      	bne.n	f2f4 <_usart_interrupt_handler+0x5c>
				/* Disable the Data Register Empty Interrupt */
				usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    f2ec:	3301      	adds	r3, #1
    f2ee:	752b      	strb	r3, [r5, #20]
				/* Enable Transmission Complete interrupt */
				usart_hw->INTENSET.reg = SERCOM_USART_INTFLAG_TXC;
    f2f0:	3301      	adds	r3, #1
    f2f2:	75ab      	strb	r3, [r5, #22]

	/* Check if the Transmission Complete interrupt has occurred and
	 * that the transmit buffer is empty */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_TXC) {
    f2f4:	2302      	movs	r3, #2
    f2f6:	421f      	tst	r7, r3
    f2f8:	d009      	beq.n	f30e <_usart_interrupt_handler+0x76>

		/* Disable TX Complete Interrupt, and set STATUS_OK */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_TXC;
    f2fa:	752b      	strb	r3, [r5, #20]
		module->tx_status = STATUS_OK;
    f2fc:	0023      	movs	r3, r4
    f2fe:	2200      	movs	r2, #0
    f300:	3333      	adds	r3, #51	; 0x33
    f302:	701a      	strb	r2, [r3, #0]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BUFFER_TRANSMITTED)) {
    f304:	07f3      	lsls	r3, r6, #31
    f306:	d502      	bpl.n	f30e <_usart_interrupt_handler+0x76>
			(*(module->callback[USART_CALLBACK_BUFFER_TRANSMITTED]))(module);
    f308:	0020      	movs	r0, r4
    f30a:	68e3      	ldr	r3, [r4, #12]
    f30c:	4798      	blx	r3

	/* Check if the Receive Complete interrupt has occurred, and that
	 * there's more data to receive */
	}

	if (interrupt_status & SERCOM_USART_INTFLAG_RXC) {
    f30e:	2304      	movs	r3, #4
    f310:	421f      	tst	r7, r3
    f312:	d029      	beq.n	f368 <_usart_interrupt_handler+0xd0>

		if (module->remaining_rx_buffer_length) {
    f314:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
    f316:	2a00      	cmp	r2, #0
    f318:	d100      	bne.n	f31c <_usart_interrupt_handler+0x84>
    f31a:	e06f      	b.n	f3fc <_usart_interrupt_handler+0x164>
			/* Read out the status code and mask away all but the 4 LSBs*/
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    f31c:	8b6b      	ldrh	r3, [r5, #26]
    f31e:	b2db      	uxtb	r3, r3
#if !SAMD20
			/* CTS status should not be considered as an error */
			if(error_code & SERCOM_USART_STATUS_CTS) {
    f320:	071a      	lsls	r2, r3, #28
    f322:	d448      	bmi.n	f3b6 <_usart_interrupt_handler+0x11e>
			error_code = (uint8_t)(usart_hw->STATUS.reg & SERCOM_USART_STATUS_MASK);
    f324:	223f      	movs	r2, #63	; 0x3f
				error_code &= ~SERCOM_USART_STATUS_CTS;
    f326:	4013      	ands	r3, r2
			if(error_code & SERCOM_USART_STATUS_TXE) {
				error_code &= ~SERCOM_USART_STATUS_TXE;
			}
#endif
			/* Check if an error has occurred during the receiving */
			if (error_code) {
    f328:	d047      	beq.n	f3ba <_usart_interrupt_handler+0x122>
				/* Check which error occurred */
				if (error_code & SERCOM_USART_STATUS_FERR) {
    f32a:	2202      	movs	r2, #2
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_FORMAT;
    f32c:	211a      	movs	r1, #26
				if (error_code & SERCOM_USART_STATUS_FERR) {
    f32e:	4213      	tst	r3, r2
    f330:	d10f      	bne.n	f352 <_usart_interrupt_handler+0xba>
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_FERR;
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    f332:	2204      	movs	r2, #4
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_OVERFLOW;
    f334:	211e      	movs	r1, #30
				} else if (error_code & SERCOM_USART_STATUS_BUFOVF) {
    f336:	4213      	tst	r3, r2
    f338:	d10b      	bne.n	f352 <_usart_interrupt_handler+0xba>
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_BUFOVF;
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    f33a:	2201      	movs	r2, #1
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_BAD_DATA;
    f33c:	2113      	movs	r1, #19
				} else if (error_code & SERCOM_USART_STATUS_PERR) {
    f33e:	4213      	tst	r3, r2
    f340:	d107      	bne.n	f352 <_usart_interrupt_handler+0xba>
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_PERR;
				}
#ifdef FEATURE_USART_LIN_SLAVE
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    f342:	2210      	movs	r2, #16
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PROTOCOL;
    f344:	2142      	movs	r1, #66	; 0x42
				else if (error_code & SERCOM_USART_STATUS_ISF) {
    f346:	4213      	tst	r3, r2
    f348:	d103      	bne.n	f352 <_usart_interrupt_handler+0xba>
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_ISF;
				}
#endif
#ifdef FEATURE_USART_COLLISION_DECTION
				else if (error_code & SERCOM_USART_STATUS_COLL) {
    f34a:	2220      	movs	r2, #32
    f34c:	4213      	tst	r3, r2
    f34e:	d006      	beq.n	f35e <_usart_interrupt_handler+0xc6>
					/* Store the error code and clear flag by writing 1 to it */
					module->rx_status = STATUS_ERR_PACKET_COLLISION;
    f350:	2141      	movs	r1, #65	; 0x41
    f352:	0023      	movs	r3, r4
    f354:	3332      	adds	r3, #50	; 0x32
    f356:	7019      	strb	r1, [r3, #0]
					usart_hw->STATUS.reg |= SERCOM_USART_STATUS_COLL;
    f358:	8b6b      	ldrh	r3, [r5, #26]
    f35a:	431a      	orrs	r2, r3
    f35c:	836a      	strh	r2, [r5, #26]
				}
#endif

				/* Run callback if registered and enabled */
				if (callback_status
    f35e:	0773      	lsls	r3, r6, #29
    f360:	d502      	bpl.n	f368 <_usart_interrupt_handler+0xd0>
						& (1 << USART_CALLBACK_ERROR)) {
					(*(module->callback[USART_CALLBACK_ERROR]))(module);
    f362:	0020      	movs	r0, r4
    f364:	6963      	ldr	r3, [r4, #20]
					module->rx_status = STATUS_OK;

					/* Run callback if registered and enabled */
					if (callback_status
							& (1 << USART_CALLBACK_BUFFER_RECEIVED)) {
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    f366:	4798      	blx	r3
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
		}
	}

#ifdef FEATURE_USART_HARDWARE_FLOW_CONTROL
	if (interrupt_status & SERCOM_USART_INTFLAG_CTSIC) {
    f368:	2310      	movs	r3, #16
    f36a:	421f      	tst	r7, r3
    f36c:	d006      	beq.n	f37c <_usart_interrupt_handler+0xe4>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_CTSIC;
    f36e:	752b      	strb	r3, [r5, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_CTSIC;
    f370:	762b      	strb	r3, [r5, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_CTS_INPUT_CHANGE)) {
    f372:	421e      	tst	r6, r3
    f374:	d002      	beq.n	f37c <_usart_interrupt_handler+0xe4>
			(*(module->callback[USART_CALLBACK_CTS_INPUT_CHANGE]))(module);
    f376:	0020      	movs	r0, r4
    f378:	69e3      	ldr	r3, [r4, #28]
    f37a:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_LIN_SLAVE
	if (interrupt_status & SERCOM_USART_INTFLAG_RXBRK) {
    f37c:	2320      	movs	r3, #32
    f37e:	421f      	tst	r7, r3
    f380:	d006      	beq.n	f390 <_usart_interrupt_handler+0xf8>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXBRK;
    f382:	752b      	strb	r3, [r5, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXBRK;
    f384:	762b      	strb	r3, [r5, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_BREAK_RECEIVED)) {
    f386:	0733      	lsls	r3, r6, #28
    f388:	d502      	bpl.n	f390 <_usart_interrupt_handler+0xf8>
			(*(module->callback[USART_CALLBACK_BREAK_RECEIVED]))(module);
    f38a:	0020      	movs	r0, r4
    f38c:	69a3      	ldr	r3, [r4, #24]
    f38e:	4798      	blx	r3
		}
	}
#endif

#ifdef FEATURE_USART_START_FRAME_DECTION
	if (interrupt_status & SERCOM_USART_INTFLAG_RXS) {
    f390:	2308      	movs	r3, #8
    f392:	421f      	tst	r7, r3
    f394:	d006      	beq.n	f3a4 <_usart_interrupt_handler+0x10c>
		/* Disable interrupts */
		usart_hw->INTENCLR.reg = SERCOM_USART_INTENCLR_RXS;
    f396:	752b      	strb	r3, [r5, #20]
		/* Clear interrupt flag */
		usart_hw->INTFLAG.reg = SERCOM_USART_INTFLAG_RXS;
    f398:	762b      	strb	r3, [r5, #24]

		/* Run callback if registered and enabled */
		if (callback_status & (1 << USART_CALLBACK_START_RECEIVED)) {
    f39a:	06b3      	lsls	r3, r6, #26
    f39c:	d502      	bpl.n	f3a4 <_usart_interrupt_handler+0x10c>
			(*(module->callback[USART_CALLBACK_START_RECEIVED]))(module);
    f39e:	6a23      	ldr	r3, [r4, #32]
    f3a0:	0020      	movs	r0, r4
    f3a2:	4798      	blx	r3
		}
	}
#endif
}
    f3a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    f3a6:	7851      	ldrb	r1, [r2, #1]
				(module->tx_buffer_ptr)++;
    f3a8:	3202      	adds	r2, #2
				data_to_send |= (*(module->tx_buffer_ptr) << 8);
    f3aa:	0209      	lsls	r1, r1, #8
    f3ac:	430b      	orrs	r3, r1
				(module->tx_buffer_ptr)++;
    f3ae:	62a2      	str	r2, [r4, #40]	; 0x28
    f3b0:	e793      	b.n	f2da <_usart_interrupt_handler+0x42>
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_DRE;
    f3b2:	752b      	strb	r3, [r5, #20]
    f3b4:	e79e      	b.n	f2f4 <_usart_interrupt_handler+0x5c>
				error_code &= ~SERCOM_USART_STATUS_CTS;
    f3b6:	2237      	movs	r2, #55	; 0x37
    f3b8:	e7b5      	b.n	f326 <_usart_interrupt_handler+0x8e>
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    f3ba:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
				*(module->rx_buffer_ptr) = received_data;
    f3bc:	6a61      	ldr	r1, [r4, #36]	; 0x24
				uint16_t received_data = (usart_hw->DATA.reg & SERCOM_USART_DATA_MASK);
    f3be:	05db      	lsls	r3, r3, #23
    f3c0:	0ddb      	lsrs	r3, r3, #23
				*(module->rx_buffer_ptr) = received_data;
    f3c2:	b2da      	uxtb	r2, r3
    f3c4:	700a      	strb	r2, [r1, #0]
				module->rx_buffer_ptr += 1;
    f3c6:	6a62      	ldr	r2, [r4, #36]	; 0x24
    f3c8:	1c51      	adds	r1, r2, #1
    f3ca:	6261      	str	r1, [r4, #36]	; 0x24
				if (module->character_size == USART_CHARACTER_SIZE_9BIT) {
    f3cc:	7961      	ldrb	r1, [r4, #5]
    f3ce:	2901      	cmp	r1, #1
    f3d0:	d104      	bne.n	f3dc <_usart_interrupt_handler+0x144>
					*(module->rx_buffer_ptr) = (received_data >> 8);
    f3d2:	0a1b      	lsrs	r3, r3, #8
    f3d4:	7053      	strb	r3, [r2, #1]
					module->rx_buffer_ptr += 1;
    f3d6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    f3d8:	3301      	adds	r3, #1
    f3da:	6263      	str	r3, [r4, #36]	; 0x24
				if(--(module->remaining_rx_buffer_length) == 0) {
    f3dc:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
    f3de:	3b01      	subs	r3, #1
    f3e0:	b29b      	uxth	r3, r3
    f3e2:	85a3      	strh	r3, [r4, #44]	; 0x2c
    f3e4:	2b00      	cmp	r3, #0
    f3e6:	d1bf      	bne.n	f368 <_usart_interrupt_handler+0xd0>
					usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    f3e8:	2204      	movs	r2, #4
    f3ea:	752a      	strb	r2, [r5, #20]
					module->rx_status = STATUS_OK;
    f3ec:	0022      	movs	r2, r4
    f3ee:	3232      	adds	r2, #50	; 0x32
    f3f0:	7013      	strb	r3, [r2, #0]
					if (callback_status
    f3f2:	07b3      	lsls	r3, r6, #30
    f3f4:	d5b8      	bpl.n	f368 <_usart_interrupt_handler+0xd0>
						(*(module->callback[USART_CALLBACK_BUFFER_RECEIVED]))(module);
    f3f6:	0020      	movs	r0, r4
    f3f8:	6923      	ldr	r3, [r4, #16]
    f3fa:	e7b4      	b.n	f366 <_usart_interrupt_handler+0xce>
			usart_hw->INTENCLR.reg = SERCOM_USART_INTFLAG_RXC;
    f3fc:	752b      	strb	r3, [r5, #20]
    f3fe:	e7b3      	b.n	f368 <_usart_interrupt_handler+0xd0>
    f400:	20002500 	.word	0x20002500

0000f404 <_tc_get_inst_index>:
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
		if (hw == tc_modules[i]) {
    f404:	4a08      	ldr	r2, [pc, #32]	; (f428 <_tc_get_inst_index+0x24>)
{
    f406:	0003      	movs	r3, r0
		if (hw == tc_modules[i]) {
    f408:	4290      	cmp	r0, r2
    f40a:	d009      	beq.n	f420 <_tc_get_inst_index+0x1c>
    f40c:	4a07      	ldr	r2, [pc, #28]	; (f42c <_tc_get_inst_index+0x28>)
    f40e:	4290      	cmp	r0, r2
    f410:	d008      	beq.n	f424 <_tc_get_inst_index+0x20>
    f412:	4a07      	ldr	r2, [pc, #28]	; (f430 <_tc_get_inst_index+0x2c>)
		}
	}

	/* Invalid data given. */
	Assert(false);
	return 0;
    f414:	2000      	movs	r0, #0
		if (hw == tc_modules[i]) {
    f416:	4293      	cmp	r3, r2
    f418:	d101      	bne.n	f41e <_tc_get_inst_index+0x1a>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    f41a:	3002      	adds	r0, #2
			return i;
    f41c:	b2c0      	uxtb	r0, r0
}
    f41e:	4770      	bx	lr
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
    f420:	2000      	movs	r0, #0
    f422:	e7fb      	b.n	f41c <_tc_get_inst_index+0x18>
    f424:	2001      	movs	r0, #1
    f426:	e7f9      	b.n	f41c <_tc_get_inst_index+0x18>
    f428:	42002c00 	.word	0x42002c00
    f42c:	42003000 	.word	0x42003000
    f430:	42003400 	.word	0x42003400

0000f434 <tc_init>:
 */
enum status_code tc_init(
		struct tc_module *const module_inst,
		Tc *const hw,
		const struct tc_config *const config)
{
    f434:	b5f0      	push	{r4, r5, r6, r7, lr}
    f436:	0006      	movs	r6, r0
    f438:	b087      	sub	sp, #28
	uint8_t ctrlbset_tmp = 0;
	/* Temporary variable to hold all updates to the CTRLC
	 * register before they are written to it */
	uint8_t ctrlc_tmp = 0;
	/* Temporary variable to hold TC instance number */
	uint8_t instance = _tc_get_inst_index(hw);
    f43a:	0008      	movs	r0, r1
{
    f43c:	0014      	movs	r4, r2
    f43e:	000d      	movs	r5, r1
	uint8_t instance = _tc_get_inst_index(hw);
    f440:	f7ff ffe0 	bl	f404 <_tc_get_inst_index>

	/* Array of GLCK ID for different TC instances */
	uint8_t inst_gclk_id[] = TC_INST_GCLK_ID;
    f444:	466a      	mov	r2, sp
    f446:	4b79      	ldr	r3, [pc, #484]	; (f62c <tc_init+0x1f8>)
	/* Register this instance for callbacks*/
	_tc_instances[instance] = module_inst;
#endif

	/* Associate the given device instance with the hardware module */
	module_inst->hw = hw;
    f448:	6035      	str	r5, [r6, #0]
	uint8_t inst_gclk_id[] = TC_INST_GCLK_ID;
    f44a:	8113      	strh	r3, [r2, #8]
    f44c:	231c      	movs	r3, #28
    f44e:	7293      	strb	r3, [r2, #10]
	uint16_t inst_pm_apbmask[] = TC_INST_PM_APBCMASK;
    f450:	4b77      	ldr	r3, [pc, #476]	; (f630 <tc_init+0x1fc>)
	uint8_t instance = _tc_get_inst_index(hw);
    f452:	0007      	movs	r7, r0
	uint16_t inst_pm_apbmask[] = TC_INST_PM_APBCMASK;
    f454:	9304      	str	r3, [sp, #16]
    f456:	2380      	movs	r3, #128	; 0x80
    f458:	019b      	lsls	r3, r3, #6
    f45a:	8293      	strh	r3, [r2, #20]
#else
	/* Check if odd numbered TC modules are being configured in 32-bit
	 * counter size. Only even numbered counters are allowed to be
	 * configured in 32-bit counter size.
	 */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    f45c:	78a3      	ldrb	r3, [r4, #2]
    f45e:	2b08      	cmp	r3, #8
    f460:	d103      	bne.n	f46a <tc_init+0x36>
			((instance + TC_INSTANCE_OFFSET) & 0x01)) {
		Assert(false);
		return STATUS_ERR_INVALID_ARG;
    f462:	2017      	movs	r0, #23
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT) &&
    f464:	07fa      	lsls	r2, r7, #31
    f466:	d400      	bmi.n	f46a <tc_init+0x36>
    f468:	e0ca      	b.n	f600 <tc_init+0x1cc>
	/* Make the counter size variable in the module_inst struct reflect
	 * the counter size in the module
	 */
	module_inst->counter_size = config->counter_size;

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    f46a:	2201      	movs	r2, #1
	module_inst->counter_size = config->counter_size;
    f46c:	7133      	strb	r3, [r6, #4]
	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    f46e:	882b      	ldrh	r3, [r5, #0]
		/* We are in the middle of a reset. Abort. */
		return STATUS_BUSY;
    f470:	2005      	movs	r0, #5
	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_SWRST) {
    f472:	4213      	tst	r3, r2
    f474:	d000      	beq.n	f478 <tc_init+0x44>
    f476:	e0c3      	b.n	f600 <tc_init+0x1cc>
	}

	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    f478:	7beb      	ldrb	r3, [r5, #15]
		/* Module is used as a slave */
		return STATUS_ERR_DENIED;
    f47a:	3017      	adds	r0, #23
	if (hw->COUNT8.STATUS.reg & TC_STATUS_SLAVE) {
    f47c:	06db      	lsls	r3, r3, #27
    f47e:	d500      	bpl.n	f482 <tc_init+0x4e>
    f480:	e0be      	b.n	f600 <tc_init+0x1cc>
	}

	if (hw->COUNT8.CTRLA.reg & TC_CTRLA_ENABLE) {
    f482:	2102      	movs	r1, #2
    f484:	882b      	ldrh	r3, [r5, #0]
    f486:	400b      	ands	r3, r1
    f488:	d000      	beq.n	f48c <tc_init+0x58>
    f48a:	e0b9      	b.n	f600 <tc_init+0x1cc>
		/* Module must be disabled before initialization. Abort. */
		return STATUS_ERR_DENIED;
	}

	/* Set up the TC PWM out pin for channel 0 */
	if (config->pwm_channel[0].enabled) {
    f48c:	7c21      	ldrb	r1, [r4, #16]
    f48e:	2900      	cmp	r1, #0
    f490:	d009      	beq.n	f4a6 <tc_init+0x72>
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    f492:	a903      	add	r1, sp, #12
	config->powersave    = false;
    f494:	70cb      	strb	r3, [r1, #3]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[0].pin_mux;
    f496:	69a3      	ldr	r3, [r4, #24]
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    f498:	708a      	strb	r2, [r1, #2]
    f49a:	700b      	strb	r3, [r1, #0]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
		system_pinmux_pin_set_config(
    f49c:	6963      	ldr	r3, [r4, #20]
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    f49e:	704a      	strb	r2, [r1, #1]
		system_pinmux_pin_set_config(
    f4a0:	b2d8      	uxtb	r0, r3
    f4a2:	f7fd fa35 	bl	c910 <system_pinmux_pin_set_config>
				config->pwm_channel[0].pin_out, &pin_config);
	}

	/* Set up the TC PWM out pin for channel 1 */
	if (config->pwm_channel[1].enabled) {
    f4a6:	7f23      	ldrb	r3, [r4, #28]
    f4a8:	2b00      	cmp	r3, #0
    f4aa:	d00b      	beq.n	f4c4 <tc_init+0x90>
    f4ac:	2301      	movs	r3, #1
	config->powersave    = false;
    f4ae:	2200      	movs	r2, #0
	config->input_pull   = SYSTEM_PINMUX_PIN_PULL_UP;
    f4b0:	a903      	add	r1, sp, #12
    f4b2:	708b      	strb	r3, [r1, #2]
		system_pinmux_get_config_defaults(&pin_config);
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
		pin_config.direction = SYSTEM_PINMUX_PIN_DIR_OUTPUT;
    f4b4:	704b      	strb	r3, [r1, #1]
		system_pinmux_pin_set_config(
    f4b6:	6a23      	ldr	r3, [r4, #32]
	config->powersave    = false;
    f4b8:	70ca      	strb	r2, [r1, #3]
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
    f4ba:	6a62      	ldr	r2, [r4, #36]	; 0x24
		system_pinmux_pin_set_config(
    f4bc:	b2d8      	uxtb	r0, r3
		pin_config.mux_position = config->pwm_channel[1].pin_mux;
    f4be:	700a      	strb	r2, [r1, #0]
		system_pinmux_pin_set_config(
    f4c0:	f7fd fa26 	bl	c910 <system_pinmux_pin_set_config>
				config->pwm_channel[1].pin_out, &pin_config);
	}

	/* Enable the user interface clock in the PM */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
			inst_pm_apbmask[instance]);
    f4c4:	007a      	lsls	r2, r7, #1
    f4c6:	4694      	mov	ip, r2
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    f4c8:	4668      	mov	r0, sp
    f4ca:	2210      	movs	r2, #16
    f4cc:	1880      	adds	r0, r0, r2
    f4ce:	4662      	mov	r2, ip
    f4d0:	4b58      	ldr	r3, [pc, #352]	; (f634 <tc_init+0x200>)
    f4d2:	5a82      	ldrh	r2, [r0, r2]
    f4d4:	6a19      	ldr	r1, [r3, #32]
    f4d6:	430a      	orrs	r2, r1
    f4d8:	621a      	str	r2, [r3, #32]

	/* Enable the slave counter if counter_size is 32-bit */
	if ((config->counter_size == TC_COUNTER_SIZE_32BIT))
    f4da:	78a2      	ldrb	r2, [r4, #2]
    f4dc:	2a08      	cmp	r2, #8
    f4de:	d10a      	bne.n	f4f6 <tc_init+0xc2>
	{
		/* Enable the user interface clock in the PM */
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
				inst_pm_apbmask[instance + 1]);
    f4e0:	1c79      	adds	r1, r7, #1
    f4e2:	004a      	lsls	r2, r1, #1
    f4e4:	4694      	mov	ip, r2
		system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBC,
    f4e6:	2110      	movs	r1, #16
    f4e8:	466a      	mov	r2, sp
    f4ea:	1852      	adds	r2, r2, r1
    f4ec:	4661      	mov	r1, ip
    f4ee:	6a18      	ldr	r0, [r3, #32]
    f4f0:	5a52      	ldrh	r2, [r2, r1]
    f4f2:	4302      	orrs	r2, r0
    f4f4:	621a      	str	r2, [r3, #32]
	}

	/* Setup clock for module */
	system_gclk_chan_get_config_defaults(&gclk_chan_config);
	gclk_chan_config.source_generator = config->clock_source;
    f4f6:	7823      	ldrb	r3, [r4, #0]
    f4f8:	a901      	add	r1, sp, #4
    f4fa:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(inst_gclk_id[instance], &gclk_chan_config);
    f4fc:	2208      	movs	r2, #8
    f4fe:	466b      	mov	r3, sp
    f500:	189b      	adds	r3, r3, r2
    f502:	5ddf      	ldrb	r7, [r3, r7]
    f504:	0038      	movs	r0, r7
    f506:	f7fc ff3f 	bl	c388 <system_gclk_chan_set_config>
	system_gclk_chan_enable(inst_gclk_id[instance]);
    f50a:	0038      	movs	r0, r7
    f50c:	f7fc ff00 	bl	c310 <system_gclk_chan_enable>

	/* Set ctrla register */
	ctrla_tmp =
			(uint32_t)config->counter_size |
			(uint32_t)config->wave_generation |
    f510:	79a3      	ldrb	r3, [r4, #6]
    f512:	78a2      	ldrb	r2, [r4, #2]
	ctrla_tmp =
    f514:	88a1      	ldrh	r1, [r4, #4]
			(uint32_t)config->wave_generation |
    f516:	431a      	orrs	r2, r3
	ctrla_tmp =
    f518:	8923      	ldrh	r3, [r4, #8]
    f51a:	430b      	orrs	r3, r1
    f51c:	431a      	orrs	r2, r3
			(uint32_t)config->reload_action |
			(uint32_t)config->clock_prescaler;

	if (config->run_in_standby) {
    f51e:	7863      	ldrb	r3, [r4, #1]
    f520:	2b00      	cmp	r3, #0
    f522:	d002      	beq.n	f52a <tc_init+0xf6>
		ctrla_tmp |= TC_CTRLA_RUNSTDBY;
    f524:	2380      	movs	r3, #128	; 0x80
    f526:	011b      	lsls	r3, r3, #4
    f528:	431a      	orrs	r2, r3
    f52a:	6833      	ldr	r3, [r6, #0]
	return (tc_module->STATUS.reg & TC_STATUS_SYNCBUSY);
    f52c:	7bd9      	ldrb	r1, [r3, #15]
	}

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    f52e:	b249      	sxtb	r1, r1
    f530:	2900      	cmp	r1, #0
    f532:	dbfb      	blt.n	f52c <tc_init+0xf8>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLA.reg = ctrla_tmp;
    f534:	802a      	strh	r2, [r5, #0]

	/* Set ctrlb register */
	if (config->oneshot) {
    f536:	7b62      	ldrb	r2, [r4, #13]
		ctrlbset_tmp = TC_CTRLBSET_ONESHOT;
    f538:	1e51      	subs	r1, r2, #1
    f53a:	418a      	sbcs	r2, r1
	}

	if (config->count_direction) {
    f53c:	7ba1      	ldrb	r1, [r4, #14]
		ctrlbset_tmp = TC_CTRLBSET_ONESHOT;
    f53e:	0092      	lsls	r2, r2, #2
	if (config->count_direction) {
    f540:	2900      	cmp	r1, #0
    f542:	d001      	beq.n	f548 <tc_init+0x114>
		ctrlbset_tmp |= TC_CTRLBSET_DIR;
    f544:	2101      	movs	r1, #1
    f546:	430a      	orrs	r2, r1
    f548:	7bd9      	ldrb	r1, [r3, #15]
	}

	/* Clear old ctrlb configuration */
	while (tc_is_syncing(module_inst)) {
    f54a:	b249      	sxtb	r1, r1
    f54c:	2900      	cmp	r1, #0
    f54e:	dbfb      	blt.n	f548 <tc_init+0x114>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLBCLR.reg = 0xFF;
    f550:	21ff      	movs	r1, #255	; 0xff
    f552:	7129      	strb	r1, [r5, #4]

	/* Check if we actually need to go into a wait state. */
	if (ctrlbset_tmp) {
    f554:	2a00      	cmp	r2, #0
    f556:	d004      	beq.n	f562 <tc_init+0x12e>
    f558:	7bd9      	ldrb	r1, [r3, #15]
		while (tc_is_syncing(module_inst)) {
    f55a:	b249      	sxtb	r1, r1
    f55c:	2900      	cmp	r1, #0
    f55e:	dbfb      	blt.n	f558 <tc_init+0x124>
			/* Wait for sync */
		}
		/* Write configuration to register */
		hw->COUNT8.CTRLBSET.reg = ctrlbset_tmp;
    f560:	716a      	strb	r2, [r5, #5]
	}

	/* Set ctrlc register*/
	ctrlc_tmp = config->waveform_invert_output;
	for (uint8_t i = 0; i < NUMBER_OF_COMPARE_CAPTURE_CHANNELS; i++) {
		if (config->enable_capture_on_channel[i] == true) {
    f562:	7ae2      	ldrb	r2, [r4, #11]
	ctrlc_tmp = config->waveform_invert_output;
    f564:	7aa1      	ldrb	r1, [r4, #10]
		if (config->enable_capture_on_channel[i] == true) {
    f566:	2a00      	cmp	r2, #0
    f568:	d001      	beq.n	f56e <tc_init+0x13a>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
    f56a:	2210      	movs	r2, #16
    f56c:	4311      	orrs	r1, r2
		if (config->enable_capture_on_channel[i] == true) {
    f56e:	7b22      	ldrb	r2, [r4, #12]
    f570:	2a00      	cmp	r2, #0
    f572:	d001      	beq.n	f578 <tc_init+0x144>
			ctrlc_tmp |= (TC_CTRLC_CPTEN(1) << i);
    f574:	2220      	movs	r2, #32
    f576:	4311      	orrs	r1, r2
    f578:	7bda      	ldrb	r2, [r3, #15]
		}
	}

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    f57a:	b252      	sxtb	r2, r2
    f57c:	2a00      	cmp	r2, #0
    f57e:	dbfb      	blt.n	f578 <tc_init+0x144>
		/* Wait for sync */
	}
	hw->COUNT8.CTRLC.reg = ctrlc_tmp;
    f580:	71a9      	strb	r1, [r5, #6]
    f582:	7bda      	ldrb	r2, [r3, #15]

	/* Write configuration to register */
	while (tc_is_syncing(module_inst)) {
    f584:	b252      	sxtb	r2, r2
    f586:	2a00      	cmp	r2, #0
    f588:	dbfb      	blt.n	f582 <tc_init+0x14e>
		/* Wait for sync */
	}

	/* Switch for TC counter size  */
	switch (module_inst->counter_size) {
    f58a:	7932      	ldrb	r2, [r6, #4]
    f58c:	2a04      	cmp	r2, #4
    f58e:	d017      	beq.n	f5c0 <tc_init+0x18c>
    f590:	2a08      	cmp	r2, #8
    f592:	d037      	beq.n	f604 <tc_init+0x1d0>

			return STATUS_OK;
	}

	Assert(false);
	return STATUS_ERR_INVALID_ARG;
    f594:	2017      	movs	r0, #23
	switch (module_inst->counter_size) {
    f596:	2a00      	cmp	r2, #0
    f598:	d132      	bne.n	f600 <tc_init+0x1cc>
    f59a:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f59c:	b252      	sxtb	r2, r2
    f59e:	2a00      	cmp	r2, #0
    f5a0:	dbfb      	blt.n	f59a <tc_init+0x166>
				= config->counter_16_bit.value;
    f5a2:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    f5a4:	822a      	strh	r2, [r5, #16]
    f5a6:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f5a8:	b252      	sxtb	r2, r2
    f5aa:	2a00      	cmp	r2, #0
    f5ac:	dbfb      	blt.n	f5a6 <tc_init+0x172>
					config->counter_16_bit.compare_capture_channel[0];
    f5ae:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
			hw->COUNT16.CC[0].reg =
    f5b0:	832a      	strh	r2, [r5, #24]
    f5b2:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f5b4:	b252      	sxtb	r2, r2
    f5b6:	2a00      	cmp	r2, #0
    f5b8:	dbfb      	blt.n	f5b2 <tc_init+0x17e>
					config->counter_16_bit.compare_capture_channel[1];
    f5ba:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
			hw->COUNT16.CC[1].reg =
    f5bc:	836b      	strh	r3, [r5, #26]
    f5be:	e01e      	b.n	f5fe <tc_init+0x1ca>
    f5c0:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f5c2:	b252      	sxtb	r2, r2
    f5c4:	2a00      	cmp	r2, #0
    f5c6:	dbfb      	blt.n	f5c0 <tc_init+0x18c>
					config->counter_8_bit.value;
    f5c8:	0022      	movs	r2, r4
    f5ca:	3228      	adds	r2, #40	; 0x28
    f5cc:	7812      	ldrb	r2, [r2, #0]
			hw->COUNT8.COUNT.reg =
    f5ce:	742a      	strb	r2, [r5, #16]
    f5d0:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f5d2:	b252      	sxtb	r2, r2
    f5d4:	2a00      	cmp	r2, #0
    f5d6:	dbfb      	blt.n	f5d0 <tc_init+0x19c>
					config->counter_8_bit.period;
    f5d8:	0022      	movs	r2, r4
    f5da:	3229      	adds	r2, #41	; 0x29
    f5dc:	7812      	ldrb	r2, [r2, #0]
			hw->COUNT8.PER.reg =
    f5de:	752a      	strb	r2, [r5, #20]
    f5e0:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f5e2:	b252      	sxtb	r2, r2
    f5e4:	2a00      	cmp	r2, #0
    f5e6:	dbfb      	blt.n	f5e0 <tc_init+0x1ac>
					config->counter_8_bit.compare_capture_channel[0];
    f5e8:	0022      	movs	r2, r4
    f5ea:	322a      	adds	r2, #42	; 0x2a
    f5ec:	7812      	ldrb	r2, [r2, #0]
			hw->COUNT8.CC[0].reg =
    f5ee:	762a      	strb	r2, [r5, #24]
    f5f0:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f5f2:	b252      	sxtb	r2, r2
    f5f4:	2a00      	cmp	r2, #0
    f5f6:	dbfb      	blt.n	f5f0 <tc_init+0x1bc>
					config->counter_8_bit.compare_capture_channel[1];
    f5f8:	342b      	adds	r4, #43	; 0x2b
    f5fa:	7823      	ldrb	r3, [r4, #0]
			hw->COUNT8.CC[1].reg =
    f5fc:	766b      	strb	r3, [r5, #25]
			return STATUS_OK;
    f5fe:	2000      	movs	r0, #0
}
    f600:	b007      	add	sp, #28
    f602:	bdf0      	pop	{r4, r5, r6, r7, pc}
    f604:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f606:	b252      	sxtb	r2, r2
    f608:	2a00      	cmp	r2, #0
    f60a:	dbfb      	blt.n	f604 <tc_init+0x1d0>
				= config->counter_32_bit.value;
    f60c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    f60e:	612a      	str	r2, [r5, #16]
    f610:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f612:	b252      	sxtb	r2, r2
    f614:	2a00      	cmp	r2, #0
    f616:	dbfb      	blt.n	f610 <tc_init+0x1dc>
			hw->COUNT32.CC[0].reg =
    f618:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    f61a:	61aa      	str	r2, [r5, #24]
    f61c:	7bda      	ldrb	r2, [r3, #15]
			while (tc_is_syncing(module_inst)) {
    f61e:	b252      	sxtb	r2, r2
    f620:	2a00      	cmp	r2, #0
    f622:	dbfb      	blt.n	f61c <tc_init+0x1e8>
					config->counter_32_bit.compare_capture_channel[1];
    f624:	6b23      	ldr	r3, [r4, #48]	; 0x30
			hw->COUNT32.CC[1].reg =
    f626:	61eb      	str	r3, [r5, #28]
    f628:	e7e9      	b.n	f5fe <tc_init+0x1ca>
    f62a:	46c0      	nop			; (mov r8, r8)
    f62c:	00001c1b 	.word	0x00001c1b
    f630:	10000800 	.word	0x10000800
    f634:	40000400 	.word	0x40000400

0000f638 <tc_get_count_value>:
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	Tc *const tc_module = module_inst->hw;
    f638:	6803      	ldr	r3, [r0, #0]
    f63a:	7bda      	ldrb	r2, [r3, #15]

	while (tc_is_syncing(module_inst)) {
    f63c:	b252      	sxtb	r2, r2
    f63e:	2a00      	cmp	r2, #0
    f640:	dbfb      	blt.n	f63a <tc_get_count_value+0x2>
		/* Wait for sync */
	}

	/* Read from based on the TC counter size */
	switch (module_inst->counter_size) {
    f642:	7902      	ldrb	r2, [r0, #4]
    f644:	2a04      	cmp	r2, #4
    f646:	d007      	beq.n	f658 <tc_get_count_value+0x20>
    f648:	2a08      	cmp	r2, #8
    f64a:	d008      	beq.n	f65e <tc_get_count_value+0x26>
		case TC_COUNTER_SIZE_32BIT:
			return tc_module->COUNT32.COUNT.reg;
	}

	Assert(false);
	return 0;
    f64c:	2000      	movs	r0, #0
	switch (module_inst->counter_size) {
    f64e:	2a00      	cmp	r2, #0
    f650:	d104      	bne.n	f65c <tc_get_count_value+0x24>
			return (uint32_t)tc_module->COUNT16.COUNT.reg;
    f652:	8a18      	ldrh	r0, [r3, #16]
    f654:	b280      	uxth	r0, r0
    f656:	e001      	b.n	f65c <tc_get_count_value+0x24>
			return (uint32_t)tc_module->COUNT8.COUNT.reg;
    f658:	7c18      	ldrb	r0, [r3, #16]
    f65a:	b2c0      	uxtb	r0, r0
}
    f65c:	4770      	bx	lr
			return tc_module->COUNT32.COUNT.reg;
    f65e:	6918      	ldr	r0, [r3, #16]
    f660:	e7fc      	b.n	f65c <tc_get_count_value+0x24>

0000f662 <tc_set_compare_value>:
 */
enum status_code tc_set_compare_value(
		const struct tc_module *const module_inst,
		const enum tc_compare_capture_channel channel_index,
		const uint32_t compare)
{
    f662:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	Assert(module_inst);
	Assert(module_inst->hw);

	/* Get a pointer to the module's hardware instance */
	Tc *const tc_module = module_inst->hw;
    f664:	6804      	ldr	r4, [r0, #0]
    f666:	7be3      	ldrb	r3, [r4, #15]

	while (tc_is_syncing(module_inst)) {
    f668:	b25b      	sxtb	r3, r3
    f66a:	2b00      	cmp	r3, #0
    f66c:	dbfb      	blt.n	f666 <tc_set_compare_value+0x4>
		/* Wait for sync */
	}

	/* Read out based on the TC counter size */
	switch (module_inst->counter_size) {
    f66e:	7903      	ldrb	r3, [r0, #4]
    f670:	2b04      	cmp	r3, #4
    f672:	d00c      	beq.n	f68e <tc_set_compare_value+0x2c>
    f674:	2b08      	cmp	r3, #8
    f676:	d012      	beq.n	f69e <tc_set_compare_value+0x3c>
						(uint32_t)compare;
				return STATUS_OK;
			}
	}

	return STATUS_ERR_INVALID_ARG;
    f678:	2017      	movs	r0, #23
	switch (module_inst->counter_size) {
    f67a:	2b00      	cmp	r3, #0
    f67c:	d10e      	bne.n	f69c <tc_set_compare_value+0x3a>
	return STATUS_ERR_INVALID_ARG;
    f67e:	2017      	movs	r0, #23
			if (channel_index <
    f680:	2901      	cmp	r1, #1
    f682:	d80b      	bhi.n	f69c <tc_set_compare_value+0x3a>
				tc_module->COUNT16.CC[channel_index].reg =
    f684:	310c      	adds	r1, #12
						(uint16_t)compare;
    f686:	b292      	uxth	r2, r2
				tc_module->COUNT16.CC[channel_index].reg =
    f688:	0049      	lsls	r1, r1, #1
    f68a:	530a      	strh	r2, [r1, r4]
    f68c:	e005      	b.n	f69a <tc_set_compare_value+0x38>
	return STATUS_ERR_INVALID_ARG;
    f68e:	2017      	movs	r0, #23
			if (channel_index <
    f690:	2901      	cmp	r1, #1
    f692:	d803      	bhi.n	f69c <tc_set_compare_value+0x3a>
						(uint8_t)compare;
    f694:	b2d2      	uxtb	r2, r2
				tc_module->COUNT8.CC[channel_index].reg  =
    f696:	1861      	adds	r1, r4, r1
    f698:	760a      	strb	r2, [r1, #24]
				return STATUS_OK;
    f69a:	2000      	movs	r0, #0
}
    f69c:	bd10      	pop	{r4, pc}
	return STATUS_ERR_INVALID_ARG;
    f69e:	2017      	movs	r0, #23
			if (channel_index <
    f6a0:	2901      	cmp	r1, #1
    f6a2:	d8fb      	bhi.n	f69c <tc_set_compare_value+0x3a>
				tc_module->COUNT32.CC[channel_index].reg =
    f6a4:	3106      	adds	r1, #6
    f6a6:	0089      	lsls	r1, r1, #2
    f6a8:	510a      	str	r2, [r1, r4]
    f6aa:	e7f6      	b.n	f69a <tc_set_compare_value+0x38>

0000f6ac <wdt_set_config>:
	return STATUS_OK;
}
#else
enum status_code wdt_set_config(
		const struct wdt_conf *const config)
{
    f6ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
    f6ae:	0005      	movs	r5, r0
			PM->APBAMASK.reg |= mask;
    f6b0:	2010      	movs	r0, #16
    f6b2:	4a2f      	ldr	r2, [pc, #188]	; (f770 <wdt_set_config+0xc4>)
	Wdt *const WDT_module = WDT;

#if (SAML21) || (SAML22) || (SAMC20) || (SAMC21)
	return (WDT_module->CTRLA.reg & WDT_CTRLA_ALWAYSON);
#else
	return (WDT_module->CTRL.reg & WDT_CTRL_ALWAYSON);
    f6b4:	4c2f      	ldr	r4, [pc, #188]	; (f774 <wdt_set_config+0xc8>)
    f6b6:	6993      	ldr	r3, [r2, #24]
    f6b8:	4303      	orrs	r3, r0
    f6ba:	6193      	str	r3, [r2, #24]
    f6bc:	7823      	ldrb	r3, [r4, #0]

	/* Turn on the digital interface clock */
	system_apb_clock_set_mask(SYSTEM_CLOCK_APB_APBA, PM_APBAMASK_WDT);

	/* Check of the Watchdog has been locked to be always on, if so, abort */
	if (wdt_is_locked()) {
    f6be:	b25b      	sxtb	r3, r3
    f6c0:	2b00      	cmp	r3, #0
    f6c2:	db15      	blt.n	f6f0 <wdt_set_config+0x44>
		return STATUS_ERR_IO;
	}

	/* Check for an invalid timeout period, abort if found */
	if (config->timeout_period == WDT_PERIOD_NONE) {
    f6c4:	78eb      	ldrb	r3, [r5, #3]
		return STATUS_ERR_INVALID_ARG;
    f6c6:	3007      	adds	r0, #7
	if (config->timeout_period == WDT_PERIOD_NONE) {
    f6c8:	2b00      	cmp	r3, #0
    f6ca:	d011      	beq.n	f6f0 <wdt_set_config+0x44>
	}

	/* Make sure the Window and Early Warning periods are not more than the
	 * reset period, abort if either is invalid */
	if ((config->timeout_period < config->window_period) ||
    f6cc:	792a      	ldrb	r2, [r5, #4]
    f6ce:	429a      	cmp	r2, r3
    f6d0:	d80e      	bhi.n	f6f0 <wdt_set_config+0x44>
    f6d2:	796a      	ldrb	r2, [r5, #5]
    f6d4:	429a      	cmp	r2, r3
    f6d6:	d80b      	bhi.n	f6f0 <wdt_set_config+0x44>
			(config->timeout_period < config->early_warning_period)) {
		return STATUS_ERR_INVALID_ARG;
	}

	/* Disable the Watchdog module */
	WDT_module->CTRL.reg &= ~WDT_CTRL_ENABLE;
    f6d8:	2202      	movs	r2, #2
    f6da:	7823      	ldrb	r3, [r4, #0]
    f6dc:	4393      	bics	r3, r2
    f6de:	7023      	strb	r3, [r4, #0]
	if (WDT_module->STATUS.reg & WDT_STATUS_SYNCBUSY) {
    f6e0:	79e3      	ldrb	r3, [r4, #7]
    f6e2:	b25b      	sxtb	r3, r3
    f6e4:	2b00      	cmp	r3, #0
    f6e6:	dbfb      	blt.n	f6e0 <wdt_set_config+0x34>

	while (wdt_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}

	if(config->enable == false) {
    f6e8:	786b      	ldrb	r3, [r5, #1]
    f6ea:	2b00      	cmp	r3, #0
    f6ec:	d101      	bne.n	f6f2 <wdt_set_config+0x46>
		return STATUS_OK;
    f6ee:	2000      	movs	r0, #0
	while (wdt_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}

	return STATUS_OK;
}
    f6f0:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	gclk_chan_conf.source_generator = config->clock_source;
    f6f2:	78ab      	ldrb	r3, [r5, #2]
    f6f4:	a901      	add	r1, sp, #4
	system_gclk_chan_set_config(WDT_GCLK_ID, &gclk_chan_conf);
    f6f6:	2003      	movs	r0, #3
	gclk_chan_conf.source_generator = config->clock_source;
    f6f8:	700b      	strb	r3, [r1, #0]
	system_gclk_chan_set_config(WDT_GCLK_ID, &gclk_chan_conf);
    f6fa:	f7fc fe45 	bl	c388 <system_gclk_chan_set_config>
	system_gclk_chan_enable(WDT_GCLK_ID);
    f6fe:	2003      	movs	r0, #3
    f700:	f7fc fe06 	bl	c310 <system_gclk_chan_enable>
	if (config->always_on) {
    f704:	782b      	ldrb	r3, [r5, #0]
    f706:	2b00      	cmp	r3, #0
    f708:	d002      	beq.n	f710 <wdt_set_config+0x64>
		system_gclk_chan_lock(WDT_GCLK_ID);
    f70a:	2003      	movs	r0, #3
    f70c:	f7fc fe48 	bl	c3a0 <system_gclk_chan_lock>
	new_config |= (config->timeout_period - 1) << WDT_CONFIG_PER_Pos;
    f710:	78eb      	ldrb	r3, [r5, #3]
	if (config->window_period != WDT_PERIOD_NONE) {
    f712:	792a      	ldrb	r2, [r5, #4]
	new_config |= (config->timeout_period - 1) << WDT_CONFIG_PER_Pos;
    f714:	3b01      	subs	r3, #1
    f716:	2104      	movs	r1, #4
	if (config->window_period != WDT_PERIOD_NONE) {
    f718:	2a00      	cmp	r2, #0
    f71a:	d021      	beq.n	f760 <wdt_set_config+0xb4>
		WDT_module->CTRL.reg |= WDT_CTRL_WEN;
    f71c:	7820      	ldrb	r0, [r4, #0]
		new_config |= (config->window_period - 1) << WDT_CONFIG_WINDOW_Pos;
    f71e:	3a01      	subs	r2, #1
		WDT_module->CTRL.reg |= WDT_CTRL_WEN;
    f720:	4301      	orrs	r1, r0
		new_config |= (config->window_period - 1) << WDT_CONFIG_WINDOW_Pos;
    f722:	0112      	lsls	r2, r2, #4
		WDT_module->CTRL.reg |= WDT_CTRL_WEN;
    f724:	7021      	strb	r1, [r4, #0]
		new_config |= (config->window_period - 1) << WDT_CONFIG_WINDOW_Pos;
    f726:	4313      	orrs	r3, r2
    f728:	79e2      	ldrb	r2, [r4, #7]
    f72a:	b252      	sxtb	r2, r2
    f72c:	2a00      	cmp	r2, #0
    f72e:	dbfb      	blt.n	f728 <wdt_set_config+0x7c>
	WDT_module->CONFIG.reg = new_config;
    f730:	b2db      	uxtb	r3, r3
    f732:	7063      	strb	r3, [r4, #1]
	if (config->early_warning_period != WDT_PERIOD_NONE) {
    f734:	796b      	ldrb	r3, [r5, #5]
    f736:	2b00      	cmp	r3, #0
    f738:	d006      	beq.n	f748 <wdt_set_config+0x9c>
    f73a:	79e2      	ldrb	r2, [r4, #7]
    f73c:	b252      	sxtb	r2, r2
    f73e:	2a00      	cmp	r2, #0
    f740:	dbfb      	blt.n	f73a <wdt_set_config+0x8e>
			= (config->early_warning_period - 1) << WDT_EWCTRL_EWOFFSET_Pos;
    f742:	3b01      	subs	r3, #1
    f744:	b2db      	uxtb	r3, r3
    f746:	70a3      	strb	r3, [r4, #2]
	if (config->always_on) {
    f748:	782b      	ldrb	r3, [r5, #0]
    f74a:	2b00      	cmp	r3, #0
    f74c:	d00c      	beq.n	f768 <wdt_set_config+0xbc>
		WDT_module->CTRL.reg |= WDT_CTRL_ALWAYSON;
    f74e:	2280      	movs	r2, #128	; 0x80
    f750:	7823      	ldrb	r3, [r4, #0]
		WDT_module->CTRL.reg |= WDT_CTRL_ENABLE;
    f752:	4313      	orrs	r3, r2
    f754:	7023      	strb	r3, [r4, #0]
    f756:	79e3      	ldrb	r3, [r4, #7]
    f758:	b25b      	sxtb	r3, r3
    f75a:	2b00      	cmp	r3, #0
    f75c:	dac7      	bge.n	f6ee <wdt_set_config+0x42>
    f75e:	e7fa      	b.n	f756 <wdt_set_config+0xaa>
		WDT_module->CTRL.reg &= ~WDT_CTRL_WEN;
    f760:	7822      	ldrb	r2, [r4, #0]
    f762:	438a      	bics	r2, r1
    f764:	7022      	strb	r2, [r4, #0]
    f766:	e7df      	b.n	f728 <wdt_set_config+0x7c>
		WDT_module->CTRL.reg |= WDT_CTRL_ENABLE;
    f768:	7822      	ldrb	r2, [r4, #0]
    f76a:	2302      	movs	r3, #2
    f76c:	e7f1      	b.n	f752 <wdt_set_config+0xa6>
    f76e:	46c0      	nop			; (mov r8, r8)
    f770:	40000400 	.word	0x40000400
    f774:	40001000 	.word	0x40001000

0000f778 <wdt_reset_count>:
void wdt_reset_count(void)
{
	Wdt *const WDT_module = WDT;

	/* Disable the Watchdog module */
	WDT_module->CLEAR.reg = WDT_CLEAR_CLEAR_KEY;
    f778:	22a5      	movs	r2, #165	; 0xa5
    f77a:	4b03      	ldr	r3, [pc, #12]	; (f788 <wdt_reset_count+0x10>)
    f77c:	721a      	strb	r2, [r3, #8]
    f77e:	79da      	ldrb	r2, [r3, #7]
    f780:	b252      	sxtb	r2, r2
    f782:	2a00      	cmp	r2, #0
    f784:	dbfb      	blt.n	f77e <wdt_reset_count+0x6>

	while (wdt_is_syncing()) {
		/* Wait for all hardware modules to complete synchronization */
	}
}
    f786:	4770      	bx	lr
    f788:	40001000 	.word	0x40001000

0000f78c <_sercom_get_sync_baud_val>:
 */
enum status_code _sercom_get_sync_baud_val(
		const uint32_t baudrate,
		const uint32_t external_clock,
		uint16_t *const baudvalue)
{
    f78c:	b510      	push	{r4, lr}
	uint16_t baud_calculated = 0;
	uint32_t clock_value = external_clock;


	/* Check if baudrate is outside of valid range */
	if (baudrate > (external_clock / 2)) {
    f78e:	0849      	lsrs	r1, r1, #1
{
    f790:	0004      	movs	r4, r0
	uint16_t baud_calculated = 0;
    f792:	2300      	movs	r3, #0
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f794:	2040      	movs	r0, #64	; 0x40
	if (baudrate > (external_clock / 2)) {
    f796:	42a1      	cmp	r1, r4
    f798:	d201      	bcs.n	f79e <_sercom_get_sync_baud_val+0x12>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
	} else {
		*baudvalue = baud_calculated;
		return STATUS_OK;
	}
}
    f79a:	bd10      	pop	{r4, pc}
		baud_calculated++;
    f79c:	0003      	movs	r3, r0
    f79e:	1c58      	adds	r0, r3, #1
		clock_value = clock_value - baudrate;
    f7a0:	1b09      	subs	r1, r1, r4
		baud_calculated++;
    f7a2:	b280      	uxth	r0, r0
	while (clock_value >= baudrate) {
    f7a4:	428c      	cmp	r4, r1
    f7a6:	d9f9      	bls.n	f79c <_sercom_get_sync_baud_val+0x10>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f7a8:	2040      	movs	r0, #64	; 0x40
	if (baud_calculated > 0xFF) {
    f7aa:	2bff      	cmp	r3, #255	; 0xff
    f7ac:	d8f5      	bhi.n	f79a <_sercom_get_sync_baud_val+0xe>
		*baudvalue = baud_calculated;
    f7ae:	8013      	strh	r3, [r2, #0]
		return STATUS_OK;
    f7b0:	2000      	movs	r0, #0
    f7b2:	e7f2      	b.n	f79a <_sercom_get_sync_baud_val+0xe>

0000f7b4 <_sercom_get_async_baud_val>:
		const uint32_t baudrate,
		const uint32_t peripheral_clock,
		uint16_t *const baudval,
		enum sercom_asynchronous_operation_mode mode,
		enum sercom_asynchronous_sample_num sample_num)
{
    f7b4:	b5f0      	push	{r4, r5, r6, r7, lr}
    f7b6:	b08b      	sub	sp, #44	; 0x2c
    f7b8:	9206      	str	r2, [sp, #24]
	uint8_t baud_fp;
	uint32_t baud_int = 0;
	uint64_t temp1, temp2;

	/* Check if the baudrate is outside of valid range */
	if ((baudrate * sample_num) > peripheral_clock) {
    f7ba:	0002      	movs	r2, r0
{
    f7bc:	001d      	movs	r5, r3
    f7be:	ab10      	add	r3, sp, #64	; 0x40
    f7c0:	000e      	movs	r6, r1
    f7c2:	7819      	ldrb	r1, [r3, #0]
		/* Return with error code */
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f7c4:	2340      	movs	r3, #64	; 0x40
	if ((baudrate * sample_num) > peripheral_clock) {
    f7c6:	434a      	muls	r2, r1
    f7c8:	42b2      	cmp	r2, r6
    f7ca:	d900      	bls.n	f7ce <_sercom_get_async_baud_val+0x1a>
    f7cc:	e08b      	b.n	f8e6 <_sercom_get_async_baud_val+0x132>
	}

	if(mode == SERCOM_ASYNC_OPERATION_MODE_ARITHMETIC) {
    f7ce:	2d00      	cmp	r5, #0
    f7d0:	d142      	bne.n	f858 <_sercom_get_async_baud_val+0xa4>
		/* Calculate the BAUD value */
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
		ratio = long_division(temp1, peripheral_clock);
    f7d2:	2400      	movs	r4, #0
	uint64_t q = 0, r = 0, bit_shift;
    f7d4:	0027      	movs	r7, r4
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    f7d6:	002b      	movs	r3, r5
    f7d8:	0002      	movs	r2, r0
    f7da:	0008      	movs	r0, r1
    f7dc:	0029      	movs	r1, r5
    f7de:	f000 fee7 	bl	105b0 <__aeabi_lmul>
		ratio = long_division(temp1, peripheral_clock);
    f7e2:	2300      	movs	r3, #0
    f7e4:	9501      	str	r5, [sp, #4]
	uint64_t q = 0, r = 0, bit_shift;
    f7e6:	003d      	movs	r5, r7
		ratio = long_division(temp1, peripheral_clock);
    f7e8:	9600      	str	r6, [sp, #0]
	uint64_t q = 0, r = 0, bit_shift;
    f7ea:	001c      	movs	r4, r3
    f7ec:	001e      	movs	r6, r3
	for (i = 63; i >= 0; i--) {
    f7ee:	333f      	adds	r3, #63	; 0x3f
		temp1 = ((sample_num * (uint64_t)baudrate) << SHIFT);
    f7f0:	9007      	str	r0, [sp, #28]
	for (i = 63; i >= 0; i--) {
    f7f2:	9303      	str	r3, [sp, #12]
		bit_shift = (uint64_t)1 << i;
    f7f4:	9a03      	ldr	r2, [sp, #12]
    f7f6:	2001      	movs	r0, #1
    f7f8:	2100      	movs	r1, #0
    f7fa:	f000 fead 	bl	10558 <__aeabi_llsl>
		r = r << 1;
    f7fe:	0022      	movs	r2, r4
    f800:	002b      	movs	r3, r5
    f802:	1912      	adds	r2, r2, r4
    f804:	416b      	adcs	r3, r5
    f806:	9204      	str	r2, [sp, #16]
    f808:	9305      	str	r3, [sp, #20]
    f80a:	001d      	movs	r5, r3
		if (n & bit_shift) {
    f80c:	9b07      	ldr	r3, [sp, #28]
		r = r << 1;
    f80e:	0014      	movs	r4, r2
		if (n & bit_shift) {
    f810:	420b      	tst	r3, r1
    f812:	d003      	beq.n	f81c <_sercom_get_async_baud_val+0x68>
			r |= 0x01;
    f814:	2201      	movs	r2, #1
    f816:	4322      	orrs	r2, r4
    f818:	0014      	movs	r4, r2
    f81a:	9d05      	ldr	r5, [sp, #20]
		if (r >= d) {
    f81c:	9b01      	ldr	r3, [sp, #4]
    f81e:	42ab      	cmp	r3, r5
    f820:	d80b      	bhi.n	f83a <_sercom_get_async_baud_val+0x86>
    f822:	d102      	bne.n	f82a <_sercom_get_async_baud_val+0x76>
    f824:	9b00      	ldr	r3, [sp, #0]
    f826:	42a3      	cmp	r3, r4
    f828:	d807      	bhi.n	f83a <_sercom_get_async_baud_val+0x86>
			r = r - d;
    f82a:	9a00      	ldr	r2, [sp, #0]
    f82c:	9b01      	ldr	r3, [sp, #4]
			q |= bit_shift;
    f82e:	4330      	orrs	r0, r6
    f830:	4339      	orrs	r1, r7
			r = r - d;
    f832:	1aa4      	subs	r4, r4, r2
    f834:	419d      	sbcs	r5, r3
			q |= bit_shift;
    f836:	0006      	movs	r6, r0
    f838:	000f      	movs	r7, r1
	for (i = 63; i >= 0; i--) {
    f83a:	9b03      	ldr	r3, [sp, #12]
    f83c:	1e5a      	subs	r2, r3, #1
    f83e:	9203      	str	r2, [sp, #12]
    f840:	d2d8      	bcs.n	f7f4 <_sercom_get_async_baud_val+0x40>
		scale = ((uint64_t)1 << SHIFT) - ratio;
    f842:	2200      	movs	r2, #0
    f844:	2301      	movs	r3, #1
    f846:	1b92      	subs	r2, r2, r6
    f848:	41bb      	sbcs	r3, r7
		baud_calculated = (65536 * scale) >> SHIFT;
    f84a:	0c14      	lsrs	r4, r2, #16
    f84c:	041b      	lsls	r3, r3, #16
			}
		}
		if(baud_fp == BAUD_FP_MAX) {
			return STATUS_ERR_BAUDRATE_UNAVAILABLE;
		}
		baud_calculated = baud_int | (baud_fp << 13);
    f84e:	431c      	orrs	r4, r3
	}

	*baudval = baud_calculated;
    f850:	9b06      	ldr	r3, [sp, #24]
    f852:	801c      	strh	r4, [r3, #0]
	return STATUS_OK;
    f854:	2300      	movs	r3, #0
    f856:	e046      	b.n	f8e6 <_sercom_get_async_baud_val+0x132>
	uint64_t baud_calculated = 0;
    f858:	2400      	movs	r4, #0
	} else if(mode == SERCOM_ASYNC_OPERATION_MODE_FRACTIONAL) {
    f85a:	2d01      	cmp	r5, #1
    f85c:	d1f8      	bne.n	f850 <_sercom_get_async_baud_val+0x9c>
			temp1 = BAUD_FP_MAX * (uint64_t)peripheral_clock;
    f85e:	0f73      	lsrs	r3, r6, #29
    f860:	9307      	str	r3, [sp, #28]
    f862:	00f3      	lsls	r3, r6, #3
    f864:	9308      	str	r3, [sp, #32]
			temp2 = ((uint64_t)baudrate * sample_num);
    f866:	000a      	movs	r2, r1
    f868:	0023      	movs	r3, r4
    f86a:	0021      	movs	r1, r4
    f86c:	f000 fea0 	bl	105b0 <__aeabi_lmul>
    f870:	9000      	str	r0, [sp, #0]
    f872:	9101      	str	r1, [sp, #4]
			r |= 0x01;
    f874:	9509      	str	r5, [sp, #36]	; 0x24
	uint64_t q = 0, r = 0, bit_shift;
    f876:	2300      	movs	r3, #0
    f878:	2600      	movs	r6, #0
    f87a:	2700      	movs	r7, #0
	for (i = 63; i >= 0; i--) {
    f87c:	253f      	movs	r5, #63	; 0x3f
	uint64_t q = 0, r = 0, bit_shift;
    f87e:	9303      	str	r3, [sp, #12]
		bit_shift = (uint64_t)1 << i;
    f880:	002a      	movs	r2, r5
    f882:	2001      	movs	r0, #1
    f884:	2100      	movs	r1, #0
    f886:	f000 fe67 	bl	10558 <__aeabi_llsl>
		r = r << 1;
    f88a:	0032      	movs	r2, r6
    f88c:	003b      	movs	r3, r7
		bit_shift = (uint64_t)1 << i;
    f88e:	468c      	mov	ip, r1
		r = r << 1;
    f890:	1992      	adds	r2, r2, r6
    f892:	417b      	adcs	r3, r7
    f894:	9204      	str	r2, [sp, #16]
    f896:	9305      	str	r3, [sp, #20]
    f898:	001f      	movs	r7, r3
		if (n & bit_shift) {
    f89a:	4663      	mov	r3, ip
		r = r << 1;
    f89c:	0016      	movs	r6, r2
		if (n & bit_shift) {
    f89e:	9908      	ldr	r1, [sp, #32]
    f8a0:	9a07      	ldr	r2, [sp, #28]
    f8a2:	4001      	ands	r1, r0
    f8a4:	4013      	ands	r3, r2
    f8a6:	4319      	orrs	r1, r3
    f8a8:	d003      	beq.n	f8b2 <_sercom_get_async_baud_val+0xfe>
			r |= 0x01;
    f8aa:	9a09      	ldr	r2, [sp, #36]	; 0x24
    f8ac:	9f05      	ldr	r7, [sp, #20]
    f8ae:	4332      	orrs	r2, r6
    f8b0:	0016      	movs	r6, r2
		if (r >= d) {
    f8b2:	9b01      	ldr	r3, [sp, #4]
    f8b4:	42bb      	cmp	r3, r7
    f8b6:	d80a      	bhi.n	f8ce <_sercom_get_async_baud_val+0x11a>
    f8b8:	d102      	bne.n	f8c0 <_sercom_get_async_baud_val+0x10c>
    f8ba:	9b00      	ldr	r3, [sp, #0]
    f8bc:	42b3      	cmp	r3, r6
    f8be:	d806      	bhi.n	f8ce <_sercom_get_async_baud_val+0x11a>
			r = r - d;
    f8c0:	9a00      	ldr	r2, [sp, #0]
    f8c2:	9b01      	ldr	r3, [sp, #4]
    f8c4:	1ab6      	subs	r6, r6, r2
    f8c6:	419f      	sbcs	r7, r3
			q |= bit_shift;
    f8c8:	9b03      	ldr	r3, [sp, #12]
    f8ca:	4303      	orrs	r3, r0
    f8cc:	9303      	str	r3, [sp, #12]
	for (i = 63; i >= 0; i--) {
    f8ce:	3d01      	subs	r5, #1
    f8d0:	d2d6      	bcs.n	f880 <_sercom_get_async_baud_val+0xcc>
			baud_int -= baud_fp;
    f8d2:	9b03      	ldr	r3, [sp, #12]
			if(baud_int < BAUD_INT_MAX) {
    f8d4:	4a06      	ldr	r2, [pc, #24]	; (f8f0 <_sercom_get_async_baud_val+0x13c>)
			baud_int -= baud_fp;
    f8d6:	1b1b      	subs	r3, r3, r4
			baud_int = baud_int / BAUD_FP_MAX;
    f8d8:	08db      	lsrs	r3, r3, #3
			if(baud_int < BAUD_INT_MAX) {
    f8da:	4293      	cmp	r3, r2
    f8dc:	d906      	bls.n	f8ec <_sercom_get_async_baud_val+0x138>
    f8de:	3401      	adds	r4, #1
		for(baud_fp = 0; baud_fp < BAUD_FP_MAX; baud_fp++) {
    f8e0:	2c08      	cmp	r4, #8
    f8e2:	d1c8      	bne.n	f876 <_sercom_get_async_baud_val+0xc2>
		return STATUS_ERR_BAUDRATE_UNAVAILABLE;
    f8e4:	2340      	movs	r3, #64	; 0x40
}
    f8e6:	0018      	movs	r0, r3
    f8e8:	b00b      	add	sp, #44	; 0x2c
    f8ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
		baud_calculated = baud_int | (baud_fp << 13);
    f8ec:	0364      	lsls	r4, r4, #13
    f8ee:	e7ae      	b.n	f84e <_sercom_get_async_baud_val+0x9a>
    f8f0:	00001fff 	.word	0x00001fff

0000f8f4 <sercom_set_gclk_generator>:
 *                                         forced.
 */
enum status_code sercom_set_gclk_generator(
		const enum gclk_generator generator_source,
		const bool force_change)
{
    f8f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	/* Check if valid option */
	if (!_sercom_config.generator_is_set || force_change) {
    f8f6:	4c0d      	ldr	r4, [pc, #52]	; (f92c <sercom_set_gclk_generator+0x38>)
{
    f8f8:	0005      	movs	r5, r0
	if (!_sercom_config.generator_is_set || force_change) {
    f8fa:	7823      	ldrb	r3, [r4, #0]
    f8fc:	2b00      	cmp	r3, #0
    f8fe:	d001      	beq.n	f904 <sercom_set_gclk_generator+0x10>
    f900:	2900      	cmp	r1, #0
    f902:	d00c      	beq.n	f91e <sercom_set_gclk_generator+0x2a>
		/* Create and fill a GCLK configuration structure for the new config */
		struct system_gclk_chan_config gclk_chan_conf;
		system_gclk_chan_get_config_defaults(&gclk_chan_conf);
		gclk_chan_conf.source_generator = generator_source;
    f904:	a901      	add	r1, sp, #4
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    f906:	2013      	movs	r0, #19
		gclk_chan_conf.source_generator = generator_source;
    f908:	700d      	strb	r5, [r1, #0]
		system_gclk_chan_set_config(SERCOM_GCLK_ID, &gclk_chan_conf);
    f90a:	f7fc fd3d 	bl	c388 <system_gclk_chan_set_config>
		system_gclk_chan_enable(SERCOM_GCLK_ID);
    f90e:	2013      	movs	r0, #19
    f910:	f7fc fcfe 	bl	c310 <system_gclk_chan_enable>

		/* Save config */
		_sercom_config.generator_source = generator_source;
		_sercom_config.generator_is_set = true;
    f914:	2301      	movs	r3, #1

		return STATUS_OK;
    f916:	2000      	movs	r0, #0
		_sercom_config.generator_source = generator_source;
    f918:	7065      	strb	r5, [r4, #1]
		_sercom_config.generator_is_set = true;
    f91a:	7023      	strb	r3, [r4, #0]
		return STATUS_OK;
	}

	/* Return invalid config to already initialized GCLK */
	return STATUS_ERR_ALREADY_INITIALIZED;
}
    f91c:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}
	} else if (generator_source == _sercom_config.generator_source) {
    f91e:	7863      	ldrb	r3, [r4, #1]
		return STATUS_OK;
    f920:	0008      	movs	r0, r1
	} else if (generator_source == _sercom_config.generator_source) {
    f922:	42ab      	cmp	r3, r5
    f924:	d0fa      	beq.n	f91c <sercom_set_gclk_generator+0x28>
	return STATUS_ERR_ALREADY_INITIALIZED;
    f926:	201d      	movs	r0, #29
    f928:	e7f8      	b.n	f91c <sercom_set_gclk_generator+0x28>
    f92a:	46c0      	nop			; (mov r8, r8)
    f92c:	20002278 	.word	0x20002278

0000f930 <_sercom_get_default_pad>:
 */
uint32_t _sercom_get_default_pad(
		Sercom *const sercom_module,
		const uint8_t pad)
{
	switch ((uintptr_t)sercom_module) {
    f930:	4a39      	ldr	r2, [pc, #228]	; (fa18 <_sercom_get_default_pad+0xe8>)
{
    f932:	0003      	movs	r3, r0
    f934:	b500      	push	{lr}
    f936:	0008      	movs	r0, r1
	switch ((uintptr_t)sercom_module) {
    f938:	4293      	cmp	r3, r2
    f93a:	d037      	beq.n	f9ac <_sercom_get_default_pad+0x7c>
    f93c:	d807      	bhi.n	f94e <_sercom_get_default_pad+0x1e>
    f93e:	4a37      	ldr	r2, [pc, #220]	; (fa1c <_sercom_get_default_pad+0xec>)
    f940:	4293      	cmp	r3, r2
    f942:	d014      	beq.n	f96e <_sercom_get_default_pad+0x3e>
    f944:	4a36      	ldr	r2, [pc, #216]	; (fa20 <_sercom_get_default_pad+0xf0>)
    f946:	4293      	cmp	r3, r2
    f948:	d021      	beq.n	f98e <_sercom_get_default_pad+0x5e>
		/* Auto-generate a lookup table for the default SERCOM pad defaults */
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
	}

	Assert(false);
	return 0;
    f94a:	2300      	movs	r3, #0
    f94c:	e017      	b.n	f97e <_sercom_get_default_pad+0x4e>
	switch ((uintptr_t)sercom_module) {
    f94e:	4a35      	ldr	r2, [pc, #212]	; (fa24 <_sercom_get_default_pad+0xf4>)
    f950:	4293      	cmp	r3, r2
    f952:	d042      	beq.n	f9da <_sercom_get_default_pad+0xaa>
    f954:	4a34      	ldr	r2, [pc, #208]	; (fa28 <_sercom_get_default_pad+0xf8>)
    f956:	4293      	cmp	r3, r2
    f958:	d04e      	beq.n	f9f8 <_sercom_get_default_pad+0xc8>
    f95a:	4a34      	ldr	r2, [pc, #208]	; (fa2c <_sercom_get_default_pad+0xfc>)
    f95c:	4293      	cmp	r3, r2
    f95e:	d1f4      	bne.n	f94a <_sercom_get_default_pad+0x1a>
	return 0;
    f960:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f962:	2903      	cmp	r1, #3
    f964:	d80b      	bhi.n	f97e <_sercom_get_default_pad+0x4e>
    f966:	f000 fd63 	bl	10430 <__gnu_thumb1_case_uqi>
    f96a:	3032      	.short	0x3032
    f96c:	3634      	.short	0x3634
	return 0;
    f96e:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f970:	2903      	cmp	r1, #3
    f972:	d804      	bhi.n	f97e <_sercom_get_default_pad+0x4e>
    f974:	f000 fd5c 	bl	10430 <__gnu_thumb1_case_uqi>
    f978:	09070205 	.word	0x09070205
    f97c:	4b2c      	ldr	r3, [pc, #176]	; (fa30 <_sercom_get_default_pad+0x100>)
}
    f97e:	0018      	movs	r0, r3
    f980:	bd00      	pop	{pc}
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f982:	4b2c      	ldr	r3, [pc, #176]	; (fa34 <_sercom_get_default_pad+0x104>)
    f984:	e7fb      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f986:	4b2c      	ldr	r3, [pc, #176]	; (fa38 <_sercom_get_default_pad+0x108>)
    f988:	e7f9      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f98a:	4b2c      	ldr	r3, [pc, #176]	; (fa3c <_sercom_get_default_pad+0x10c>)
    f98c:	e7f7      	b.n	f97e <_sercom_get_default_pad+0x4e>
	return 0;
    f98e:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f990:	2903      	cmp	r1, #3
    f992:	d8f4      	bhi.n	f97e <_sercom_get_default_pad+0x4e>
    f994:	f000 fd4c 	bl	10430 <__gnu_thumb1_case_uqi>
    f998:	08060204 	.word	0x08060204
    f99c:	4b28      	ldr	r3, [pc, #160]	; (fa40 <_sercom_get_default_pad+0x110>)
    f99e:	e7ee      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9a0:	2303      	movs	r3, #3
    f9a2:	e7ec      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9a4:	4b27      	ldr	r3, [pc, #156]	; (fa44 <_sercom_get_default_pad+0x114>)
    f9a6:	e7ea      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9a8:	4b27      	ldr	r3, [pc, #156]	; (fa48 <_sercom_get_default_pad+0x118>)
    f9aa:	e7e8      	b.n	f97e <_sercom_get_default_pad+0x4e>
	return 0;
    f9ac:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f9ae:	2903      	cmp	r1, #3
    f9b0:	d8e5      	bhi.n	f97e <_sercom_get_default_pad+0x4e>
    f9b2:	f000 fd3d 	bl	10430 <__gnu_thumb1_case_uqi>
    f9b6:	0204      	.short	0x0204
    f9b8:	0806      	.short	0x0806
    f9ba:	4b24      	ldr	r3, [pc, #144]	; (fa4c <_sercom_get_default_pad+0x11c>)
    f9bc:	e7df      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9be:	4b24      	ldr	r3, [pc, #144]	; (fa50 <_sercom_get_default_pad+0x120>)
    f9c0:	e7dd      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9c2:	4b24      	ldr	r3, [pc, #144]	; (fa54 <_sercom_get_default_pad+0x124>)
    f9c4:	e7db      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9c6:	4b24      	ldr	r3, [pc, #144]	; (fa58 <_sercom_get_default_pad+0x128>)
    f9c8:	e7d9      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9ca:	4b24      	ldr	r3, [pc, #144]	; (fa5c <_sercom_get_default_pad+0x12c>)
    f9cc:	e7d7      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9ce:	4b24      	ldr	r3, [pc, #144]	; (fa60 <_sercom_get_default_pad+0x130>)
    f9d0:	e7d5      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9d2:	4b24      	ldr	r3, [pc, #144]	; (fa64 <_sercom_get_default_pad+0x134>)
    f9d4:	e7d3      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9d6:	4b24      	ldr	r3, [pc, #144]	; (fa68 <_sercom_get_default_pad+0x138>)
    f9d8:	e7d1      	b.n	f97e <_sercom_get_default_pad+0x4e>
	return 0;
    f9da:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f9dc:	2903      	cmp	r1, #3
    f9de:	d8ce      	bhi.n	f97e <_sercom_get_default_pad+0x4e>
    f9e0:	f000 fd26 	bl	10430 <__gnu_thumb1_case_uqi>
    f9e4:	08060204 	.word	0x08060204
    f9e8:	4b20      	ldr	r3, [pc, #128]	; (fa6c <_sercom_get_default_pad+0x13c>)
    f9ea:	e7c8      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9ec:	4b20      	ldr	r3, [pc, #128]	; (fa70 <_sercom_get_default_pad+0x140>)
    f9ee:	e7c6      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9f0:	4b20      	ldr	r3, [pc, #128]	; (fa74 <_sercom_get_default_pad+0x144>)
    f9f2:	e7c4      	b.n	f97e <_sercom_get_default_pad+0x4e>
    f9f4:	4b20      	ldr	r3, [pc, #128]	; (fa78 <_sercom_get_default_pad+0x148>)
    f9f6:	e7c2      	b.n	f97e <_sercom_get_default_pad+0x4e>
	return 0;
    f9f8:	2300      	movs	r3, #0
		MREPEAT(SERCOM_INST_NUM, _SERCOM_PAD_DEFAULTS_CASE, pad)
    f9fa:	2903      	cmp	r1, #3
    f9fc:	d8bf      	bhi.n	f97e <_sercom_get_default_pad+0x4e>
    f9fe:	f000 fd17 	bl	10430 <__gnu_thumb1_case_uqi>
    fa02:	0204      	.short	0x0204
    fa04:	0806      	.short	0x0806
    fa06:	4b1d      	ldr	r3, [pc, #116]	; (fa7c <_sercom_get_default_pad+0x14c>)
    fa08:	e7b9      	b.n	f97e <_sercom_get_default_pad+0x4e>
    fa0a:	4b1d      	ldr	r3, [pc, #116]	; (fa80 <_sercom_get_default_pad+0x150>)
    fa0c:	e7b7      	b.n	f97e <_sercom_get_default_pad+0x4e>
    fa0e:	4b1d      	ldr	r3, [pc, #116]	; (fa84 <_sercom_get_default_pad+0x154>)
    fa10:	e7b5      	b.n	f97e <_sercom_get_default_pad+0x4e>
    fa12:	4b1d      	ldr	r3, [pc, #116]	; (fa88 <_sercom_get_default_pad+0x158>)
    fa14:	e7b3      	b.n	f97e <_sercom_get_default_pad+0x4e>
    fa16:	46c0      	nop			; (mov r8, r8)
    fa18:	42001000 	.word	0x42001000
    fa1c:	42000800 	.word	0x42000800
    fa20:	42000c00 	.word	0x42000c00
    fa24:	42001800 	.word	0x42001800
    fa28:	42001c00 	.word	0x42001c00
    fa2c:	42001400 	.word	0x42001400
    fa30:	00050003 	.word	0x00050003
    fa34:	00040003 	.word	0x00040003
    fa38:	00060003 	.word	0x00060003
    fa3c:	00070003 	.word	0x00070003
    fa40:	00010003 	.word	0x00010003
    fa44:	001e0003 	.word	0x001e0003
    fa48:	001f0003 	.word	0x001f0003
    fa4c:	00090003 	.word	0x00090003
    fa50:	00080003 	.word	0x00080003
    fa54:	000a0003 	.word	0x000a0003
    fa58:	000b0003 	.word	0x000b0003
    fa5c:	00110003 	.word	0x00110003
    fa60:	00100003 	.word	0x00100003
    fa64:	00120003 	.word	0x00120003
    fa68:	00130003 	.word	0x00130003
    fa6c:	000d0003 	.word	0x000d0003
    fa70:	000c0003 	.word	0x000c0003
    fa74:	000e0003 	.word	0x000e0003
    fa78:	000f0003 	.word	0x000f0003
    fa7c:	00170003 	.word	0x00170003
    fa80:	00160003 	.word	0x00160003
    fa84:	00180003 	.word	0x00180003
    fa88:	00190003 	.word	0x00190003

0000fa8c <_sercom_get_sercom_inst_index>:
 *
 * \return Index of given instance.
 */
uint8_t _sercom_get_sercom_inst_index(
		Sercom *const sercom_instance)
{
    fa8c:	b570      	push	{r4, r5, r6, lr}
    fa8e:	b086      	sub	sp, #24
	/* Save all available SERCOM instances for compare */
	Sercom *sercom_instances[SERCOM_INST_NUM] = SERCOM_INSTS;
    fa90:	466a      	mov	r2, sp
    fa92:	0011      	movs	r1, r2
    fa94:	4b08      	ldr	r3, [pc, #32]	; (fab8 <_sercom_get_sercom_inst_index+0x2c>)
    fa96:	cb70      	ldmia	r3!, {r4, r5, r6}
    fa98:	c170      	stmia	r1!, {r4, r5, r6}
    fa9a:	cb70      	ldmia	r3!, {r4, r5, r6}
    fa9c:	c170      	stmia	r1!, {r4, r5, r6}

	/* Find index for sercom instance */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    fa9e:	2300      	movs	r3, #0
		if ((uintptr_t)sercom_instance == (uintptr_t)sercom_instances[i]) {
    faa0:	0099      	lsls	r1, r3, #2
    faa2:	5851      	ldr	r1, [r2, r1]
    faa4:	4281      	cmp	r1, r0
    faa6:	d102      	bne.n	faae <_sercom_get_sercom_inst_index+0x22>
			return i;
    faa8:	b2d8      	uxtb	r0, r3
	}

	/* Invalid data given */
	Assert(false);
	return 0;
}
    faaa:	b006      	add	sp, #24
    faac:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
    faae:	3301      	adds	r3, #1
    fab0:	2b06      	cmp	r3, #6
    fab2:	d1f5      	bne.n	faa0 <_sercom_get_sercom_inst_index+0x14>
	return 0;
    fab4:	2000      	movs	r0, #0
    fab6:	e7f8      	b.n	faaa <_sercom_get_sercom_inst_index+0x1e>
    fab8:	000109bc 	.word	0x000109bc

0000fabc <os_cputime_init>:
 *
 * @return int 0 on success; -1 on error.
 */
int
os_cputime_init(uint32_t clock_freq)
{
    fabc:	b510      	push	{r4, lr}
    fabe:	0001      	movs	r1, r0

    /* Set the ticks per microsecond. */
#if !defined(OS_CPUTIME_FREQ_32768) && !defined(OS_CPUTIME_FREQ_1MHZ)
    g_os_cputime.ticks_per_usec = clock_freq / 1000000U;
#endif
    rc = hal_timer_config(MYNEWT_VAL(OS_CPUTIME_TIMER_NUM), clock_freq);
    fac0:	2000      	movs	r0, #0
    fac2:	f7fe fdad 	bl	e620 <hal_timer_config>
    return rc;
}
    fac6:	bd10      	pop	{r4, pc}

0000fac8 <os_malloc_lock.part.0>:
#if MYNEWT_VAL(OS_SCHEDULING)
    int rc;

    if (g_os_started) {
        rc = os_mutex_pend(&os_malloc_mutex, 0xffffffff);
        assert(rc == 0);
    fac8:	2300      	movs	r3, #0
os_malloc_lock(void)
    faca:	b510      	push	{r4, lr}
        assert(rc == 0);
    facc:	001a      	movs	r2, r3
    face:	0019      	movs	r1, r3
    fad0:	0018      	movs	r0, r3
    fad2:	f7fc ff31 	bl	c938 <__assert_func>
	...

0000fad8 <os_malloc_lock>:
    if (g_os_started) {
    fad8:	4b07      	ldr	r3, [pc, #28]	; (faf8 <os_malloc_lock+0x20>)
{
    fada:	b510      	push	{r4, lr}
    if (g_os_started) {
    fadc:	681b      	ldr	r3, [r3, #0]
    fade:	2b00      	cmp	r3, #0
    fae0:	d008      	beq.n	faf4 <os_malloc_lock+0x1c>
        rc = os_mutex_pend(&os_malloc_mutex, 0xffffffff);
    fae2:	2101      	movs	r1, #1
    fae4:	4805      	ldr	r0, [pc, #20]	; (fafc <os_malloc_lock+0x24>)
    fae6:	4249      	negs	r1, r1
    fae8:	f7fd fdf0 	bl	d6cc <os_mutex_pend>
        assert(rc == 0);
    faec:	2800      	cmp	r0, #0
    faee:	d001      	beq.n	faf4 <os_malloc_lock+0x1c>
    faf0:	f7ff ffea 	bl	fac8 <os_malloc_lock.part.0>
    }
#endif
}
    faf4:	bd10      	pop	{r4, pc}
    faf6:	46c0      	nop			; (mov r8, r8)
    faf8:	2000249c 	.word	0x2000249c
    fafc:	2000227c 	.word	0x2000227c

0000fb00 <os_malloc_unlock>:
os_malloc_unlock(void)
{
#if MYNEWT_VAL(OS_SCHEDULING)
    int rc;

    if (g_os_started) {
    fb00:	4b06      	ldr	r3, [pc, #24]	; (fb1c <os_malloc_unlock+0x1c>)
{
    fb02:	b510      	push	{r4, lr}
    if (g_os_started) {
    fb04:	681b      	ldr	r3, [r3, #0]
    fb06:	2b00      	cmp	r3, #0
    fb08:	d006      	beq.n	fb18 <os_malloc_unlock+0x18>
        rc = os_mutex_release(&os_malloc_mutex);
    fb0a:	4805      	ldr	r0, [pc, #20]	; (fb20 <os_malloc_unlock+0x20>)
    fb0c:	f7fd fd80 	bl	d610 <os_mutex_release>
        assert(rc == 0);
    fb10:	2800      	cmp	r0, #0
    fb12:	d001      	beq.n	fb18 <os_malloc_unlock+0x18>
    fb14:	f7ff ffd8 	bl	fac8 <os_malloc_lock.part.0>
    }
#endif
}
    fb18:	bd10      	pop	{r4, pc}
    fb1a:	46c0      	nop			; (mov r8, r8)
    fb1c:	2000249c 	.word	0x2000249c
    fb20:	2000227c 	.word	0x2000227c

0000fb24 <os_malloc>:
 *
 * @return A pointer to the memory region allocated.
 */
void *
os_malloc(size_t size)
{
    fb24:	b510      	push	{r4, lr}
    fb26:	0004      	movs	r4, r0
    void *ptr;

    os_malloc_lock();
    fb28:	f7ff ffd6 	bl	fad8 <os_malloc_lock>
    ptr = malloc(size);
    fb2c:	0020      	movs	r0, r4
    fb2e:	f000 f86b 	bl	fc08 <malloc>
    fb32:	0004      	movs	r4, r0
    os_malloc_unlock();
    fb34:	f7ff ffe4 	bl	fb00 <os_malloc_unlock>

    return ptr;
}
    fb38:	0020      	movs	r0, r4
    fb3a:	bd10      	pop	{r4, pc}

0000fb3c <os_free>:
 *
 * @param mem The memory to free.
 */
void
os_free(void *mem)
{
    fb3c:	b510      	push	{r4, lr}
    fb3e:	0004      	movs	r4, r0
    os_malloc_lock();
    fb40:	f7ff ffca 	bl	fad8 <os_malloc_lock>
    free(mem);
    fb44:	0020      	movs	r0, r4
    fb46:	f000 f8ab 	bl	fca0 <free>
    os_malloc_unlock();
    fb4a:	f7ff ffd9 	bl	fb00 <os_malloc_unlock>
}
    fb4e:	bd10      	pop	{r4, pc}

0000fb50 <malloc_lock_nop>:
	},
	&__malloc_head,
	&__malloc_head
};

static bool malloc_lock_nop() {return true;}
    fb50:	2001      	movs	r0, #1
    fb52:	4770      	bx	lr

0000fb54 <malloc_unlock_nop>:
static void malloc_unlock_nop() {}
    fb54:	4770      	bx	lr
	...

0000fb58 <__free_block>:

static struct free_arena_header *__free_block(struct free_arena_header *ah)
{
	struct free_arena_header *pah, *nah;

	pah = ah->a.prev;
    fb58:	68c3      	ldr	r3, [r0, #12]
{
    fb5a:	b510      	push	{r4, lr}
	nah = ah->a.next;
	if (pah->a.type == ARENA_TYPE_FREE &&
    fb5c:	6819      	ldr	r1, [r3, #0]
	nah = ah->a.next;
    fb5e:	6882      	ldr	r2, [r0, #8]
	if (pah->a.type == ARENA_TYPE_FREE &&
    fb60:	2901      	cmp	r1, #1
    fb62:	d11c      	bne.n	fb9e <__free_block+0x46>
	    (char *)pah + pah->a.size == (char *)ah) {
    fb64:	685c      	ldr	r4, [r3, #4]
    fb66:	1919      	adds	r1, r3, r4
	if (pah->a.type == ARENA_TYPE_FREE &&
    fb68:	4288      	cmp	r0, r1
    fb6a:	d118      	bne.n	fb9e <__free_block+0x46>
		/* Coalesce into the previous block */
		pah->a.size += ah->a.size;
    fb6c:	6841      	ldr	r1, [r0, #4]
		pah->a.next = nah;
    fb6e:	609a      	str	r2, [r3, #8]
		pah->a.size += ah->a.size;
    fb70:	1909      	adds	r1, r1, r4
    fb72:	6059      	str	r1, [r3, #4]
		nah->a.prev = pah;
    fb74:	60d3      	str	r3, [r2, #12]
		ah->next_free->prev_free = ah;
	}

	/* In either of the previous cases, we might be able to merge
	   with the subsequent block... */
	if (nah->a.type == ARENA_TYPE_FREE &&
    fb76:	6811      	ldr	r1, [r2, #0]
    fb78:	2901      	cmp	r1, #1
    fb7a:	d10e      	bne.n	fb9a <__free_block+0x42>
	    (char *)ah + ah->a.size == (char *)nah) {
    fb7c:	6859      	ldr	r1, [r3, #4]
    fb7e:	1858      	adds	r0, r3, r1
	if (nah->a.type == ARENA_TYPE_FREE &&
    fb80:	4282      	cmp	r2, r0
    fb82:	d10a      	bne.n	fb9a <__free_block+0x42>
		ah->a.size += nah->a.size;
    fb84:	6850      	ldr	r0, [r2, #4]
    fb86:	1841      	adds	r1, r0, r1
    fb88:	6059      	str	r1, [r3, #4]
	ap = ah->prev_free;
    fb8a:	6950      	ldr	r0, [r2, #20]
	an = ah->next_free;
    fb8c:	6911      	ldr	r1, [r2, #16]
	ap->next_free = an;
    fb8e:	6101      	str	r1, [r0, #16]
	an->prev_free = ap;
    fb90:	6148      	str	r0, [r1, #20]
	ap = ah->a.prev;
    fb92:	68d1      	ldr	r1, [r2, #12]
	an = ah->a.next;
    fb94:	6892      	ldr	r2, [r2, #8]
	ap->a.next = an;
    fb96:	608a      	str	r2, [r1, #8]
	an->a.prev = ap;
    fb98:	60d1      	str	r1, [r2, #12]
		remove_from_chains(nah);
	}

	/* Return the block that contains the called block */
	return ah;
}
    fb9a:	0018      	movs	r0, r3
    fb9c:	bd10      	pop	{r4, pc}
		ah->a.type = ARENA_TYPE_FREE;
    fb9e:	2301      	movs	r3, #1
    fba0:	6003      	str	r3, [r0, #0]
		ah->next_free = __malloc_head.next_free;
    fba2:	4b04      	ldr	r3, [pc, #16]	; (fbb4 <__free_block+0x5c>)
    fba4:	6919      	ldr	r1, [r3, #16]
		ah->prev_free = &__malloc_head;
    fba6:	6143      	str	r3, [r0, #20]
		ah->next_free = __malloc_head.next_free;
    fba8:	6101      	str	r1, [r0, #16]
		__malloc_head.next_free = ah;
    fbaa:	6118      	str	r0, [r3, #16]
		ah->next_free->prev_free = ah;
    fbac:	6903      	ldr	r3, [r0, #16]
    fbae:	6158      	str	r0, [r3, #20]
    fbb0:	0003      	movs	r3, r0
    fbb2:	e7e0      	b.n	fb76 <__free_block+0x1e>
    fbb4:	200000f8 	.word	0x200000f8

0000fbb8 <add_malloc_block>:
	return result;
}

/* Call this to give malloc some memory to allocate from */
void add_malloc_block(void *buf, size_t size)
{
    fbb8:	b510      	push	{r4, lr}
    fbba:	0004      	movs	r4, r0
	struct free_arena_header *fp = buf;
	struct free_arena_header *pah;

	if (size < sizeof(struct free_arena_header))
    fbbc:	2917      	cmp	r1, #23
    fbbe:	d908      	bls.n	fbd2 <add_malloc_block+0x1a>
		return; // Too small.

	/* Insert the block into the management chains.  We need to set
	   up the size and the main block list pointer, the rest of
	   the work is logically identical to free(). */
	fp->a.type = ARENA_TYPE_FREE;
    fbc0:	2301      	movs	r3, #1
    fbc2:	6003      	str	r3, [r0, #0]
	fp->a.size = size;

        if (!malloc_lock())
    fbc4:	4b0d      	ldr	r3, [pc, #52]	; (fbfc <add_malloc_block+0x44>)
	fp->a.size = size;
    fbc6:	6041      	str	r1, [r0, #4]
        if (!malloc_lock())
    fbc8:	681b      	ldr	r3, [r3, #0]
    fbca:	4798      	blx	r3

	/* We need to insert this into the main block list in the proper
	   place -- this list is required to be sorted.  Since we most likely
	   get memory assignments in ascending order, search backwards for
	   the proper place. */
	for (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;
    fbcc:	4b0c      	ldr	r3, [pc, #48]	; (fc00 <add_malloc_block+0x48>)
        if (!malloc_lock())
    fbce:	2800      	cmp	r0, #0
    fbd0:	d100      	bne.n	fbd4 <add_malloc_block+0x1c>

	/* Insert into the free chain and coalesce with adjacent blocks */
	fp = __free_block(fp);

        malloc_unlock();
}
    fbd2:	bd10      	pop	{r4, pc}
	     pah = pah->a.prev) {
    fbd4:	68db      	ldr	r3, [r3, #12]
	for (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;
    fbd6:	681a      	ldr	r2, [r3, #0]
    fbd8:	2a02      	cmp	r2, #2
    fbda:	d001      	beq.n	fbe0 <add_malloc_block+0x28>
		if (pah < fp)
    fbdc:	429c      	cmp	r4, r3
    fbde:	d9f9      	bls.n	fbd4 <add_malloc_block+0x1c>
	fp->a.next = pah->a.next;
    fbe0:	689a      	ldr	r2, [r3, #8]
	fp->a.prev = pah;
    fbe2:	60e3      	str	r3, [r4, #12]
	fp->a.next = pah->a.next;
    fbe4:	60a2      	str	r2, [r4, #8]
	pah->a.next = fp;
    fbe6:	609c      	str	r4, [r3, #8]
	fp->a.next->a.prev = fp;
    fbe8:	68a3      	ldr	r3, [r4, #8]
	fp = __free_block(fp);
    fbea:	0020      	movs	r0, r4
	fp->a.next->a.prev = fp;
    fbec:	60dc      	str	r4, [r3, #12]
	fp = __free_block(fp);
    fbee:	f7ff ffb3 	bl	fb58 <__free_block>
        malloc_unlock();
    fbf2:	4b04      	ldr	r3, [pc, #16]	; (fc04 <add_malloc_block+0x4c>)
    fbf4:	681b      	ldr	r3, [r3, #0]
    fbf6:	4798      	blx	r3
    fbf8:	e7eb      	b.n	fbd2 <add_malloc_block+0x1a>
    fbfa:	46c0      	nop			; (mov r8, r8)
    fbfc:	20000110 	.word	0x20000110
    fc00:	200000f8 	.word	0x200000f8
    fc04:	20000114 	.word	0x20000114

0000fc08 <malloc>:
{
    fc08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (size == 0)
    fc0a:	2800      	cmp	r0, #0
    fc0c:	d102      	bne.n	fc14 <malloc+0xc>
		return NULL;
    fc0e:	2400      	movs	r4, #0
}
    fc10:	0020      	movs	r0, r4
    fc12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
    fc14:	230f      	movs	r3, #15
    fc16:	301f      	adds	r0, #31
    fc18:	4398      	bics	r0, r3
        if (!malloc_lock())
    fc1a:	4b1e      	ldr	r3, [pc, #120]	; (fc94 <malloc+0x8c>)
	size = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;
    fc1c:	0004      	movs	r4, r0
        if (!malloc_lock())
    fc1e:	681b      	ldr	r3, [r3, #0]
    fc20:	4798      	blx	r3
    fc22:	2800      	cmp	r0, #0
    fc24:	d0f3      	beq.n	fc0e <malloc+0x6>
	for (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;
    fc26:	4b1c      	ldr	r3, [pc, #112]	; (fc98 <malloc+0x90>)
    fc28:	691b      	ldr	r3, [r3, #16]
    fc2a:	681a      	ldr	r2, [r3, #0]
    fc2c:	2a02      	cmp	r2, #2
    fc2e:	d106      	bne.n	fc3e <malloc+0x36>
            more_mem = _sbrk(size);
    fc30:	0020      	movs	r0, r4
    fc32:	f000 fbab 	bl	1038c <_sbrk>
            if (more_mem != (void *)-1) {
    fc36:	1c43      	adds	r3, r0, #1
    fc38:	d128      	bne.n	fc8c <malloc+0x84>
    fc3a:	2400      	movs	r4, #0
    fc3c:	e01b      	b.n	fc76 <malloc+0x6e>
		if (fp->a.size >= size) {
    fc3e:	6858      	ldr	r0, [r3, #4]
    fc40:	6919      	ldr	r1, [r3, #16]
    fc42:	42a0      	cmp	r0, r4
    fc44:	d320      	bcc.n	fc88 <malloc+0x80>
	if (fsize >= size + 2 * sizeof(struct arena_header)) {
    fc46:	0022      	movs	r2, r4
    fc48:	3220      	adds	r2, #32
    fc4a:	695d      	ldr	r5, [r3, #20]
    fc4c:	4290      	cmp	r0, r2
    fc4e:	d316      	bcc.n	fc7e <malloc+0x76>
		nfp = (struct free_arena_header *)((char *)fp + size);
    fc50:	191a      	adds	r2, r3, r4
		nfp->a.size = fsize - size;
    fc52:	1b00      	subs	r0, r0, r4
		na = fp->a.next;
    fc54:	689e      	ldr	r6, [r3, #8]
		nfp->a.type = ARENA_TYPE_FREE;
    fc56:	2701      	movs	r7, #1
		nfp->a.size = fsize - size;
    fc58:	6050      	str	r0, [r2, #4]
		fp->a.type = ARENA_TYPE_USED;
    fc5a:	2000      	movs	r0, #0
		nfp->a.type = ARENA_TYPE_FREE;
    fc5c:	6017      	str	r7, [r2, #0]
		fp->a.type = ARENA_TYPE_USED;
    fc5e:	6018      	str	r0, [r3, #0]
		fp->a.size = size;
    fc60:	605c      	str	r4, [r3, #4]
		nfp->a.prev = fp;
    fc62:	60d3      	str	r3, [r2, #12]
		nfp->a.next = na;
    fc64:	6096      	str	r6, [r2, #8]
		na->a.prev = nfp;
    fc66:	60f2      	str	r2, [r6, #12]
		fp->a.next = nfp;
    fc68:	609a      	str	r2, [r3, #8]
		nfp->next_free = fpn = fp->next_free;
    fc6a:	6111      	str	r1, [r2, #16]
		nfp->prev_free = fpp = fp->prev_free;
    fc6c:	6155      	str	r5, [r2, #20]
		fpn->prev_free = nfp;
    fc6e:	614a      	str	r2, [r1, #20]
		fpp->next_free = nfp;
    fc70:	612a      	str	r2, [r5, #16]
	return (void *)(&fp->a + 1);
    fc72:	3310      	adds	r3, #16
    fc74:	001c      	movs	r4, r3
        malloc_unlock();
    fc76:	4b09      	ldr	r3, [pc, #36]	; (fc9c <malloc+0x94>)
    fc78:	681b      	ldr	r3, [r3, #0]
    fc7a:	4798      	blx	r3
	return result;
    fc7c:	e7c8      	b.n	fc10 <malloc+0x8>
		fp->a.type = ARENA_TYPE_USED; /* Allocate the whole block */
    fc7e:	2200      	movs	r2, #0
    fc80:	601a      	str	r2, [r3, #0]
	ap->next_free = an;
    fc82:	6129      	str	r1, [r5, #16]
	an->prev_free = ap;
    fc84:	614d      	str	r5, [r1, #20]
    fc86:	e7f4      	b.n	fc72 <malloc+0x6a>
    fc88:	000b      	movs	r3, r1
    fc8a:	e7ce      	b.n	fc2a <malloc+0x22>
                add_malloc_block(more_mem, size);
    fc8c:	0021      	movs	r1, r4
    fc8e:	f7ff ff93 	bl	fbb8 <add_malloc_block>
                goto retry_alloc;
    fc92:	e7c8      	b.n	fc26 <malloc+0x1e>
    fc94:	20000110 	.word	0x20000110
    fc98:	200000f8 	.word	0x200000f8
    fc9c:	20000114 	.word	0x20000114

0000fca0 <free>:

void free(void *ptr)
{
    fca0:	b510      	push	{r4, lr}
    fca2:	1e04      	subs	r4, r0, #0
	struct free_arena_header *ah;

	if (!ptr)
    fca4:	d00b      	beq.n	fcbe <free+0x1e>

#ifdef DEBUG_MALLOC
	assert(ah->a.type == ARENA_TYPE_USED);
#endif

        if (!malloc_lock())
    fca6:	4b06      	ldr	r3, [pc, #24]	; (fcc0 <free+0x20>)
    fca8:	681b      	ldr	r3, [r3, #0]
    fcaa:	4798      	blx	r3
    fcac:	2800      	cmp	r0, #0
    fcae:	d006      	beq.n	fcbe <free+0x1e>
	ah = (struct free_arena_header *)
    fcb0:	0020      	movs	r0, r4
    fcb2:	3810      	subs	r0, #16
            return;

	/* Merge into adjacent free blocks */
	ah = __free_block(ah);
    fcb4:	f7ff ff50 	bl	fb58 <__free_block>
        malloc_unlock();
    fcb8:	4b02      	ldr	r3, [pc, #8]	; (fcc4 <free+0x24>)
    fcba:	681b      	ldr	r3, [r3, #0]
    fcbc:	4798      	blx	r3
}
    fcbe:	bd10      	pop	{r4, pc}
    fcc0:	20000110 	.word	0x20000110
    fcc4:	20000114 	.word	0x20000114

0000fcc8 <strlen>:

#include <string.h>

size_t strlen(const char *s)
{
	const char *ss = s;
    fcc8:	0003      	movs	r3, r0
	while (*ss)
    fcca:	781a      	ldrb	r2, [r3, #0]
    fccc:	2a00      	cmp	r2, #0
    fcce:	d101      	bne.n	fcd4 <strlen+0xc>
		ss++;
	return ss - s;
    fcd0:	1a18      	subs	r0, r3, r0
}
    fcd2:	4770      	bx	lr
		ss++;
    fcd4:	3301      	adds	r3, #1
    fcd6:	e7f8      	b.n	fcca <strlen+0x2>

0000fcd8 <ui2a>:
    char base;  /**<  number base (e.g.: 8, 10, 16) */
    char *bf;           /**<  Buffer to output */
};

static void ui2a(unsigned long long int num, struct param *p)
{
    fcd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    int n = 0;
    unsigned long long int d = 1;
    char *bf = p->bf;
    while (num / d >= p->base)
    fcda:	2700      	movs	r7, #0
    unsigned long long int d = 1;
    fcdc:	2501      	movs	r5, #1
    fcde:	003c      	movs	r4, r7
    char *bf = p->bf;
    fce0:	6853      	ldr	r3, [r2, #4]
{
    fce2:	b087      	sub	sp, #28
    fce4:	9003      	str	r0, [sp, #12]
    fce6:	9104      	str	r1, [sp, #16]
    fce8:	9201      	str	r2, [sp, #4]
    char *bf = p->bf;
    fcea:	9300      	str	r3, [sp, #0]
    while (num / d >= p->base)
    fcec:	78d6      	ldrb	r6, [r2, #3]
    fcee:	002a      	movs	r2, r5
    fcf0:	0023      	movs	r3, r4
    fcf2:	9803      	ldr	r0, [sp, #12]
    fcf4:	9904      	ldr	r1, [sp, #16]
    fcf6:	f000 fc3b 	bl	10570 <__aeabi_uldivmod>
    fcfa:	428f      	cmp	r7, r1
    fcfc:	d10a      	bne.n	fd14 <ui2a+0x3c>
    fcfe:	4286      	cmp	r6, r0
    fd00:	d908      	bls.n	fd14 <ui2a+0x3c>
    int n = 0;
    fd02:	2300      	movs	r3, #0
    fd04:	9302      	str	r3, [sp, #8]
        d *= p->base;
    while (d != 0) {
    fd06:	002b      	movs	r3, r5
    fd08:	4323      	orrs	r3, r4
    fd0a:	d10c      	bne.n	fd26 <ui2a+0x4e>
        if (n || dgt > 0 || d == 0) {
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
            ++n;
        }
    }
    *bf = 0;
    fd0c:	9a00      	ldr	r2, [sp, #0]
    fd0e:	7013      	strb	r3, [r2, #0]
}
    fd10:	b007      	add	sp, #28
    fd12:	bdf0      	pop	{r4, r5, r6, r7, pc}
        d *= p->base;
    fd14:	0028      	movs	r0, r5
    fd16:	0021      	movs	r1, r4
    fd18:	0032      	movs	r2, r6
    fd1a:	2300      	movs	r3, #0
    fd1c:	f000 fc48 	bl	105b0 <__aeabi_lmul>
    fd20:	0005      	movs	r5, r0
    fd22:	000c      	movs	r4, r1
    fd24:	e7e3      	b.n	fcee <ui2a+0x16>
    fd26:	002a      	movs	r2, r5
    fd28:	0023      	movs	r3, r4
    fd2a:	9803      	ldr	r0, [sp, #12]
    fd2c:	9904      	ldr	r1, [sp, #16]
    fd2e:	f000 fc1f 	bl	10570 <__aeabi_uldivmod>
        num %= d;
    fd32:	9304      	str	r3, [sp, #16]
        d /= p->base;
    fd34:	9b01      	ldr	r3, [sp, #4]
        unsigned long long  dgt = num / d;
    fd36:	9105      	str	r1, [sp, #20]
        num %= d;
    fd38:	9203      	str	r2, [sp, #12]
        d /= p->base;
    fd3a:	78da      	ldrb	r2, [r3, #3]
    fd3c:	0007      	movs	r7, r0
    fd3e:	2300      	movs	r3, #0
    fd40:	0028      	movs	r0, r5
    fd42:	000e      	movs	r6, r1
    fd44:	0021      	movs	r1, r4
    fd46:	f000 fc13 	bl	10570 <__aeabi_uldivmod>
        if (n || dgt > 0 || d == 0) {
    fd4a:	9b02      	ldr	r3, [sp, #8]
        d /= p->base;
    fd4c:	0005      	movs	r5, r0
    fd4e:	000c      	movs	r4, r1
        if (n || dgt > 0 || d == 0) {
    fd50:	2b00      	cmp	r3, #0
    fd52:	d105      	bne.n	fd60 <ui2a+0x88>
    fd54:	433e      	orrs	r6, r7
    fd56:	d103      	bne.n	fd60 <ui2a+0x88>
    fd58:	4301      	orrs	r1, r0
    fd5a:	d1d4      	bne.n	fd06 <ui2a+0x2e>
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    fd5c:	2330      	movs	r3, #48	; 0x30
    fd5e:	e00b      	b.n	fd78 <ui2a+0xa0>
    fd60:	9b05      	ldr	r3, [sp, #20]
    fd62:	2b00      	cmp	r3, #0
    fd64:	d101      	bne.n	fd6a <ui2a+0x92>
    fd66:	2f09      	cmp	r7, #9
    fd68:	d9f8      	bls.n	fd5c <ui2a+0x84>
    fd6a:	2104      	movs	r1, #4
    fd6c:	9b01      	ldr	r3, [sp, #4]
    fd6e:	789a      	ldrb	r2, [r3, #2]
    fd70:	2337      	movs	r3, #55	; 0x37
    fd72:	420a      	tst	r2, r1
    fd74:	d100      	bne.n	fd78 <ui2a+0xa0>
    fd76:	3320      	adds	r3, #32
    fd78:	19df      	adds	r7, r3, r7
    fd7a:	9b00      	ldr	r3, [sp, #0]
    fd7c:	701f      	strb	r7, [r3, #0]
            ++n;
    fd7e:	9b02      	ldr	r3, [sp, #8]
    fd80:	3301      	adds	r3, #1
    fd82:	9302      	str	r3, [sp, #8]
            *bf++ = dgt + (dgt < 10 ? '0' : (p->uc ? 'A' : 'a') - 10);
    fd84:	9b00      	ldr	r3, [sp, #0]
    fd86:	3301      	adds	r3, #1
    fd88:	9300      	str	r3, [sp, #0]
    fd8a:	e7bc      	b.n	fd06 <ui2a+0x2e>

0000fd8c <putf>:
    *nump = num;
    return ch;
}

static int putf(FILE *putp, char c)
{
    fd8c:	b507      	push	{r0, r1, r2, lr}
	return fwrite(s, 1, strlen(s), stdout) + fwrite("\n", 1, 1, stdout);
}

__extern_inline int fputc(int c, FILE *f)
{
	unsigned char ch = c;
    fd8e:	466a      	mov	r2, sp
    fd90:	000b      	movs	r3, r1
    fd92:	1dd1      	adds	r1, r2, #7
    fd94:	700b      	strb	r3, [r1, #0]
    if (stream->vmt->write == NULL) return 0;
    fd96:	6803      	ldr	r3, [r0, #0]
    fd98:	681b      	ldr	r3, [r3, #0]
    fd9a:	2b00      	cmp	r3, #0
    fd9c:	d101      	bne.n	fda2 <putf+0x16>
    if (fputc(c, putp) == EOF)
        return 0;
    fd9e:	2000      	movs	r0, #0
    else
        return 1;
}
    fda0:	bd0e      	pop	{r1, r2, r3, pc}
    return stream->vmt->write(stream, buf, size*nmemb) / size;
    fda2:	2201      	movs	r2, #1
    fda4:	4798      	blx	r3
	return fwrite(&ch, 1, 1, f) == 1 ? ch : EOF;
    fda6:	2801      	cmp	r0, #1
    fda8:	d1f9      	bne.n	fd9e <putf+0x12>
    fdaa:	e7f9      	b.n	fda0 <putf+0x14>

0000fdac <putchw>:

static unsigned putchw(FILE *putp, struct param *p)
{
    fdac:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    fdae:	000e      	movs	r6, r1
    unsigned written = 0;
    char ch;
    int n = p->width;
    fdb0:	780c      	ldrb	r4, [r1, #0]
    fdb2:	684b      	ldr	r3, [r1, #4]
{
    fdb4:	9001      	str	r0, [sp, #4]
    char *bf = p->bf;

    /* Number of filling characters */
    while (*bf++ && n > 0)
    fdb6:	781a      	ldrb	r2, [r3, #0]
    fdb8:	2a00      	cmp	r2, #0
    fdba:	d002      	beq.n	fdc2 <putchw+0x16>
    fdbc:	3301      	adds	r3, #1
    fdbe:	2c00      	cmp	r4, #0
    fdc0:	d111      	bne.n	fde6 <putchw+0x3a>
        n--;
    if (p->sign)
        n--;
    fdc2:	2201      	movs	r2, #1
    if (p->sign)
    fdc4:	78b3      	ldrb	r3, [r6, #2]
        n--;
    fdc6:	4013      	ands	r3, r2
    fdc8:	1ae4      	subs	r4, r4, r3
    if (p->alt && p->base == 16)
    fdca:	8873      	ldrh	r3, [r6, #2]
    fdcc:	32fc      	adds	r2, #252	; 0xfc
    fdce:	4393      	bics	r3, r2
    fdd0:	4a35      	ldr	r2, [pc, #212]	; (fea8 <putchw+0xfc>)
    fdd2:	4293      	cmp	r3, r2
    fdd4:	d109      	bne.n	fdea <putchw+0x3e>
        n -= 2;
    fdd6:	3c02      	subs	r4, #2
    else if (p->alt && p->base == 8)
        n--;

    /* Unless left-aligned, fill with space, before alternate or sign */
    if (!p->lz && !p->left) {
    fdd8:	4d34      	ldr	r5, [pc, #208]	; (feac <putchw+0x100>)
    fdda:	6833      	ldr	r3, [r6, #0]
    fddc:	0027      	movs	r7, r4
    fdde:	401d      	ands	r5, r3
    fde0:	d00f      	beq.n	fe02 <putchw+0x56>
    unsigned written = 0;
    fde2:	2500      	movs	r5, #0
    fde4:	e014      	b.n	fe10 <putchw+0x64>
        n--;
    fde6:	3c01      	subs	r4, #1
    fde8:	e7e5      	b.n	fdb6 <putchw+0xa>
        n--;
    fdea:	4a31      	ldr	r2, [pc, #196]	; (feb0 <putchw+0x104>)
    fdec:	189b      	adds	r3, r3, r2
    fdee:	425a      	negs	r2, r3
    fdf0:	4153      	adcs	r3, r2
    fdf2:	1ae4      	subs	r4, r4, r3
    fdf4:	e7f0      	b.n	fdd8 <putchw+0x2c>
        while (n-- > 0)
            written += putf(putp, ' ');
    fdf6:	2120      	movs	r1, #32
    fdf8:	9801      	ldr	r0, [sp, #4]
    fdfa:	f7ff ffc7 	bl	fd8c <putf>
    fdfe:	3f01      	subs	r7, #1
    fe00:	182d      	adds	r5, r5, r0
        while (n-- > 0)
    fe02:	2f00      	cmp	r7, #0
    fe04:	dcf7      	bgt.n	fdf6 <putchw+0x4a>
    fe06:	43e3      	mvns	r3, r4
    fe08:	17db      	asrs	r3, r3, #31
    fe0a:	1e62      	subs	r2, r4, #1
    fe0c:	401c      	ands	r4, r3
    fe0e:	1b14      	subs	r4, r2, r4
    }

    /* print sign */
    if (p->sign)
    fe10:	78b3      	ldrb	r3, [r6, #2]
    fe12:	07db      	lsls	r3, r3, #31
    fe14:	d504      	bpl.n	fe20 <putchw+0x74>
        written += putf(putp, '-');
    fe16:	212d      	movs	r1, #45	; 0x2d
    fe18:	9801      	ldr	r0, [sp, #4]
    fe1a:	f7ff ffb7 	bl	fd8c <putf>
    fe1e:	182d      	adds	r5, r5, r0

    /* Alternate */
    if (p->alt && p->base == 16) {
    fe20:	22fd      	movs	r2, #253	; 0xfd
    fe22:	8873      	ldrh	r3, [r6, #2]
    fe24:	4393      	bics	r3, r2
    fe26:	4a20      	ldr	r2, [pc, #128]	; (fea8 <putchw+0xfc>)
    fe28:	4293      	cmp	r3, r2
    fe2a:	d11e      	bne.n	fe6a <putchw+0xbe>
        written += putf(putp, '0');
    fe2c:	2130      	movs	r1, #48	; 0x30
    fe2e:	9801      	ldr	r0, [sp, #4]
    fe30:	f7ff ffac 	bl	fd8c <putf>
        written += putf(putp, (p->uc ? 'X' : 'x'));
    fe34:	78b3      	ldrb	r3, [r6, #2]
        written += putf(putp, '0');
    fe36:	1945      	adds	r5, r0, r5
        written += putf(putp, (p->uc ? 'X' : 'x'));
    fe38:	2158      	movs	r1, #88	; 0x58
    fe3a:	075b      	lsls	r3, r3, #29
    fe3c:	d400      	bmi.n	fe40 <putchw+0x94>
    fe3e:	3120      	adds	r1, #32
    } else if (p->alt && p->base == 8) {
        written += putf(putp, '0');
    fe40:	9801      	ldr	r0, [sp, #4]
    fe42:	f7ff ffa3 	bl	fd8c <putf>
    fe46:	182d      	adds	r5, r5, r0
    }

    /* Fill with zeros, after alternate or sign */
    if (p->lz) {
    fe48:	7873      	ldrb	r3, [r6, #1]
    fe4a:	0027      	movs	r7, r4
    fe4c:	2b00      	cmp	r3, #0
    fe4e:	d117      	bne.n	fe80 <putchw+0xd4>
    fe50:	6877      	ldr	r7, [r6, #4]
    fe52:	3701      	adds	r7, #1
            written += putf(putp, '0');
    }

    /* Put actual buffer */
    bf = p->bf;
    while ((ch = *bf++))
    fe54:	1e7b      	subs	r3, r7, #1
    fe56:	7819      	ldrb	r1, [r3, #0]
    fe58:	2900      	cmp	r1, #0
    fe5a:	d119      	bne.n	fe90 <putchw+0xe4>
        written += putf(putp, ch);

    /* If left-aligned, pad the end with spaces. */
    if (p->left) {
    fe5c:	78b3      	ldrb	r3, [r6, #2]
    fe5e:	071b      	lsls	r3, r3, #28
    fe60:	d501      	bpl.n	fe66 <putchw+0xba>
        while (n-- > 0)
    fe62:	2c00      	cmp	r4, #0
    fe64:	dc19      	bgt.n	fe9a <putchw+0xee>
            written += putf(putp, ' ');
    }
    
    return written;
}
    fe66:	0028      	movs	r0, r5
    fe68:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    } else if (p->alt && p->base == 8) {
    fe6a:	4a12      	ldr	r2, [pc, #72]	; (feb4 <putchw+0x108>)
    fe6c:	4293      	cmp	r3, r2
    fe6e:	d1eb      	bne.n	fe48 <putchw+0x9c>
        written += putf(putp, '0');
    fe70:	2130      	movs	r1, #48	; 0x30
    fe72:	e7e5      	b.n	fe40 <putchw+0x94>
            written += putf(putp, '0');
    fe74:	2130      	movs	r1, #48	; 0x30
    fe76:	9801      	ldr	r0, [sp, #4]
    fe78:	f7ff ff88 	bl	fd8c <putf>
    fe7c:	3f01      	subs	r7, #1
    fe7e:	182d      	adds	r5, r5, r0
        while (n-- > 0)
    fe80:	2f00      	cmp	r7, #0
    fe82:	dcf7      	bgt.n	fe74 <putchw+0xc8>
    fe84:	43e3      	mvns	r3, r4
    fe86:	17db      	asrs	r3, r3, #31
    fe88:	1e62      	subs	r2, r4, #1
    fe8a:	401c      	ands	r4, r3
    fe8c:	1b14      	subs	r4, r2, r4
    fe8e:	e7df      	b.n	fe50 <putchw+0xa4>
        written += putf(putp, ch);
    fe90:	9801      	ldr	r0, [sp, #4]
    fe92:	f7ff ff7b 	bl	fd8c <putf>
    fe96:	182d      	adds	r5, r5, r0
    fe98:	e7db      	b.n	fe52 <putchw+0xa6>
            written += putf(putp, ' ');
    fe9a:	2120      	movs	r1, #32
    fe9c:	9801      	ldr	r0, [sp, #4]
    fe9e:	f7ff ff75 	bl	fd8c <putf>
    fea2:	3c01      	subs	r4, #1
    fea4:	182d      	adds	r5, r5, r0
    fea6:	e7dc      	b.n	fe62 <putchw+0xb6>
    fea8:	00001002 	.word	0x00001002
    feac:	0008ff00 	.word	0x0008ff00
    feb0:	fffff7fe 	.word	0xfffff7fe
    feb4:	00000802 	.word	0x00000802

0000feb8 <tfp_format>:

    return val;
}

size_t tfp_format(FILE *putp, const char *fmt, va_list va)
{
    feb8:	b5f0      	push	{r4, r5, r6, r7, lr}
    feba:	0005      	movs	r5, r0
    febc:	0016      	movs	r6, r2
    size_t written = 0;
    febe:	2400      	movs	r4, #0
{
    fec0:	b08b      	sub	sp, #44	; 0x2c
    char bf[23];
    char ch;
    char lng;
    void *v;

    p.bf = bf;
    fec2:	ab04      	add	r3, sp, #16
    fec4:	9303      	str	r3, [sp, #12]

    while ((ch = *(fmt++))) {
    fec6:	1c4f      	adds	r7, r1, #1
    fec8:	7809      	ldrb	r1, [r1, #0]
    feca:	2900      	cmp	r1, #0
    fecc:	d102      	bne.n	fed4 <tfp_format+0x1c>
        }
    }
 abort:;
 
 return written;
}
    fece:	0020      	movs	r0, r4
    fed0:	b00b      	add	sp, #44	; 0x2c
    fed2:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (ch != '%') {
    fed4:	2925      	cmp	r1, #37	; 0x25
    fed6:	d003      	beq.n	fee0 <tfp_format+0x28>
                written += putf(putp, ch);
    fed8:	0028      	movs	r0, r5
    feda:	f7ff ff57 	bl	fd8c <putf>
    fede:	e097      	b.n	10010 <tfp_format+0x158>
            p.lz = 0;
    fee0:	2300      	movs	r3, #0
            p.width = 0;
    fee2:	a902      	add	r1, sp, #8
    fee4:	700b      	strb	r3, [r1, #0]
            p.sign = 0;
    fee6:	2102      	movs	r1, #2
            p.uc = 0;
    fee8:	2004      	movs	r0, #4
            p.lz = 0;
    feea:	aa02      	add	r2, sp, #8
    feec:	7053      	strb	r3, [r2, #1]
            p.alt = 0;
    feee:	7892      	ldrb	r2, [r2, #2]
            p.sign = 0;
    fef0:	438a      	bics	r2, r1
            p.left = 0;
    fef2:	3901      	subs	r1, #1
    fef4:	438a      	bics	r2, r1
    fef6:	3107      	adds	r1, #7
            p.uc = 0;
    fef8:	438a      	bics	r2, r1
    fefa:	4382      	bics	r2, r0
    fefc:	a802      	add	r0, sp, #8
    fefe:	7082      	strb	r2, [r0, #2]
                    p.left = 1;
    ff00:	468c      	mov	ip, r1
    while ((ch = *(fmt++))) {
    ff02:	0038      	movs	r0, r7
            while ((ch = *(fmt++))) {
    ff04:	001a      	movs	r2, r3
    ff06:	7801      	ldrb	r1, [r0, #0]
    ff08:	3701      	adds	r7, #1
    ff0a:	2900      	cmp	r1, #0
    ff0c:	d005      	beq.n	ff1a <tfp_format+0x62>
                switch (ch) {
    ff0e:	292d      	cmp	r1, #45	; 0x2d
    ff10:	d032      	beq.n	ff78 <tfp_format+0xc0>
    ff12:	2930      	cmp	r1, #48	; 0x30
    ff14:	d022      	beq.n	ff5c <tfp_format+0xa4>
    ff16:	2923      	cmp	r1, #35	; 0x23
    ff18:	d027      	beq.n	ff6a <tfp_format+0xb2>
    ff1a:	2b00      	cmp	r3, #0
    ff1c:	d001      	beq.n	ff22 <tfp_format+0x6a>
    ff1e:	ab02      	add	r3, sp, #8
    ff20:	705a      	strb	r2, [r3, #1]
            if (ch >= '0' && ch <= '9') {
    ff22:	000b      	movs	r3, r1
    ff24:	3b30      	subs	r3, #48	; 0x30
    ff26:	2b09      	cmp	r3, #9
    ff28:	d83a      	bhi.n	ffa0 <tfp_format+0xe8>
    int num = 0;
    ff2a:	2300      	movs	r3, #0
    ff2c:	9300      	str	r3, [sp, #0]
        num = num * base + digit;
    ff2e:	330a      	adds	r3, #10
    ff30:	0038      	movs	r0, r7
    ff32:	469c      	mov	ip, r3
    if (ch >= '0' && ch <= '9')
    ff34:	000b      	movs	r3, r1
    ff36:	3b30      	subs	r3, #48	; 0x30
    ff38:	b2da      	uxtb	r2, r3
    ff3a:	0007      	movs	r7, r0
    ff3c:	2a09      	cmp	r2, #9
    ff3e:	d905      	bls.n	ff4c <tfp_format+0x94>
    else if (ch >= 'a' && ch <= 'f')
    ff40:	3b31      	subs	r3, #49	; 0x31
    ff42:	2b05      	cmp	r3, #5
    ff44:	d824      	bhi.n	ff90 <tfp_format+0xd8>
        return ch - 'A' + 10;
    ff46:	330a      	adds	r3, #10
        if (digit > base)
    ff48:	2b0a      	cmp	r3, #10
    ff4a:	dc25      	bgt.n	ff98 <tfp_format+0xe0>
        num = num * base + digit;
    ff4c:	4661      	mov	r1, ip
    ff4e:	9a00      	ldr	r2, [sp, #0]
    ff50:	434a      	muls	r2, r1
    ff52:	18d3      	adds	r3, r2, r3
        ch = *p++;
    ff54:	7801      	ldrb	r1, [r0, #0]
        num = num * base + digit;
    ff56:	9300      	str	r3, [sp, #0]
    ff58:	3001      	adds	r0, #1
    ff5a:	e7eb      	b.n	ff34 <tfp_format+0x7c>
                    if (!p.left) {
    ff5c:	4660      	mov	r0, ip
    ff5e:	a902      	add	r1, sp, #8
    ff60:	7889      	ldrb	r1, [r1, #2]
    ff62:	4201      	tst	r1, r0
    ff64:	d011      	beq.n	ff8a <tfp_format+0xd2>
            while ((ch = *(fmt++))) {
    ff66:	0038      	movs	r0, r7
    ff68:	e7cd      	b.n	ff06 <tfp_format+0x4e>
                    p.alt = 1;
    ff6a:	2002      	movs	r0, #2
    ff6c:	a902      	add	r1, sp, #8
    ff6e:	7889      	ldrb	r1, [r1, #2]
    ff70:	4301      	orrs	r1, r0
    ff72:	a802      	add	r0, sp, #8
    ff74:	7081      	strb	r1, [r0, #2]
                    continue;
    ff76:	e7f6      	b.n	ff66 <tfp_format+0xae>
                    p.left = 1;
    ff78:	4662      	mov	r2, ip
    ff7a:	ab02      	add	r3, sp, #8
    ff7c:	789b      	ldrb	r3, [r3, #2]
    ff7e:	4313      	orrs	r3, r2
    ff80:	aa02      	add	r2, sp, #8
    ff82:	7093      	strb	r3, [r2, #2]
                    continue;
    ff84:	2301      	movs	r3, #1
                    p.lz = 0;
    ff86:	2200      	movs	r2, #0
                    continue;
    ff88:	e7ed      	b.n	ff66 <tfp_format+0xae>
    ff8a:	2301      	movs	r3, #1
                        p.lz = 1;
    ff8c:	001a      	movs	r2, r3
    ff8e:	e7ea      	b.n	ff66 <tfp_format+0xae>
    else if (ch >= 'A' && ch <= 'F')
    ff90:	000b      	movs	r3, r1
    ff92:	3b41      	subs	r3, #65	; 0x41
    ff94:	2b05      	cmp	r3, #5
    ff96:	d9d6      	bls.n	ff46 <tfp_format+0x8e>
    *nump = num;
    ff98:	466a      	mov	r2, sp
    ff9a:	7812      	ldrb	r2, [r2, #0]
    ff9c:	ab02      	add	r3, sp, #8
    ff9e:	701a      	strb	r2, [r3, #0]
            lng = 0;
    ffa0:	2300      	movs	r3, #0
            if (ch == 'l') {
    ffa2:	296c      	cmp	r1, #108	; 0x6c
    ffa4:	d104      	bne.n	ffb0 <tfp_format+0xf8>
                ch = *(fmt++);
    ffa6:	7839      	ldrb	r1, [r7, #0]
                if (ch == 'l') {
    ffa8:	296c      	cmp	r1, #108	; 0x6c
    ffaa:	d00e      	beq.n	ffca <tfp_format+0x112>
                ch = *(fmt++);
    ffac:	3701      	adds	r7, #1
                lng = 1;
    ffae:	3301      	adds	r3, #1
            switch (ch) {
    ffb0:	2969      	cmp	r1, #105	; 0x69
    ffb2:	d012      	beq.n	ffda <tfp_format+0x122>
    ffb4:	d82e      	bhi.n	10014 <tfp_format+0x15c>
    ffb6:	2958      	cmp	r1, #88	; 0x58
    ffb8:	d059      	beq.n	1006e <tfp_format+0x1b6>
    ffba:	d80a      	bhi.n	ffd2 <tfp_format+0x11a>
    ffbc:	2900      	cmp	r1, #0
    ffbe:	d100      	bne.n	ffc2 <tfp_format+0x10a>
    ffc0:	e785      	b.n	fece <tfp_format+0x16>
    ffc2:	2925      	cmp	r1, #37	; 0x25
    ffc4:	d088      	beq.n	fed8 <tfp_format+0x20>
                v = va_arg(va, void *);
    ffc6:	0039      	movs	r1, r7
    ffc8:	e77d      	b.n	fec6 <tfp_format+0xe>
                    ch = *(fmt++);
    ffca:	7879      	ldrb	r1, [r7, #1]
                    lng = 2;
    ffcc:	2302      	movs	r3, #2
                    ch = *(fmt++);
    ffce:	3702      	adds	r7, #2
    ffd0:	e7ee      	b.n	ffb0 <tfp_format+0xf8>
            switch (ch) {
    ffd2:	2963      	cmp	r1, #99	; 0x63
    ffd4:	d068      	beq.n	100a8 <tfp_format+0x1f0>
    ffd6:	2964      	cmp	r1, #100	; 0x64
    ffd8:	d1f5      	bne.n	ffc6 <tfp_format+0x10e>
                p.base = 10;
    ffda:	220a      	movs	r2, #10
    ffdc:	a902      	add	r1, sp, #8
    ffde:	70ca      	strb	r2, [r1, #3]
    ffe0:	6832      	ldr	r2, [r6, #0]
    switch (lng) {
    ffe2:	2b01      	cmp	r3, #1
    ffe4:	d856      	bhi.n	10094 <tfp_format+0x1dc>
            val = va_arg(*va, long);
    ffe6:	3604      	adds	r6, #4
    ffe8:	17d3      	asrs	r3, r2, #31
                i2a(intarg(lng, 1, &va), &p);
    ffea:	0010      	movs	r0, r2
    ffec:	1e19      	subs	r1, r3, #0
    if (num < 0) {
    ffee:	da08      	bge.n	10002 <tfp_format+0x14a>
        num = -num;
    fff0:	2100      	movs	r1, #0
    fff2:	4250      	negs	r0, r2
    fff4:	4199      	sbcs	r1, r3
        p->sign = 1;
    fff6:	2201      	movs	r2, #1
    fff8:	ab02      	add	r3, sp, #8
    fffa:	789b      	ldrb	r3, [r3, #2]
    fffc:	4313      	orrs	r3, r2
    fffe:	aa02      	add	r2, sp, #8
   10000:	7093      	strb	r3, [r2, #2]
                ui2a(intarg(lng, 0, &va), &p);
   10002:	aa02      	add	r2, sp, #8
   10004:	f7ff fe68 	bl	fcd8 <ui2a>
                written += putchw(putp, &p);
   10008:	a902      	add	r1, sp, #8
   1000a:	0028      	movs	r0, r5
   1000c:	f7ff fece 	bl	fdac <putchw>
                written += putf(putp, ch);
   10010:	1824      	adds	r4, r4, r0
                break;
   10012:	e7d8      	b.n	ffc6 <tfp_format+0x10e>
            switch (ch) {
   10014:	2973      	cmp	r1, #115	; 0x73
   10016:	d051      	beq.n	100bc <tfp_format+0x204>
   10018:	d824      	bhi.n	10064 <tfp_format+0x1ac>
   1001a:	296f      	cmp	r1, #111	; 0x6f
   1001c:	d03d      	beq.n	1009a <tfp_format+0x1e2>
   1001e:	2970      	cmp	r1, #112	; 0x70
   10020:	d1d1      	bne.n	ffc6 <tfp_format+0x10e>
                v = va_arg(va, void *);
   10022:	1d33      	adds	r3, r6, #4
   10024:	9301      	str	r3, [sp, #4]
                p.base = 16;
   10026:	2310      	movs	r3, #16
                v = va_arg(va, void *);
   10028:	6830      	ldr	r0, [r6, #0]
                p.base = 16;
   1002a:	aa02      	add	r2, sp, #8
                ui2a((uintptr_t)v, &p);
   1002c:	2100      	movs	r1, #0
                p.base = 16;
   1002e:	70d3      	strb	r3, [r2, #3]
                ui2a((uintptr_t)v, &p);
   10030:	f7ff fe52 	bl	fcd8 <ui2a>
                p.width = 2 * sizeof(void*);
   10034:	2384      	movs	r3, #132	; 0x84
   10036:	aa02      	add	r2, sp, #8
   10038:	005b      	lsls	r3, r3, #1
   1003a:	8013      	strh	r3, [r2, #0]
                written += putf(putp, '0');
   1003c:	2130      	movs	r1, #48	; 0x30
   1003e:	0028      	movs	r0, r5
   10040:	f7ff fea4 	bl	fd8c <putf>
                written += putf(putp, 'x');
   10044:	2178      	movs	r1, #120	; 0x78
                written += putf(putp, '0');
   10046:	9000      	str	r0, [sp, #0]
                written += putf(putp, 'x');
   10048:	0028      	movs	r0, r5
   1004a:	f7ff fe9f 	bl	fd8c <putf>
                written += putchw(putp, &p);
   1004e:	a902      	add	r1, sp, #8
                written += putf(putp, 'x');
   10050:	0006      	movs	r6, r0
                written += putchw(putp, &p);
   10052:	0028      	movs	r0, r5
   10054:	f7ff feaa 	bl	fdac <putchw>
   10058:	9b00      	ldr	r3, [sp, #0]
   1005a:	1824      	adds	r4, r4, r0
   1005c:	18e4      	adds	r4, r4, r3
   1005e:	1934      	adds	r4, r6, r4
                v = va_arg(va, void *);
   10060:	9e01      	ldr	r6, [sp, #4]
                break;
   10062:	e7b0      	b.n	ffc6 <tfp_format+0x10e>
                p.base = 10;
   10064:	220a      	movs	r2, #10
            switch (ch) {
   10066:	2975      	cmp	r1, #117	; 0x75
   10068:	d018      	beq.n	1009c <tfp_format+0x1e4>
   1006a:	2978      	cmp	r1, #120	; 0x78
   1006c:	d1ab      	bne.n	ffc6 <tfp_format+0x10e>
                p.base = 16;
   1006e:	2210      	movs	r2, #16
   10070:	a802      	add	r0, sp, #8
                p.uc = (ch == 'X');
   10072:	3958      	subs	r1, #88	; 0x58
                p.base = 16;
   10074:	70c2      	strb	r2, [r0, #3]
                p.uc = (ch == 'X');
   10076:	424a      	negs	r2, r1
   10078:	4151      	adcs	r1, r2
   1007a:	008a      	lsls	r2, r1, #2
   1007c:	7881      	ldrb	r1, [r0, #2]
   1007e:	2004      	movs	r0, #4
   10080:	4381      	bics	r1, r0
   10082:	4311      	orrs	r1, r2
   10084:	aa02      	add	r2, sp, #8
   10086:	7091      	strb	r1, [r2, #2]
   10088:	6830      	ldr	r0, [r6, #0]
    switch (lng) {
   1008a:	2b01      	cmp	r3, #1
   1008c:	d809      	bhi.n	100a2 <tfp_format+0x1ea>
   1008e:	2100      	movs	r1, #0
            val = va_arg(*va, unsigned long);
   10090:	3604      	adds	r6, #4
   10092:	e7b6      	b.n	10002 <tfp_format+0x14a>
        val |= (unsigned long long)(va_arg(*va, unsigned long)) << 32;
   10094:	6873      	ldr	r3, [r6, #4]
   10096:	3608      	adds	r6, #8
   10098:	e7a7      	b.n	ffea <tfp_format+0x132>
                p.base = 8;
   1009a:	2208      	movs	r2, #8
   1009c:	a902      	add	r1, sp, #8
   1009e:	70ca      	strb	r2, [r1, #3]
   100a0:	e7f2      	b.n	10088 <tfp_format+0x1d0>
        val |= (unsigned long long)(va_arg(*va, unsigned long)) << 32;
   100a2:	6871      	ldr	r1, [r6, #4]
   100a4:	3608      	adds	r6, #8
   100a6:	e7ac      	b.n	10002 <tfp_format+0x14a>
                written += putf(putp, (char)(va_arg(va, int)));
   100a8:	6831      	ldr	r1, [r6, #0]
   100aa:	1d33      	adds	r3, r6, #4
   100ac:	b2c9      	uxtb	r1, r1
   100ae:	0028      	movs	r0, r5
   100b0:	9300      	str	r3, [sp, #0]
   100b2:	f7ff fe6b 	bl	fd8c <putf>
   100b6:	1824      	adds	r4, r4, r0
                p.bf = va_arg(va, char *);
   100b8:	9e00      	ldr	r6, [sp, #0]
                break;
   100ba:	e784      	b.n	ffc6 <tfp_format+0x10e>
                p.bf = va_arg(va, char *);
   100bc:	1d33      	adds	r3, r6, #4
   100be:	9300      	str	r3, [sp, #0]
   100c0:	6833      	ldr	r3, [r6, #0]
                written += putchw(putp, &p);
   100c2:	a902      	add	r1, sp, #8
   100c4:	0028      	movs	r0, r5
                p.bf = va_arg(va, char *);
   100c6:	9301      	str	r3, [sp, #4]
   100c8:	9303      	str	r3, [sp, #12]
                written += putchw(putp, &p);
   100ca:	f7ff fe6f 	bl	fdac <putchw>
                p.bf = bf;
   100ce:	ab04      	add	r3, sp, #16
                written += putchw(putp, &p);
   100d0:	1824      	adds	r4, r4, r0
                p.bf = bf;
   100d2:	9303      	str	r3, [sp, #12]
   100d4:	e7f0      	b.n	100b8 <tfp_format+0x200>

000100d6 <vfprintf>:

int vfprintf(FILE *f, const char *fmt, va_list va)
{
   100d6:	b510      	push	{r4, lr}
    return tfp_format(f, fmt, va);
   100d8:	f7ff feee 	bl	feb8 <tfp_format>
}
   100dc:	bd10      	pop	{r4, pc}
	...

000100e0 <printf>:
    va_end(va);
    return rv;
}

int printf(const char *fmt, ...)
{
   100e0:	b40f      	push	{r0, r1, r2, r3}
   100e2:	b507      	push	{r0, r1, r2, lr}
    va_list va;
    va_start(va, fmt);
    int rv = vfprintf(stdout, fmt, va);
   100e4:	4b05      	ldr	r3, [pc, #20]	; (100fc <printf+0x1c>)
{
   100e6:	aa04      	add	r2, sp, #16
   100e8:	ca02      	ldmia	r2!, {r1}
    int rv = vfprintf(stdout, fmt, va);
   100ea:	6818      	ldr	r0, [r3, #0]
    va_start(va, fmt);
   100ec:	9201      	str	r2, [sp, #4]
    return tfp_format(f, fmt, va);
   100ee:	f7ff fee3 	bl	feb8 <tfp_format>
    va_end(va);
    return rv;
}
   100f2:	b003      	add	sp, #12
   100f4:	bc08      	pop	{r3}
   100f6:	b004      	add	sp, #16
   100f8:	4718      	bx	r3
   100fa:	46c0      	nop			; (mov r8, r8)
   100fc:	000109d4 	.word	0x000109d4

00010100 <vprintf>:

#include <stdio.h>
#include <stdarg.h>

int vprintf(const char *format, va_list ap)
{
   10100:	b510      	push	{r4, lr}
	return vfprintf(stdout, format, ap);
   10102:	4b03      	ldr	r3, [pc, #12]	; (10110 <vprintf+0x10>)
{
   10104:	000a      	movs	r2, r1
	return vfprintf(stdout, format, ap);
   10106:	0001      	movs	r1, r0
   10108:	6818      	ldr	r0, [r3, #0]
   1010a:	f7ff ffe4 	bl	100d6 <vfprintf>
}
   1010e:	bd10      	pop	{r4, pc}
   10110:	000109d4 	.word	0x000109d4

00010114 <stdin_read>:

static size_t
stdin_read(FILE *fp, char *bp, size_t n)
{
    return 0;
}
   10114:	2000      	movs	r0, #0
   10116:	4770      	bx	lr

00010118 <stdout_write>:

static size_t
stdout_write(FILE *fp, const char *bp, size_t n)
{
   10118:	b510      	push	{r4, lr}
   1011a:	0014      	movs	r4, r2
   1011c:	0008      	movs	r0, r1
    console_write(bp, n);
   1011e:	0011      	movs	r1, r2
   10120:	f7fd fd00 	bl	db24 <console_write>
    return n;
}
   10124:	0020      	movs	r0, r4
   10126:	bd10      	pop	{r4, pc}

00010128 <flash_area_open>:
flash_area_open(uint8_t id, const struct flash_area **fap)
{
    const struct flash_area *area;
    int i;

    if (flash_map == NULL) {
   10128:	4b0d      	ldr	r3, [pc, #52]	; (10160 <flash_area_open+0x38>)
{
   1012a:	b570      	push	{r4, r5, r6, lr}
    if (flash_map == NULL) {
   1012c:	681b      	ldr	r3, [r3, #0]
   1012e:	2b00      	cmp	r3, #0
   10130:	d013      	beq.n	1015a <flash_area_open+0x32>
        return SYS_EACCES;
    }

    for (i = 0; i < flash_map_entries; i++) {
   10132:	4a0c      	ldr	r2, [pc, #48]	; (10164 <flash_area_open+0x3c>)
   10134:	6814      	ldr	r4, [r2, #0]
   10136:	2200      	movs	r2, #0
   10138:	4294      	cmp	r4, r2
   1013a:	dc02      	bgt.n	10142 <flash_area_open+0x1a>
            *fap = area;
            return 0;
        }
    }

    return SYS_ENOENT;
   1013c:	2004      	movs	r0, #4
        return SYS_EACCES;
   1013e:	4240      	negs	r0, r0
   10140:	e008      	b.n	10154 <flash_area_open+0x2c>
        area = flash_map + i;
   10142:	001d      	movs	r5, r3
   10144:	330c      	adds	r3, #12
        if (area->fa_id == id) {
   10146:	001e      	movs	r6, r3
   10148:	3e0c      	subs	r6, #12
   1014a:	7836      	ldrb	r6, [r6, #0]
   1014c:	4286      	cmp	r6, r0
   1014e:	d102      	bne.n	10156 <flash_area_open+0x2e>
            return 0;
   10150:	2000      	movs	r0, #0
            *fap = area;
   10152:	600d      	str	r5, [r1, #0]
}
   10154:	bd70      	pop	{r4, r5, r6, pc}
    for (i = 0; i < flash_map_entries; i++) {
   10156:	3201      	adds	r2, #1
   10158:	e7ee      	b.n	10138 <flash_area_open+0x10>
        return SYS_EACCES;
   1015a:	2007      	movs	r0, #7
   1015c:	e7ef      	b.n	1013e <flash_area_open+0x16>
   1015e:	46c0      	nop			; (mov r8, r8)
   10160:	20002518 	.word	0x20002518
   10164:	2000251c 	.word	0x2000251c

00010168 <flash_area_close>:

void
flash_area_close(const struct flash_area *fa)
{
    /* nothing to do for now */
}
   10168:	4770      	bx	lr

0001016a <flash_area_read>:
}

int
flash_area_read(const struct flash_area *fa, uint32_t off, void *dst,
    uint32_t len)
{
   1016a:	b570      	push	{r4, r5, r6, lr}
    if (off > fa->fa_size || off + len > fa->fa_size) {
   1016c:	6884      	ldr	r4, [r0, #8]
   1016e:	428c      	cmp	r4, r1
   10170:	d308      	bcc.n	10184 <flash_area_read+0x1a>
   10172:	18cd      	adds	r5, r1, r3
   10174:	42ac      	cmp	r4, r5
   10176:	d305      	bcc.n	10184 <flash_area_read+0x1a>
        return -1;
    }
    return hal_flash_read(fa->fa_device_id, fa->fa_off + off, dst, len);
   10178:	6844      	ldr	r4, [r0, #4]
   1017a:	7840      	ldrb	r0, [r0, #1]
   1017c:	1909      	adds	r1, r1, r4
   1017e:	f000 f939 	bl	103f4 <hal_flash_read>
}
   10182:	bd70      	pop	{r4, r5, r6, pc}
        return -1;
   10184:	2001      	movs	r0, #1
   10186:	4240      	negs	r0, r0
   10188:	e7fb      	b.n	10182 <flash_area_read+0x18>
	...

0001018c <flash_map_init>:
    }
}

void
flash_map_init(void)
{
   1018c:	b5f0      	push	{r4, r5, r6, r7, lr}

    int num_areas;
    int rc;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
   1018e:	4b24      	ldr	r3, [pc, #144]	; (10220 <flash_map_init+0x94>)
{
   10190:	b089      	sub	sp, #36	; 0x24
    SYSINIT_ASSERT_ACTIVE();
   10192:	7818      	ldrb	r0, [r3, #0]
   10194:	2800      	cmp	r0, #0
   10196:	d104      	bne.n	101a2 <flash_map_init+0x16>
   10198:	0003      	movs	r3, r0
   1019a:	0002      	movs	r2, r0
   1019c:	0001      	movs	r1, r0
   1019e:	f7fc fbcb 	bl	c938 <__assert_func>

    rc = hal_flash_init();
   101a2:	f000 f912 	bl	103ca <hal_flash_init>
    SYSINIT_PANIC_ASSERT(rc == 0);
   101a6:	2800      	cmp	r0, #0
   101a8:	d007      	beq.n	101ba <flash_map_init+0x2e>
   101aa:	2000      	movs	r0, #0
   101ac:	4b1d      	ldr	r3, [pc, #116]	; (10224 <flash_map_init+0x98>)
   101ae:	9000      	str	r0, [sp, #0]
   101b0:	681c      	ldr	r4, [r3, #0]
   101b2:	0002      	movs	r2, r0
   101b4:	0003      	movs	r3, r0
   101b6:	0001      	movs	r1, r0
   101b8:	47a0      	blx	r4
     *    In particular, a FLASH_AREA_BOOTLOADER entry is required, as the meta
     *    region is located at the end of the boot loader area.
     * 2. If we fail to read the flash map from the meta region, the system
     *    continues to use the default flash map.
     */
    flash_map = sysflash_map_dflt;
   101ba:	4b1b      	ldr	r3, [pc, #108]	; (10228 <flash_map_init+0x9c>)
   101bc:	4f1b      	ldr	r7, [pc, #108]	; (1022c <flash_map_init+0xa0>)
    flash_map_entries = sizeof sysflash_map_dflt / sizeof sysflash_map_dflt[0];
   101be:	4e1c      	ldr	r6, [pc, #112]	; (10230 <flash_map_init+0xa4>)
    flash_map = sysflash_map_dflt;
   101c0:	603b      	str	r3, [r7, #0]
    flash_map_entries = sizeof sysflash_map_dflt / sizeof sysflash_map_dflt[0];
   101c2:	2306      	movs	r3, #6
   101c4:	6033      	str	r3, [r6, #0]
    off = 0;
   101c6:	2300      	movs	r3, #0
   101c8:	9304      	str	r3, [sp, #16]
    rc = mfg_init();
   101ca:	f000 f89b 	bl	10304 <mfg_init>
   101ce:	1e04      	subs	r4, r0, #0
    if (rc != 0) {
   101d0:	d108      	bne.n	101e4 <flash_map_init+0x58>
        rc = mfg_next_tlv_with_type(&tlv, &off, MFG_META_TLV_TYPE_FLASH_AREA);
   101d2:	2202      	movs	r2, #2
   101d4:	a904      	add	r1, sp, #16
   101d6:	a803      	add	r0, sp, #12
   101d8:	f000 f864 	bl	102a4 <mfg_next_tlv_with_type>
        switch (rc) {
   101dc:	2800      	cmp	r0, #0
   101de:	d003      	beq.n	101e8 <flash_map_init+0x5c>
   101e0:	2803      	cmp	r0, #3
   101e2:	d019      	beq.n	10218 <flash_map_init+0x8c>
                            mfg_areas, &num_areas);
    if (rc == 0) {
        flash_map = mfg_areas;
        flash_map_entries = num_areas;
    }
}
   101e4:	b009      	add	sp, #36	; 0x24
   101e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        rc = mfg_read_tlv_flash_area(&tlv, off, &meta_flash_area);
   101e8:	ad05      	add	r5, sp, #20
   101ea:	002a      	movs	r2, r5
   101ec:	9904      	ldr	r1, [sp, #16]
   101ee:	a803      	add	r0, sp, #12
   101f0:	f000 f866 	bl	102c0 <mfg_read_tlv_flash_area>
        if (rc != 0) {
   101f4:	2800      	cmp	r0, #0
   101f6:	d1f5      	bne.n	101e4 <flash_map_init+0x58>
   101f8:	220c      	movs	r2, #12
   101fa:	4362      	muls	r2, r4
        fap->fa_id = meta_flash_area.area_id;
   101fc:	4b0d      	ldr	r3, [pc, #52]	; (10234 <flash_map_init+0xa8>)
   101fe:	7829      	ldrb	r1, [r5, #0]
        (*out_num_areas)++;
   10200:	3401      	adds	r4, #1
        fap->fa_id = meta_flash_area.area_id;
   10202:	54d1      	strb	r1, [r2, r3]
   10204:	189b      	adds	r3, r3, r2
        fap->fa_device_id = meta_flash_area.device_id;
   10206:	786a      	ldrb	r2, [r5, #1]
   10208:	705a      	strb	r2, [r3, #1]
        fap->fa_off = meta_flash_area.offset;
   1020a:	686a      	ldr	r2, [r5, #4]
   1020c:	605a      	str	r2, [r3, #4]
        fap->fa_size = meta_flash_area.size;
   1020e:	68aa      	ldr	r2, [r5, #8]
   10210:	609a      	str	r2, [r3, #8]
        if (*out_num_areas >= max_areas) {
   10212:	2c0a      	cmp	r4, #10
   10214:	d1dd      	bne.n	101d2 <flash_map_init+0x46>
   10216:	e7e5      	b.n	101e4 <flash_map_init+0x58>
        flash_map = mfg_areas;
   10218:	4b06      	ldr	r3, [pc, #24]	; (10234 <flash_map_init+0xa8>)
        flash_map_entries = num_areas;
   1021a:	6034      	str	r4, [r6, #0]
        flash_map = mfg_areas;
   1021c:	603b      	str	r3, [r7, #0]
}
   1021e:	e7e1      	b.n	101e4 <flash_map_init+0x58>
   10220:	200024d0 	.word	0x200024d0
   10224:	200000e0 	.word	0x200000e0
   10228:	000109d8 	.word	0x000109d8
   1022c:	20002518 	.word	0x20002518
   10230:	2000251c 	.word	0x2000251c
   10234:	20002288 	.word	0x20002288

00010238 <mfg_next_tlv>:
 *                                  read;
 *                              Other MFG error code on failure.
 */
int
mfg_next_tlv(struct mfg_meta_tlv *tlv, uint32_t *off)
{
   10238:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    const struct flash_area *fap;
    int rc;

    if (!mfg_state.valid) {
        return MFG_EUNINIT;
   1023a:	2401      	movs	r4, #1
    if (!mfg_state.valid) {
   1023c:	4f18      	ldr	r7, [pc, #96]	; (102a0 <mfg_next_tlv+0x68>)
{
   1023e:	0006      	movs	r6, r0
    if (!mfg_state.valid) {
   10240:	783b      	ldrb	r3, [r7, #0]
{
   10242:	000d      	movs	r5, r1
    if (!mfg_state.valid) {
   10244:	4223      	tst	r3, r4
   10246:	d009      	beq.n	1025c <mfg_next_tlv+0x24>
    }

    rc = flash_area_open(FLASH_AREA_BOOTLOADER, &fap);
   10248:	a901      	add	r1, sp, #4
   1024a:	2000      	movs	r0, #0
   1024c:	f7ff ff6c 	bl	10128 <flash_area_open>
    if (rc != 0) {
   10250:	2800      	cmp	r0, #0
   10252:	d005      	beq.n	10260 <mfg_next_tlv+0x28>
        rc = MFG_EFLASH;
   10254:	2404      	movs	r4, #4
    }

    rc = 0;

done:
    flash_area_close(fap);
   10256:	9801      	ldr	r0, [sp, #4]
   10258:	f7ff ff86 	bl	10168 <flash_area_close>
    return rc;
}
   1025c:	0020      	movs	r0, r4
   1025e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
    if (*off == 0) {
   10260:	682a      	ldr	r2, [r5, #0]
   10262:	2a00      	cmp	r2, #0
   10264:	d117      	bne.n	10296 <mfg_next_tlv+0x5e>
        *off = mfg_state.off + MFG_META_HEADER_SZ;
   10266:	687b      	ldr	r3, [r7, #4]
   10268:	3304      	adds	r3, #4
        *off += MFG_META_TLV_SZ + tlv->size;
   1026a:	602b      	str	r3, [r5, #0]
    if (*off + MFG_META_FOOTER_SZ >= fap->fa_size) {
   1026c:	9f01      	ldr	r7, [sp, #4]
   1026e:	682b      	ldr	r3, [r5, #0]
   10270:	68ba      	ldr	r2, [r7, #8]
   10272:	3308      	adds	r3, #8
        return MFG_EDONE;
   10274:	2403      	movs	r4, #3
    if (*off + MFG_META_FOOTER_SZ >= fap->fa_size) {
   10276:	4293      	cmp	r3, r2
   10278:	d2f0      	bcs.n	1025c <mfg_next_tlv+0x24>
    memset(tlv, 0, sizeof *tlv);
   1027a:	2202      	movs	r2, #2
   1027c:	2100      	movs	r1, #0
   1027e:	0030      	movs	r0, r6
   10280:	f7fd fb16 	bl	d8b0 <memset>
    rc = flash_area_read(fap, *off, tlv, MFG_META_TLV_SZ);
   10284:	2302      	movs	r3, #2
   10286:	0032      	movs	r2, r6
   10288:	6829      	ldr	r1, [r5, #0]
   1028a:	0038      	movs	r0, r7
   1028c:	f7ff ff6d 	bl	1016a <flash_area_read>
   10290:	1e04      	subs	r4, r0, #0
    if (rc != 0) {
   10292:	d1df      	bne.n	10254 <mfg_next_tlv+0x1c>
   10294:	e7df      	b.n	10256 <mfg_next_tlv+0x1e>
        *off += MFG_META_TLV_SZ + tlv->size;
   10296:	7873      	ldrb	r3, [r6, #1]
   10298:	189b      	adds	r3, r3, r2
   1029a:	3302      	adds	r3, #2
   1029c:	e7e5      	b.n	1026a <mfg_next_tlv+0x32>
   1029e:	46c0      	nop			; (mov r8, r8)
   102a0:	20002520 	.word	0x20002520

000102a4 <mfg_next_tlv_with_type>:
 *                                  the specified type to read;
 *                              Other MFG error code on failure.
 */
int
mfg_next_tlv_with_type(struct mfg_meta_tlv *tlv, uint32_t *off, uint8_t type)
{
   102a4:	b570      	push	{r4, r5, r6, lr}
   102a6:	0004      	movs	r4, r0
   102a8:	000e      	movs	r6, r1
   102aa:	0015      	movs	r5, r2
    int rc;

    while (1) {
        rc = mfg_next_tlv(tlv, off);
   102ac:	0031      	movs	r1, r6
   102ae:	0020      	movs	r0, r4
   102b0:	f7ff ffc2 	bl	10238 <mfg_next_tlv>
        if (rc != 0) {
   102b4:	2800      	cmp	r0, #0
   102b6:	d102      	bne.n	102be <mfg_next_tlv_with_type+0x1a>
            break;
        }

        if (tlv->type == type) {
   102b8:	7823      	ldrb	r3, [r4, #0]
   102ba:	42ab      	cmp	r3, r5
   102bc:	d1f6      	bne.n	102ac <mfg_next_tlv_with_type+0x8>

        /* Proceed to next TLV. */
    }

    return rc;
}
   102be:	bd70      	pop	{r4, r5, r6, pc}

000102c0 <mfg_read_tlv_flash_area>:
 * @return                      0 on success; MFG error code on failure.
 */
int
mfg_read_tlv_flash_area(const struct mfg_meta_tlv *tlv, uint32_t off,
                        struct mfg_meta_flash_area *out_mfa)
{
   102c0:	b573      	push	{r0, r1, r4, r5, r6, lr}
   102c2:	0006      	movs	r6, r0
   102c4:	000c      	movs	r4, r1
    const struct flash_area *fap;
    int read_sz;
    int rc;

    rc = flash_area_open(FLASH_AREA_BOOTLOADER, &fap);
   102c6:	2000      	movs	r0, #0
   102c8:	a901      	add	r1, sp, #4
{
   102ca:	0015      	movs	r5, r2
    rc = flash_area_open(FLASH_AREA_BOOTLOADER, &fap);
   102cc:	f7ff ff2c 	bl	10128 <flash_area_open>
   102d0:	1e01      	subs	r1, r0, #0
    if (rc != 0) {
   102d2:	d005      	beq.n	102e0 <mfg_read_tlv_flash_area+0x20>
        rc = MFG_EFLASH;
   102d4:	2404      	movs	r4, #4
    }

    rc = 0;

done:
    flash_area_close(fap);
   102d6:	9801      	ldr	r0, [sp, #4]
   102d8:	f7ff ff46 	bl	10168 <flash_area_close>
    return rc;
}
   102dc:	0020      	movs	r0, r4
   102de:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
    memset(out_mfa, 0, sizeof *out_mfa);
   102e0:	220c      	movs	r2, #12
   102e2:	0028      	movs	r0, r5
   102e4:	f7fd fae4 	bl	d8b0 <memset>
    read_sz = min(MFG_META_FLASH_AREA_SZ, tlv->size);
   102e8:	7872      	ldrb	r2, [r6, #1]
   102ea:	1c13      	adds	r3, r2, #0
   102ec:	2a0c      	cmp	r2, #12
   102ee:	d900      	bls.n	102f2 <mfg_read_tlv_flash_area+0x32>
   102f0:	230c      	movs	r3, #12
    rc = flash_area_read(fap, off + MFG_META_TLV_SZ, out_mfa, read_sz);
   102f2:	1ca1      	adds	r1, r4, #2
   102f4:	b2db      	uxtb	r3, r3
   102f6:	002a      	movs	r2, r5
   102f8:	9801      	ldr	r0, [sp, #4]
   102fa:	f7ff ff36 	bl	1016a <flash_area_read>
   102fe:	1e04      	subs	r4, r0, #0
    if (rc != 0) {
   10300:	d0e9      	beq.n	102d6 <mfg_read_tlv_flash_area+0x16>
   10302:	e7e7      	b.n	102d4 <mfg_read_tlv_flash_area+0x14>

00010304 <mfg_init>:
 *
 * @return                      0 on success; MFG error code on failure.
 */
int
mfg_init(void)
{
   10304:	b5f0      	push	{r4, r5, r6, r7, lr}
    struct mfg_meta_footer ftr;
    uint16_t off;
    int rc;

    /* Ensure this function only gets called by sysinit. */
    SYSINIT_ASSERT_ACTIVE();
   10306:	4b1e      	ldr	r3, [pc, #120]	; (10380 <mfg_init+0x7c>)
{
   10308:	b085      	sub	sp, #20
    SYSINIT_ASSERT_ACTIVE();
   1030a:	7818      	ldrb	r0, [r3, #0]
   1030c:	2800      	cmp	r0, #0
   1030e:	d104      	bne.n	1031a <mfg_init+0x16>
   10310:	0003      	movs	r3, r0
   10312:	0002      	movs	r2, r0
   10314:	0001      	movs	r1, r0
   10316:	f7fc fb0f 	bl	c938 <__assert_func>

    if (mfg_state.valid) {
   1031a:	2601      	movs	r6, #1
   1031c:	4d19      	ldr	r5, [pc, #100]	; (10384 <mfg_init+0x80>)
        /* Already initialized. */
        return 0;
   1031e:	2400      	movs	r4, #0
    if (mfg_state.valid) {
   10320:	782b      	ldrb	r3, [r5, #0]
   10322:	4233      	tst	r3, r6
   10324:	d10b      	bne.n	1033e <mfg_init+0x3a>
    }

    mfg_state.valid = 0;
   10326:	43b3      	bics	r3, r6

    rc = flash_area_open(FLASH_AREA_BOOTLOADER, &fap);
   10328:	a901      	add	r1, sp, #4
   1032a:	0020      	movs	r0, r4
    mfg_state.valid = 0;
   1032c:	702b      	strb	r3, [r5, #0]
    rc = flash_area_open(FLASH_AREA_BOOTLOADER, &fap);
   1032e:	f7ff fefb 	bl	10128 <flash_area_open>
    if (rc != 0) {
   10332:	42a0      	cmp	r0, r4
   10334:	d006      	beq.n	10344 <mfg_init+0x40>
        rc = MFG_EFLASH;
   10336:	2404      	movs	r4, #4
    mfg_state.size = ftr.size;

    rc = 0;

done:
    flash_area_close(fap);
   10338:	9801      	ldr	r0, [sp, #4]
   1033a:	f7ff ff15 	bl	10168 <flash_area_close>
    return rc;
}
   1033e:	0020      	movs	r0, r4
   10340:	b005      	add	sp, #20
   10342:	bdf0      	pop	{r4, r5, r6, r7, pc}
    off = fap->fa_size - sizeof ftr;
   10344:	9801      	ldr	r0, [sp, #4]
    rc = flash_area_read(fap, off, &ftr, sizeof ftr);
   10346:	af02      	add	r7, sp, #8
    off = fap->fa_size - sizeof ftr;
   10348:	6881      	ldr	r1, [r0, #8]
    rc = flash_area_read(fap, off, &ftr, sizeof ftr);
   1034a:	2308      	movs	r3, #8
    off = fap->fa_size - sizeof ftr;
   1034c:	3908      	subs	r1, #8
    rc = flash_area_read(fap, off, &ftr, sizeof ftr);
   1034e:	b289      	uxth	r1, r1
   10350:	003a      	movs	r2, r7
   10352:	f7ff ff0a 	bl	1016a <flash_area_read>
   10356:	1e04      	subs	r4, r0, #0
    if (rc != 0) {
   10358:	d1ed      	bne.n	10336 <mfg_init+0x32>
    if (ftr.magic != MFG_META_MAGIC) {
   1035a:	4b0b      	ldr	r3, [pc, #44]	; (10388 <mfg_init+0x84>)
   1035c:	687a      	ldr	r2, [r7, #4]
   1035e:	429a      	cmp	r2, r3
   10360:	d10b      	bne.n	1037a <mfg_init+0x76>
    if (ftr.size > fap->fa_size) {
   10362:	9b01      	ldr	r3, [sp, #4]
   10364:	883a      	ldrh	r2, [r7, #0]
   10366:	689b      	ldr	r3, [r3, #8]
   10368:	429a      	cmp	r2, r3
   1036a:	d806      	bhi.n	1037a <mfg_init+0x76>
    mfg_state.valid = 1;
   1036c:	7829      	ldrb	r1, [r5, #0]
    mfg_state.off = fap->fa_size - ftr.size;
   1036e:	1a9b      	subs	r3, r3, r2
    mfg_state.valid = 1;
   10370:	430e      	orrs	r6, r1
   10372:	702e      	strb	r6, [r5, #0]
    mfg_state.off = fap->fa_size - ftr.size;
   10374:	606b      	str	r3, [r5, #4]
    mfg_state.size = ftr.size;
   10376:	60aa      	str	r2, [r5, #8]
   10378:	e7de      	b.n	10338 <mfg_init+0x34>
        rc = MFG_EBADDATA;
   1037a:	2402      	movs	r4, #2
   1037c:	e7dc      	b.n	10338 <mfg_init+0x34>
   1037e:	46c0      	nop			; (mov r8, r8)
   10380:	200024d0 	.word	0x200024d0
   10384:	20002520 	.word	0x20002520
   10388:	3bb2a269 	.word	0x3bb2a269

0001038c <_sbrk>:
void *
_sbrk(int incr)
{
    void *prev_brk;

    if (incr < 0) {
   1038c:	2800      	cmp	r0, #0
   1038e:	db09      	blt.n	103a4 <_sbrk+0x18>
        /* Returning memory to the heap. */
        prev_brk = (void *)-1;
    } else {
        /* Allocating memory from the heap. */
        if (&_user_heap_end - _brk >= incr) {
   10390:	4906      	ldr	r1, [pc, #24]	; (103ac <_sbrk+0x20>)
   10392:	4a07      	ldr	r2, [pc, #28]	; (103b0 <_sbrk+0x24>)
   10394:	680b      	ldr	r3, [r1, #0]
   10396:	1ad2      	subs	r2, r2, r3
   10398:	4282      	cmp	r2, r0
   1039a:	db03      	blt.n	103a4 <_sbrk+0x18>
            prev_brk = _brk;
            _brk += incr;
   1039c:	1818      	adds	r0, r3, r0
   1039e:	6008      	str	r0, [r1, #0]
            prev_brk = (void *)-1;
        }
    }

    return prev_brk;
}
   103a0:	0018      	movs	r0, r3
   103a2:	4770      	bx	lr
        prev_brk = (void *)-1;
   103a4:	2301      	movs	r3, #1
   103a6:	425b      	negs	r3, r3
    return prev_brk;
   103a8:	e7fa      	b.n	103a0 <_sbrk+0x14>
   103aa:	46c0      	nop			; (mov r8, r8)
   103ac:	20000124 	.word	0x20000124
   103b0:	20007c00 	.word	0x20007c00

000103b4 <hal_flash_check_addr>:
}

static int
hal_flash_check_addr(const struct hal_flash *hf, uint32_t addr)
{
    if (addr < hf->hf_base_addr || addr > hf->hf_base_addr + hf->hf_size) {
   103b4:	6843      	ldr	r3, [r0, #4]
   103b6:	428b      	cmp	r3, r1
   103b8:	d804      	bhi.n	103c4 <hal_flash_check_addr+0x10>
   103ba:	6880      	ldr	r0, [r0, #8]
   103bc:	1818      	adds	r0, r3, r0
   103be:	4288      	cmp	r0, r1
   103c0:	4180      	sbcs	r0, r0
        return -1;
    }
    return 0;
}
   103c2:	4770      	bx	lr
        return -1;
   103c4:	2001      	movs	r0, #1
   103c6:	4240      	negs	r0, r0
   103c8:	e7fb      	b.n	103c2 <hal_flash_check_addr+0xe>

000103ca <hal_flash_init>:
{
   103ca:	b570      	push	{r4, r5, r6, lr}
    int rc = 0;
   103cc:	2500      	movs	r5, #0
            rc = -1;
   103ce:	2601      	movs	r6, #1
    for (i = 0; ; i++) {
   103d0:	002c      	movs	r4, r5
            rc = -1;
   103d2:	4276      	negs	r6, r6
        hf = hal_bsp_flash_dev(i);
   103d4:	0020      	movs	r0, r4
   103d6:	f7fd fe37 	bl	e048 <hal_bsp_flash_dev>
        if (!hf) {
   103da:	2800      	cmp	r0, #0
   103dc:	d008      	beq.n	103f0 <hal_flash_init+0x26>
        if (hf->hf_itf->hff_init(hf)) {
   103de:	6803      	ldr	r3, [r0, #0]
   103e0:	691b      	ldr	r3, [r3, #16]
   103e2:	4798      	blx	r3
   103e4:	2800      	cmp	r0, #0
   103e6:	d000      	beq.n	103ea <hal_flash_init+0x20>
            rc = -1;
   103e8:	0035      	movs	r5, r6
    for (i = 0; ; i++) {
   103ea:	3401      	adds	r4, #1
   103ec:	b2e4      	uxtb	r4, r4
        hf = hal_bsp_flash_dev(i);
   103ee:	e7f1      	b.n	103d4 <hal_flash_init+0xa>
}
   103f0:	0028      	movs	r0, r5
   103f2:	bd70      	pop	{r4, r5, r6, pc}

000103f4 <hal_flash_read>:

int
hal_flash_read(uint8_t id, uint32_t address, void *dst, uint32_t num_bytes)
{
   103f4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
   103f6:	000d      	movs	r5, r1
   103f8:	9201      	str	r2, [sp, #4]
   103fa:	001e      	movs	r6, r3
    const struct hal_flash *hf;

    hf = hal_bsp_flash_dev(id);
   103fc:	f7fd fe24 	bl	e048 <hal_bsp_flash_dev>
   10400:	1e04      	subs	r4, r0, #0
    if (!hf) {
   10402:	d012      	beq.n	1042a <hal_flash_read+0x36>
        return -1;
    }
    if (hal_flash_check_addr(hf, address) ||
   10404:	0029      	movs	r1, r5
   10406:	f7ff ffd5 	bl	103b4 <hal_flash_check_addr>
   1040a:	2800      	cmp	r0, #0
   1040c:	d10d      	bne.n	1042a <hal_flash_read+0x36>
      hal_flash_check_addr(hf, address + num_bytes)) {
   1040e:	19a9      	adds	r1, r5, r6
   10410:	0020      	movs	r0, r4
   10412:	f7ff ffcf 	bl	103b4 <hal_flash_check_addr>
    if (hal_flash_check_addr(hf, address) ||
   10416:	2800      	cmp	r0, #0
   10418:	d107      	bne.n	1042a <hal_flash_read+0x36>
        return -1;
    }
    return hf->hf_itf->hff_read(hf, address, dst, num_bytes);
   1041a:	6823      	ldr	r3, [r4, #0]
   1041c:	9a01      	ldr	r2, [sp, #4]
   1041e:	681f      	ldr	r7, [r3, #0]
   10420:	0029      	movs	r1, r5
   10422:	0033      	movs	r3, r6
   10424:	0020      	movs	r0, r4
   10426:	47b8      	blx	r7
}
   10428:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
        return -1;
   1042a:	2001      	movs	r0, #1
   1042c:	4240      	negs	r0, r0
   1042e:	e7fb      	b.n	10428 <hal_flash_read+0x34>

00010430 <__gnu_thumb1_case_uqi>:
   10430:	b402      	push	{r1}
   10432:	4671      	mov	r1, lr
   10434:	0849      	lsrs	r1, r1, #1
   10436:	0049      	lsls	r1, r1, #1
   10438:	5c09      	ldrb	r1, [r1, r0]
   1043a:	0049      	lsls	r1, r1, #1
   1043c:	448e      	add	lr, r1
   1043e:	bc02      	pop	{r1}
   10440:	4770      	bx	lr
   10442:	46c0      	nop			; (mov r8, r8)

00010444 <__udivsi3>:
   10444:	2200      	movs	r2, #0
   10446:	0843      	lsrs	r3, r0, #1
   10448:	428b      	cmp	r3, r1
   1044a:	d374      	bcc.n	10536 <__udivsi3+0xf2>
   1044c:	0903      	lsrs	r3, r0, #4
   1044e:	428b      	cmp	r3, r1
   10450:	d35f      	bcc.n	10512 <__udivsi3+0xce>
   10452:	0a03      	lsrs	r3, r0, #8
   10454:	428b      	cmp	r3, r1
   10456:	d344      	bcc.n	104e2 <__udivsi3+0x9e>
   10458:	0b03      	lsrs	r3, r0, #12
   1045a:	428b      	cmp	r3, r1
   1045c:	d328      	bcc.n	104b0 <__udivsi3+0x6c>
   1045e:	0c03      	lsrs	r3, r0, #16
   10460:	428b      	cmp	r3, r1
   10462:	d30d      	bcc.n	10480 <__udivsi3+0x3c>
   10464:	22ff      	movs	r2, #255	; 0xff
   10466:	0209      	lsls	r1, r1, #8
   10468:	ba12      	rev	r2, r2
   1046a:	0c03      	lsrs	r3, r0, #16
   1046c:	428b      	cmp	r3, r1
   1046e:	d302      	bcc.n	10476 <__udivsi3+0x32>
   10470:	1212      	asrs	r2, r2, #8
   10472:	0209      	lsls	r1, r1, #8
   10474:	d065      	beq.n	10542 <__udivsi3+0xfe>
   10476:	0b03      	lsrs	r3, r0, #12
   10478:	428b      	cmp	r3, r1
   1047a:	d319      	bcc.n	104b0 <__udivsi3+0x6c>
   1047c:	e000      	b.n	10480 <__udivsi3+0x3c>
   1047e:	0a09      	lsrs	r1, r1, #8
   10480:	0bc3      	lsrs	r3, r0, #15
   10482:	428b      	cmp	r3, r1
   10484:	d301      	bcc.n	1048a <__udivsi3+0x46>
   10486:	03cb      	lsls	r3, r1, #15
   10488:	1ac0      	subs	r0, r0, r3
   1048a:	4152      	adcs	r2, r2
   1048c:	0b83      	lsrs	r3, r0, #14
   1048e:	428b      	cmp	r3, r1
   10490:	d301      	bcc.n	10496 <__udivsi3+0x52>
   10492:	038b      	lsls	r3, r1, #14
   10494:	1ac0      	subs	r0, r0, r3
   10496:	4152      	adcs	r2, r2
   10498:	0b43      	lsrs	r3, r0, #13
   1049a:	428b      	cmp	r3, r1
   1049c:	d301      	bcc.n	104a2 <__udivsi3+0x5e>
   1049e:	034b      	lsls	r3, r1, #13
   104a0:	1ac0      	subs	r0, r0, r3
   104a2:	4152      	adcs	r2, r2
   104a4:	0b03      	lsrs	r3, r0, #12
   104a6:	428b      	cmp	r3, r1
   104a8:	d301      	bcc.n	104ae <__udivsi3+0x6a>
   104aa:	030b      	lsls	r3, r1, #12
   104ac:	1ac0      	subs	r0, r0, r3
   104ae:	4152      	adcs	r2, r2
   104b0:	0ac3      	lsrs	r3, r0, #11
   104b2:	428b      	cmp	r3, r1
   104b4:	d301      	bcc.n	104ba <__udivsi3+0x76>
   104b6:	02cb      	lsls	r3, r1, #11
   104b8:	1ac0      	subs	r0, r0, r3
   104ba:	4152      	adcs	r2, r2
   104bc:	0a83      	lsrs	r3, r0, #10
   104be:	428b      	cmp	r3, r1
   104c0:	d301      	bcc.n	104c6 <__udivsi3+0x82>
   104c2:	028b      	lsls	r3, r1, #10
   104c4:	1ac0      	subs	r0, r0, r3
   104c6:	4152      	adcs	r2, r2
   104c8:	0a43      	lsrs	r3, r0, #9
   104ca:	428b      	cmp	r3, r1
   104cc:	d301      	bcc.n	104d2 <__udivsi3+0x8e>
   104ce:	024b      	lsls	r3, r1, #9
   104d0:	1ac0      	subs	r0, r0, r3
   104d2:	4152      	adcs	r2, r2
   104d4:	0a03      	lsrs	r3, r0, #8
   104d6:	428b      	cmp	r3, r1
   104d8:	d301      	bcc.n	104de <__udivsi3+0x9a>
   104da:	020b      	lsls	r3, r1, #8
   104dc:	1ac0      	subs	r0, r0, r3
   104de:	4152      	adcs	r2, r2
   104e0:	d2cd      	bcs.n	1047e <__udivsi3+0x3a>
   104e2:	09c3      	lsrs	r3, r0, #7
   104e4:	428b      	cmp	r3, r1
   104e6:	d301      	bcc.n	104ec <__udivsi3+0xa8>
   104e8:	01cb      	lsls	r3, r1, #7
   104ea:	1ac0      	subs	r0, r0, r3
   104ec:	4152      	adcs	r2, r2
   104ee:	0983      	lsrs	r3, r0, #6
   104f0:	428b      	cmp	r3, r1
   104f2:	d301      	bcc.n	104f8 <__udivsi3+0xb4>
   104f4:	018b      	lsls	r3, r1, #6
   104f6:	1ac0      	subs	r0, r0, r3
   104f8:	4152      	adcs	r2, r2
   104fa:	0943      	lsrs	r3, r0, #5
   104fc:	428b      	cmp	r3, r1
   104fe:	d301      	bcc.n	10504 <__udivsi3+0xc0>
   10500:	014b      	lsls	r3, r1, #5
   10502:	1ac0      	subs	r0, r0, r3
   10504:	4152      	adcs	r2, r2
   10506:	0903      	lsrs	r3, r0, #4
   10508:	428b      	cmp	r3, r1
   1050a:	d301      	bcc.n	10510 <__udivsi3+0xcc>
   1050c:	010b      	lsls	r3, r1, #4
   1050e:	1ac0      	subs	r0, r0, r3
   10510:	4152      	adcs	r2, r2
   10512:	08c3      	lsrs	r3, r0, #3
   10514:	428b      	cmp	r3, r1
   10516:	d301      	bcc.n	1051c <__udivsi3+0xd8>
   10518:	00cb      	lsls	r3, r1, #3
   1051a:	1ac0      	subs	r0, r0, r3
   1051c:	4152      	adcs	r2, r2
   1051e:	0883      	lsrs	r3, r0, #2
   10520:	428b      	cmp	r3, r1
   10522:	d301      	bcc.n	10528 <__udivsi3+0xe4>
   10524:	008b      	lsls	r3, r1, #2
   10526:	1ac0      	subs	r0, r0, r3
   10528:	4152      	adcs	r2, r2
   1052a:	0843      	lsrs	r3, r0, #1
   1052c:	428b      	cmp	r3, r1
   1052e:	d301      	bcc.n	10534 <__udivsi3+0xf0>
   10530:	004b      	lsls	r3, r1, #1
   10532:	1ac0      	subs	r0, r0, r3
   10534:	4152      	adcs	r2, r2
   10536:	1a41      	subs	r1, r0, r1
   10538:	d200      	bcs.n	1053c <__udivsi3+0xf8>
   1053a:	4601      	mov	r1, r0
   1053c:	4152      	adcs	r2, r2
   1053e:	4610      	mov	r0, r2
   10540:	4770      	bx	lr
   10542:	e7ff      	b.n	10544 <__udivsi3+0x100>
   10544:	b501      	push	{r0, lr}
   10546:	2000      	movs	r0, #0
   10548:	f7fd f986 	bl	d858 <__aeabi_idiv0>
   1054c:	bd02      	pop	{r1, pc}
   1054e:	46c0      	nop			; (mov r8, r8)

00010550 <__aeabi_uidivmod>:
   10550:	2900      	cmp	r1, #0
   10552:	d0f7      	beq.n	10544 <__udivsi3+0x100>
   10554:	e776      	b.n	10444 <__udivsi3>
   10556:	4770      	bx	lr

00010558 <__aeabi_llsl>:
   10558:	4091      	lsls	r1, r2
   1055a:	1c03      	adds	r3, r0, #0
   1055c:	4090      	lsls	r0, r2
   1055e:	469c      	mov	ip, r3
   10560:	3a20      	subs	r2, #32
   10562:	4093      	lsls	r3, r2
   10564:	4319      	orrs	r1, r3
   10566:	4252      	negs	r2, r2
   10568:	4663      	mov	r3, ip
   1056a:	40d3      	lsrs	r3, r2
   1056c:	4319      	orrs	r1, r3
   1056e:	4770      	bx	lr

00010570 <__aeabi_uldivmod>:
   10570:	2b00      	cmp	r3, #0
   10572:	d111      	bne.n	10598 <__aeabi_uldivmod+0x28>
   10574:	2a00      	cmp	r2, #0
   10576:	d10f      	bne.n	10598 <__aeabi_uldivmod+0x28>
   10578:	2900      	cmp	r1, #0
   1057a:	d100      	bne.n	1057e <__aeabi_uldivmod+0xe>
   1057c:	2800      	cmp	r0, #0
   1057e:	d002      	beq.n	10586 <__aeabi_uldivmod+0x16>
   10580:	2100      	movs	r1, #0
   10582:	43c9      	mvns	r1, r1
   10584:	1c08      	adds	r0, r1, #0
   10586:	b407      	push	{r0, r1, r2}
   10588:	4802      	ldr	r0, [pc, #8]	; (10594 <__aeabi_uldivmod+0x24>)
   1058a:	a102      	add	r1, pc, #8	; (adr r1, 10594 <__aeabi_uldivmod+0x24>)
   1058c:	1840      	adds	r0, r0, r1
   1058e:	9002      	str	r0, [sp, #8]
   10590:	bd03      	pop	{r0, r1, pc}
   10592:	46c0      	nop			; (mov r8, r8)
   10594:	ffffd2c4 	.word	0xffffd2c4
   10598:	b403      	push	{r0, r1}
   1059a:	4668      	mov	r0, sp
   1059c:	b501      	push	{r0, lr}
   1059e:	9802      	ldr	r0, [sp, #8]
   105a0:	f000 f830 	bl	10604 <__udivmoddi4>
   105a4:	9b01      	ldr	r3, [sp, #4]
   105a6:	469e      	mov	lr, r3
   105a8:	b002      	add	sp, #8
   105aa:	bc0c      	pop	{r2, r3}
   105ac:	4770      	bx	lr
   105ae:	46c0      	nop			; (mov r8, r8)

000105b0 <__aeabi_lmul>:
   105b0:	b5f0      	push	{r4, r5, r6, r7, lr}
   105b2:	46ce      	mov	lr, r9
   105b4:	4647      	mov	r7, r8
   105b6:	0415      	lsls	r5, r2, #16
   105b8:	0c2d      	lsrs	r5, r5, #16
   105ba:	002e      	movs	r6, r5
   105bc:	b580      	push	{r7, lr}
   105be:	0407      	lsls	r7, r0, #16
   105c0:	0c14      	lsrs	r4, r2, #16
   105c2:	0c3f      	lsrs	r7, r7, #16
   105c4:	4699      	mov	r9, r3
   105c6:	0c03      	lsrs	r3, r0, #16
   105c8:	437e      	muls	r6, r7
   105ca:	435d      	muls	r5, r3
   105cc:	4367      	muls	r7, r4
   105ce:	4363      	muls	r3, r4
   105d0:	197f      	adds	r7, r7, r5
   105d2:	0c34      	lsrs	r4, r6, #16
   105d4:	19e4      	adds	r4, r4, r7
   105d6:	469c      	mov	ip, r3
   105d8:	42a5      	cmp	r5, r4
   105da:	d903      	bls.n	105e4 <__aeabi_lmul+0x34>
   105dc:	2380      	movs	r3, #128	; 0x80
   105de:	025b      	lsls	r3, r3, #9
   105e0:	4698      	mov	r8, r3
   105e2:	44c4      	add	ip, r8
   105e4:	464b      	mov	r3, r9
   105e6:	4343      	muls	r3, r0
   105e8:	4351      	muls	r1, r2
   105ea:	0c25      	lsrs	r5, r4, #16
   105ec:	0436      	lsls	r6, r6, #16
   105ee:	4465      	add	r5, ip
   105f0:	0c36      	lsrs	r6, r6, #16
   105f2:	0424      	lsls	r4, r4, #16
   105f4:	19a4      	adds	r4, r4, r6
   105f6:	195b      	adds	r3, r3, r5
   105f8:	1859      	adds	r1, r3, r1
   105fa:	0020      	movs	r0, r4
   105fc:	bc0c      	pop	{r2, r3}
   105fe:	4690      	mov	r8, r2
   10600:	4699      	mov	r9, r3
   10602:	bdf0      	pop	{r4, r5, r6, r7, pc}

00010604 <__udivmoddi4>:
   10604:	b5f0      	push	{r4, r5, r6, r7, lr}
   10606:	464f      	mov	r7, r9
   10608:	4646      	mov	r6, r8
   1060a:	46d6      	mov	lr, sl
   1060c:	b5c0      	push	{r6, r7, lr}
   1060e:	0004      	movs	r4, r0
   10610:	b082      	sub	sp, #8
   10612:	000d      	movs	r5, r1
   10614:	4691      	mov	r9, r2
   10616:	4698      	mov	r8, r3
   10618:	428b      	cmp	r3, r1
   1061a:	d82f      	bhi.n	1067c <__udivmoddi4+0x78>
   1061c:	d02c      	beq.n	10678 <__udivmoddi4+0x74>
   1061e:	4641      	mov	r1, r8
   10620:	4648      	mov	r0, r9
   10622:	f000 f8b1 	bl	10788 <__clzdi2>
   10626:	0029      	movs	r1, r5
   10628:	0006      	movs	r6, r0
   1062a:	0020      	movs	r0, r4
   1062c:	f000 f8ac 	bl	10788 <__clzdi2>
   10630:	1a33      	subs	r3, r6, r0
   10632:	469c      	mov	ip, r3
   10634:	3b20      	subs	r3, #32
   10636:	469a      	mov	sl, r3
   10638:	d500      	bpl.n	1063c <__udivmoddi4+0x38>
   1063a:	e076      	b.n	1072a <__udivmoddi4+0x126>
   1063c:	464b      	mov	r3, r9
   1063e:	4652      	mov	r2, sl
   10640:	4093      	lsls	r3, r2
   10642:	001f      	movs	r7, r3
   10644:	464b      	mov	r3, r9
   10646:	4662      	mov	r2, ip
   10648:	4093      	lsls	r3, r2
   1064a:	001e      	movs	r6, r3
   1064c:	42af      	cmp	r7, r5
   1064e:	d828      	bhi.n	106a2 <__udivmoddi4+0x9e>
   10650:	d025      	beq.n	1069e <__udivmoddi4+0x9a>
   10652:	4653      	mov	r3, sl
   10654:	1ba4      	subs	r4, r4, r6
   10656:	41bd      	sbcs	r5, r7
   10658:	2b00      	cmp	r3, #0
   1065a:	da00      	bge.n	1065e <__udivmoddi4+0x5a>
   1065c:	e07b      	b.n	10756 <__udivmoddi4+0x152>
   1065e:	2200      	movs	r2, #0
   10660:	2300      	movs	r3, #0
   10662:	9200      	str	r2, [sp, #0]
   10664:	9301      	str	r3, [sp, #4]
   10666:	2301      	movs	r3, #1
   10668:	4652      	mov	r2, sl
   1066a:	4093      	lsls	r3, r2
   1066c:	9301      	str	r3, [sp, #4]
   1066e:	2301      	movs	r3, #1
   10670:	4662      	mov	r2, ip
   10672:	4093      	lsls	r3, r2
   10674:	9300      	str	r3, [sp, #0]
   10676:	e018      	b.n	106aa <__udivmoddi4+0xa6>
   10678:	4282      	cmp	r2, r0
   1067a:	d9d0      	bls.n	1061e <__udivmoddi4+0x1a>
   1067c:	2200      	movs	r2, #0
   1067e:	2300      	movs	r3, #0
   10680:	9200      	str	r2, [sp, #0]
   10682:	9301      	str	r3, [sp, #4]
   10684:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   10686:	2b00      	cmp	r3, #0
   10688:	d001      	beq.n	1068e <__udivmoddi4+0x8a>
   1068a:	601c      	str	r4, [r3, #0]
   1068c:	605d      	str	r5, [r3, #4]
   1068e:	9800      	ldr	r0, [sp, #0]
   10690:	9901      	ldr	r1, [sp, #4]
   10692:	b002      	add	sp, #8
   10694:	bc1c      	pop	{r2, r3, r4}
   10696:	4690      	mov	r8, r2
   10698:	4699      	mov	r9, r3
   1069a:	46a2      	mov	sl, r4
   1069c:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1069e:	42a3      	cmp	r3, r4
   106a0:	d9d7      	bls.n	10652 <__udivmoddi4+0x4e>
   106a2:	2200      	movs	r2, #0
   106a4:	2300      	movs	r3, #0
   106a6:	9200      	str	r2, [sp, #0]
   106a8:	9301      	str	r3, [sp, #4]
   106aa:	4663      	mov	r3, ip
   106ac:	2b00      	cmp	r3, #0
   106ae:	d0e9      	beq.n	10684 <__udivmoddi4+0x80>
   106b0:	07fb      	lsls	r3, r7, #31
   106b2:	4698      	mov	r8, r3
   106b4:	4641      	mov	r1, r8
   106b6:	0872      	lsrs	r2, r6, #1
   106b8:	430a      	orrs	r2, r1
   106ba:	087b      	lsrs	r3, r7, #1
   106bc:	4666      	mov	r6, ip
   106be:	e00e      	b.n	106de <__udivmoddi4+0xda>
   106c0:	42ab      	cmp	r3, r5
   106c2:	d101      	bne.n	106c8 <__udivmoddi4+0xc4>
   106c4:	42a2      	cmp	r2, r4
   106c6:	d80c      	bhi.n	106e2 <__udivmoddi4+0xde>
   106c8:	1aa4      	subs	r4, r4, r2
   106ca:	419d      	sbcs	r5, r3
   106cc:	2001      	movs	r0, #1
   106ce:	1924      	adds	r4, r4, r4
   106d0:	416d      	adcs	r5, r5
   106d2:	2100      	movs	r1, #0
   106d4:	3e01      	subs	r6, #1
   106d6:	1824      	adds	r4, r4, r0
   106d8:	414d      	adcs	r5, r1
   106da:	2e00      	cmp	r6, #0
   106dc:	d006      	beq.n	106ec <__udivmoddi4+0xe8>
   106de:	42ab      	cmp	r3, r5
   106e0:	d9ee      	bls.n	106c0 <__udivmoddi4+0xbc>
   106e2:	3e01      	subs	r6, #1
   106e4:	1924      	adds	r4, r4, r4
   106e6:	416d      	adcs	r5, r5
   106e8:	2e00      	cmp	r6, #0
   106ea:	d1f8      	bne.n	106de <__udivmoddi4+0xda>
   106ec:	9800      	ldr	r0, [sp, #0]
   106ee:	9901      	ldr	r1, [sp, #4]
   106f0:	4653      	mov	r3, sl
   106f2:	1900      	adds	r0, r0, r4
   106f4:	4169      	adcs	r1, r5
   106f6:	2b00      	cmp	r3, #0
   106f8:	db23      	blt.n	10742 <__udivmoddi4+0x13e>
   106fa:	002b      	movs	r3, r5
   106fc:	4652      	mov	r2, sl
   106fe:	40d3      	lsrs	r3, r2
   10700:	002a      	movs	r2, r5
   10702:	4664      	mov	r4, ip
   10704:	40e2      	lsrs	r2, r4
   10706:	001c      	movs	r4, r3
   10708:	4653      	mov	r3, sl
   1070a:	0015      	movs	r5, r2
   1070c:	2b00      	cmp	r3, #0
   1070e:	db2d      	blt.n	1076c <__udivmoddi4+0x168>
   10710:	0026      	movs	r6, r4
   10712:	4657      	mov	r7, sl
   10714:	40be      	lsls	r6, r7
   10716:	0033      	movs	r3, r6
   10718:	0026      	movs	r6, r4
   1071a:	4667      	mov	r7, ip
   1071c:	40be      	lsls	r6, r7
   1071e:	0032      	movs	r2, r6
   10720:	1a80      	subs	r0, r0, r2
   10722:	4199      	sbcs	r1, r3
   10724:	9000      	str	r0, [sp, #0]
   10726:	9101      	str	r1, [sp, #4]
   10728:	e7ac      	b.n	10684 <__udivmoddi4+0x80>
   1072a:	4662      	mov	r2, ip
   1072c:	2320      	movs	r3, #32
   1072e:	1a9b      	subs	r3, r3, r2
   10730:	464a      	mov	r2, r9
   10732:	40da      	lsrs	r2, r3
   10734:	4661      	mov	r1, ip
   10736:	0013      	movs	r3, r2
   10738:	4642      	mov	r2, r8
   1073a:	408a      	lsls	r2, r1
   1073c:	0017      	movs	r7, r2
   1073e:	431f      	orrs	r7, r3
   10740:	e780      	b.n	10644 <__udivmoddi4+0x40>
   10742:	4662      	mov	r2, ip
   10744:	2320      	movs	r3, #32
   10746:	1a9b      	subs	r3, r3, r2
   10748:	002a      	movs	r2, r5
   1074a:	4666      	mov	r6, ip
   1074c:	409a      	lsls	r2, r3
   1074e:	0023      	movs	r3, r4
   10750:	40f3      	lsrs	r3, r6
   10752:	4313      	orrs	r3, r2
   10754:	e7d4      	b.n	10700 <__udivmoddi4+0xfc>
   10756:	4662      	mov	r2, ip
   10758:	2320      	movs	r3, #32
   1075a:	2100      	movs	r1, #0
   1075c:	1a9b      	subs	r3, r3, r2
   1075e:	2200      	movs	r2, #0
   10760:	9100      	str	r1, [sp, #0]
   10762:	9201      	str	r2, [sp, #4]
   10764:	2201      	movs	r2, #1
   10766:	40da      	lsrs	r2, r3
   10768:	9201      	str	r2, [sp, #4]
   1076a:	e780      	b.n	1066e <__udivmoddi4+0x6a>
   1076c:	2320      	movs	r3, #32
   1076e:	4662      	mov	r2, ip
   10770:	0026      	movs	r6, r4
   10772:	1a9b      	subs	r3, r3, r2
   10774:	40de      	lsrs	r6, r3
   10776:	002f      	movs	r7, r5
   10778:	46b0      	mov	r8, r6
   1077a:	4666      	mov	r6, ip
   1077c:	40b7      	lsls	r7, r6
   1077e:	4646      	mov	r6, r8
   10780:	003b      	movs	r3, r7
   10782:	4333      	orrs	r3, r6
   10784:	e7c8      	b.n	10718 <__udivmoddi4+0x114>
   10786:	46c0      	nop			; (mov r8, r8)

00010788 <__clzdi2>:
   10788:	b510      	push	{r4, lr}
   1078a:	2900      	cmp	r1, #0
   1078c:	d103      	bne.n	10796 <__clzdi2+0xe>
   1078e:	f000 f807 	bl	107a0 <__clzsi2>
   10792:	3020      	adds	r0, #32
   10794:	e002      	b.n	1079c <__clzdi2+0x14>
   10796:	1c08      	adds	r0, r1, #0
   10798:	f000 f802 	bl	107a0 <__clzsi2>
   1079c:	bd10      	pop	{r4, pc}
   1079e:	46c0      	nop			; (mov r8, r8)

000107a0 <__clzsi2>:
   107a0:	211c      	movs	r1, #28
   107a2:	2301      	movs	r3, #1
   107a4:	041b      	lsls	r3, r3, #16
   107a6:	4298      	cmp	r0, r3
   107a8:	d301      	bcc.n	107ae <__clzsi2+0xe>
   107aa:	0c00      	lsrs	r0, r0, #16
   107ac:	3910      	subs	r1, #16
   107ae:	0a1b      	lsrs	r3, r3, #8
   107b0:	4298      	cmp	r0, r3
   107b2:	d301      	bcc.n	107b8 <__clzsi2+0x18>
   107b4:	0a00      	lsrs	r0, r0, #8
   107b6:	3908      	subs	r1, #8
   107b8:	091b      	lsrs	r3, r3, #4
   107ba:	4298      	cmp	r0, r3
   107bc:	d301      	bcc.n	107c2 <__clzsi2+0x22>
   107be:	0900      	lsrs	r0, r0, #4
   107c0:	3904      	subs	r1, #4
   107c2:	a202      	add	r2, pc, #8	; (adr r2, 107cc <__clzsi2+0x2c>)
   107c4:	5c10      	ldrb	r0, [r2, r0]
   107c6:	1840      	adds	r0, r0, r1
   107c8:	4770      	bx	lr
   107ca:	46c0      	nop			; (mov r8, r8)
   107cc:	02020304 	.word	0x02020304
   107d0:	01010101 	.word	0x01010101
	...

000107dc <valid_pins>:
   107dc:	dbffffff c0000f0c 65737341 40207472     ........Assert @
   107ec:	25783020 55000a78 6e61686e 64656c64      0x%x..Unhandled
   107fc:	746e6920 75727265 28207470 29646c25      interrupt (%ld)
   1080c:	7865202c 74706563 206e6f69 30207073     , exception sp 0
   1081c:	38302578 000a786c 3a307220 30257830     x%08lx.. r0:0x%0
   1082c:	20786c38 3a317220 30257830 20786c38     8lx  r1:0x%08lx 
   1083c:	3a327220 30257830 20786c38 3a337220      r2:0x%08lx  r3:
   1084c:	30257830 0a786c38 34722000 2578303a     0x%08lx.. r4:0x%
   1085c:	786c3830 35722020 2578303a 786c3830     08lx  r5:0x%08lx
   1086c:	36722020 2578303a 786c3830 37722020       r6:0x%08lx  r7
   1087c:	2578303a 786c3830 7220000a 78303a38     :0x%08lx.. r8:0x
   1088c:	6c383025 72202078 78303a39 6c383025     %08lx  r9:0x%08l
   1089c:	31722078 78303a30 6c383025 31722078     x r10:0x%08lx r1
   108ac:	78303a31 6c383025 72000a78 303a3231     1:0x%08lx..r12:0
   108bc:	38302578 2020786c 303a726c 38302578     x%08lx  lr:0x%08
   108cc:	2020786c 303a6370 38302578 7020786c     lx  pc:0x%08lx p
   108dc:	303a7273 38302578 000a786c 52534349     sr:0x%08lx..ICSR
   108ec:	2578303a 786c3830 616d000a 69006e69     :0x%08lx..main.i
   108fc:	00656c64 7379736d 7200315f                       dle.msys_1.

00010907 <file_name>:
   10907:	72          	.byte	0x72
   10908:	736f7065 	.word	0x736f7065
   1090c:	6170612f 	.word	0x6170612f
   10910:	2d656863 	.word	0x2d656863
   10914:	656e796d 	.word	0x656e796d
   10918:	632d7477 	.word	0x632d7477
   1091c:	2f65726f 	.word	0x2f65726f
   10920:	6e72656b 	.word	0x6e72656b
   10924:	6f2f6c65 	.word	0x6f2f6c65
   10928:	72732f73 	.word	0x72732f73
   1092c:	72612f63 	.word	0x72612f63
   10930:	632f6863 	.word	0x632f6863
   10934:	6574726f 	.word	0x6574726f
   10938:	306d5f78 	.word	0x306d5f78
   1093c:	2f306d2f 	.word	0x2f306d2f
   10940:	5f4c4148 	.word	0x5f4c4148
   10944:	2e304d43 	.word	0x2e304d43
   10948:	0073      	.short	0x0073
   1094a:	5b1b      	.short	0x5b1b
   1094c:	00447525 	.word	0x00447525
   10950:	75255b1b 	.word	0x75255b1b
   10954:	0043      	.short	0x0043
   10956:	3025      	.short	0x3025
   10958:	20756c36 	.word	0x20756c36
   1095c:	00          	.byte	0x00
   1095d:	75          	.byte	0x75
   1095e:	7261      	.short	0x7261
   10960:	00003074 	.word	0x00003074

00010964 <uart_cfgs>:
   10964:	42001000 00310000 00000000 00000000     ...B..1.........
	...
   1097c:	000a0003 000b0003                       ........

00010984 <samd21_flash_funcs>:
   10984:	0000e313 0000e285 0000e259 0000e229     ........Y...)...
   10994:	0000e1cd                                ....

00010998 <CSWTCH.32>:
   10998:	00008000 00008000 00008000 007a1200     ..............z.
   109a8:	02dc6c00 05b8d800                       .l......

000109b0 <samd21_hal_timers>:
   109b0:	200024d4 00000000 00000000 42000800     .$. ...........B
   109c0:	42000c00 42001000 42001400 42001800     ...B...B...B...B
   109d0:	42001c00                                ...B

000109d4 <stdout>:
   109d4:	20000118                                ... 

000109d8 <sysflash_map_dflt>:
	...
   109e0:	0000c000 00000001 0000c000 00018000     ................
   109f0:	00000002 00024000 00018000 00000003     .....@..........
   10a00:	0003c000 00001c00 00000010 0003dc00     ................
   10a10:	00000400 00000011 0003e000 00002000     ............. ..

/home/pchizek/dev/press-reg/bin/targets/blinky/app/apps/blinky/blinky.elf:     file format elf32-littlearm

arm-none-eabi-objdump: section '.rodata' mentioned in a -j option, but not found in any input file

/home/pchizek/dev/press-reg/bin/targets/blinky/app/apps/blinky/blinky.elf:     file format elf32-littlearm

arm-none-eabi-objdump: section '.data' mentioned in a -j option, but not found in any input file
   text	   data	    bss	    dec	    hex	filename
  18968	    116	   9944	  29028	   7164	/home/pchizek/dev/press-reg/bin/targets/blinky/app/apps/blinky/blinky.elf
